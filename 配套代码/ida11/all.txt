def __init__(self):
def _get_module_cvar(self, modname):
def __getattr__(self, attr):
def __setattr__(self, attr, value):
def get_struct(str_, off, struct):
def unpack_db(buf, off):
def get_dw(buf, off):
def unpack_dw(buf, off):
def unpack_dd(buf, off):
def unpack_dq(buf, off):
def unpack_ea(buf, off):
def unpack_eavec(buf, base_ea):
def is_local(self):
def __init__(self):
def get_dexnum(self, from_ea):
def get_nn_var(self, from_ea):
def access_string(flags):
def as_string(s):
def idx_to_ea(self, from_ea, idx, tag):
def get_string(self, from_ea, string_idx):
def get_method_idx(self, ea):
def get_method(self, from_ea, method_idx):
def get_string_by_index(node, idx, tag):
def _primitive_type_label(typechar):
def is_wide_type(typechar):
def decorate_java_typename(desc):
def get_type_string(self, from_ea, type_idx):
def get_method_name(self, from_ea, method_idx):
def get_parameter_name(self, from_ea, idx):
def get_short_type_name(longname):
def get_full_type_name(longname):
def get_short_method_name(self, method):
def get_full_method_name(self, method):
def get_call_method_name(self, method):
def get_field(self, from_ea, field_idx):
def get_field_name(self, from_ea, field_idx):
def get_full_field_name(self, field_idx, field, field_name):
def get_short_field_name(self, field_idx, field, field_name):
def refs(ea, funcfirst, funcnext):
def CodeRefsTo(ea, flow):
def CodeRefsFrom(ea, flow):
def DataRefsTo(ea):
def DataRefsFrom(ea):
def XrefTypeName(typecode):
def XrefsFrom(ea, flags=0):
def XrefsTo(ea, flags=0):
def Threads():
def Heads(start=None, end=None):
def Functions(start=None, end=None):
def Chunks(start):
def Modules():
def Names():
def Segments():
def Entries():
def FuncItems(start):
def Structs():
def StructMembers(sid):
def DecodePrecedingInstruction(ea):
def DecodePreviousInstruction(ea):
def DecodeInstruction(ea):
def GetDataList(ea, count, itemsize=1):
def PutDataList(ea, datalist, itemsize=1):
def MapDataList(ea, length, func, wordsize=1):
def GetInputFileMD5():
def __init__(self, si):
def is_1_byte_encoding(self):
def _toseq(self, as_unicode):
def __str__(self):
def __unicode__(self):
def clear_cache(self):
def __init__(self, default_setup = False):
def refresh(self):
def setup(self,
def _get_item(self, index):
def __iter__(self):
def __getitem__(self, index):
def GetIdbDir():
def GetRegisterList():
def GetInstructionList():
def _Assemble(ea, line):
def Assemble(ea, line):
def _copy_obj(src, dest, skip_list = None):
def __init__(self, reg, dtype):
def __eq__(self, other):
def __getattr__(self, attr):
def __setattr__(self, attr, value):
def __getattr__(self, name):
def __setattr__(self, name, value):
def __init__(self, actions, flags = 0):
def __len__(self):
def __call__(self):
def ProcessUiActions(actions, flags=0):
def __init__(self):
def __str__(self):
def header(self):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
NET_ann_def = _ida_allins.NET_ann_def
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def get_auto_state(*args) -> "atype_t":
def set_auto_state(*args) -> "atype_t":
def __init__(self, *args):
def get_auto_display(*args) -> "bool":
def show_auto(*args) -> "void":
def show_addr(*args) -> "void":
def set_ida_state(*args) -> "idastate_t":
def may_create_stkvars(*args) -> "bool":
def may_trace_sp(*args) -> "bool":
def auto_mark_range(*args) -> "void":
def auto_mark(*args) -> "void":
def auto_unmark(*args) -> "void":
def plan_ea(*args) -> "void":
def plan_range(*args) -> "void":
def auto_make_code(*args) -> "void":
def auto_make_proc(*args) -> "void":
def reanalyze_callers(*args) -> "void":
def revert_ida_decisions(*args) -> "void":
def auto_apply_type(*args) -> "void":
def auto_apply_tail(*args) -> "void":
def plan_and_wait(*args) -> "int":
def auto_wait(*args) -> "bool":
def auto_wait_range(*args) -> "ssize_t":
def auto_make_step(*args) -> "bool":
def auto_cancel(*args) -> "void":
def auto_is_ok(*args) -> "bool":
def peek_auto_queue(*args) -> "ea_t":
def auto_get(*args) -> "ea_t":
def auto_recreate_insn(*args) -> "int":
def is_auto_enabled(*args) -> "bool":
def enable_auto(*args) -> "bool":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def init(self, *args) -> "void":
def reset(self, *args) -> "void":
def empty(self, *args) -> "bool":
def bitoff(self, *args) -> "uint":
def bitsize(self, *args) -> "uint":
def bytesize(self, *args) -> "uint":
def mask64(self, *args) -> "uint64":
def has_common(self, *args) -> "bool":
def apply_mask(self, *args) -> "bool":
def intersect(self, *args) -> "void":
def create_union(self, *args) -> "void":
def sub(self, *args) -> "bool":
def shift_down(self, *args) -> "void":
def shift_up(self, *args) -> "void":
def extract(self, *args) -> "bool":
def inject(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __str__(self, *args) -> "qstring":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "compiled_binpat_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "compiled_binpat_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "compiled_binpat_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< compiled_binpat_t >::const_iterator":
def end(self, *args) -> "qvector< compiled_binpat_t >::const_iterator":
def insert(self, *args) -> "qvector< compiled_binpat_t >::iterator":
def erase(self, *args) -> "qvector< compiled_binpat_t >::iterator":
def find(self, *args) -> "qvector< compiled_binpat_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "compiled_binpat_t const &":
def __setitem__(self, *args) -> "void":
def enable_flags(*args) -> "error_t":
def disable_flags(*args) -> "error_t":
def change_storage_type(*args) -> "error_t":
def next_addr(*args) -> "ea_t":
def prev_addr(*args) -> "ea_t":
def next_chunk(*args) -> "ea_t":
def prev_chunk(*args) -> "ea_t":
def chunk_start(*args) -> "ea_t":
def chunk_size(*args) -> "asize_t":
def free_chunk(*args) -> "ea_t":
def next_that(*args) -> "ea_t":
def next_unknown(*args) -> "ea_t":
def prev_that(*args) -> "ea_t":
def prev_unknown(*args) -> "ea_t":
def prev_head(*args) -> "ea_t":
def next_head(*args) -> "ea_t":
def prev_not_tail(*args) -> "ea_t":
def next_not_tail(*args) -> "ea_t":
def prev_visea(*args) -> "ea_t":
def next_visea(*args) -> "ea_t":
def get_item_head(*args) -> "ea_t":
def get_item_end(*args) -> "ea_t":
def calc_max_item_end(*args) -> "ea_t":
def get_item_size(*args) -> "asize_t":
def is_mapped(*args) -> "bool":
def get_flags_ex(*args) -> "flags_t":
def get_flags(*args) -> "flags_t":
def get_full_flags(*args) -> "flags_t":
def get_item_flag(*args) -> "flags_t":
def has_value(*args) -> "bool":
def del_value(*args) -> "void":
def is_loaded(*args) -> "bool":
def nbits(*args) -> "int":
def bytesize(*args) -> "int":
def get_byte(*args) -> "uchar":
def get_db_byte(*args) -> "uchar":
def get_word(*args) -> "ushort":
def get_dword(*args) -> "uint32":
def get_qword(*args) -> "uint64":
def get_wide_byte(*args) -> "uint64":
def get_wide_word(*args) -> "uint64":
def get_wide_dword(*args) -> "uint64":
def get_16bit(*args) -> "uint32":
def get_32bit(*args) -> "uint32":
def get_64bit(*args) -> "uint64":
def get_data_value(*args) -> "bool":
def get_original_byte(*args) -> "uint64":
def get_original_word(*args) -> "uint64":
def get_original_dword(*args) -> "uint64":
def get_original_qword(*args) -> "uint64":
def put_byte(*args) -> "bool":
def put_word(*args) -> "void":
def put_dword(*args) -> "void":
def put_qword(*args) -> "void":
def patch_byte(*args) -> "bool":
def patch_word(*args) -> "bool":
def patch_dword(*args) -> "bool":
def patch_qword(*args) -> "bool":
def revert_byte(*args) -> "bool":
def add_byte(*args) -> "void":
def add_word(*args) -> "void":
def add_dword(*args) -> "void":
def add_qword(*args) -> "void":
def get_zero_ranges(*args) -> "bool":
def put_bytes(*args) -> "void":
def patch_bytes(*args) -> "void":
def is_code(*args) -> "bool":
def f_is_code(*args) -> "bool":
def is_data(*args) -> "bool":
def f_is_data(*args) -> "bool":
def is_tail(*args) -> "bool":
def f_is_tail(*args) -> "bool":
def is_not_tail(*args) -> "bool":
def f_is_not_tail(*args) -> "bool":
def is_unknown(*args) -> "bool":
def is_head(*args) -> "bool":
def f_is_head(*args) -> "bool":
def del_items(*args) -> "bool":
def is_manual_insn(*args) -> "bool":
def get_manual_insn(*args) -> "qstring *":
def set_manual_insn(*args) -> "void":
def is_flow(*args) -> "bool":
def has_extra_cmts(*args) -> "bool":
def f_has_extra_cmts(*args) -> "bool":
def has_cmt(*args) -> "bool":
def f_has_cmt(*args) -> "bool":
def has_xref(*args) -> "bool":
def f_has_xref(*args) -> "bool":
def has_name(*args) -> "bool":
def f_has_name(*args) -> "bool":
def has_dummy_name(*args) -> "bool":
def f_has_dummy_name(*args) -> "bool":
def has_auto_name(*args) -> "bool":
def has_any_name(*args) -> "bool":
def has_user_name(*args) -> "bool":
def f_has_user_name(*args) -> "bool":
def is_invsign(*args) -> "bool":
def toggle_sign(*args) -> "bool":
def is_bnot(*args) -> "bool":
def toggle_bnot(*args) -> "bool":
def is_lzero(*args) -> "bool":
def set_lzero(*args) -> "bool":
def clr_lzero(*args) -> "bool":
def toggle_lzero(*args) -> "bool":
def leading_zero_important(*args) -> "bool":
def is_defarg0(*args) -> "bool":
def is_defarg1(*args) -> "bool":
def is_off0(*args) -> "bool":
def is_off1(*args) -> "bool":
def is_char0(*args) -> "bool":
def is_char1(*args) -> "bool":
def is_seg0(*args) -> "bool":
def is_seg1(*args) -> "bool":
def is_enum0(*args) -> "bool":
def is_enum1(*args) -> "bool":
def is_stroff0(*args) -> "bool":
def is_stroff1(*args) -> "bool":
def is_stkvar0(*args) -> "bool":
def is_stkvar1(*args) -> "bool":
def is_float0(*args) -> "bool":
def is_float1(*args) -> "bool":
def is_custfmt0(*args) -> "bool":
def is_custfmt1(*args) -> "bool":
def is_numop0(*args) -> "bool":
def is_numop1(*args) -> "bool":
def get_optype_flags0(*args) -> "flags_t":
def get_optype_flags1(*args) -> "flags_t":
def is_defarg(*args) -> "bool":
def is_off(*args) -> "bool":
def is_char(*args) -> "bool":
def is_seg(*args) -> "bool":
def is_enum(*args) -> "bool":
def is_manual(*args) -> "bool":
def is_stroff(*args) -> "bool":
def is_stkvar(*args) -> "bool":
def is_fltnum(*args) -> "bool":
def is_custfmt(*args) -> "bool":
def is_numop(*args) -> "bool":
def is_suspop(*args) -> "bool":
def op_adds_xrefs(*args) -> "bool":
def set_op_type(*args) -> "bool":
def op_seg(*args) -> "bool":
def op_enum(*args) -> "bool":
def get_enum_id(*args) -> "uchar *":
def op_stroff(*args) -> "bool":
def get_stroff_path(*args) -> "int":
def op_stkvar(*args) -> "bool":
def set_forced_operand(*args) -> "bool":
def get_forced_operand(*args) -> "qstring *":
def is_forced_operand(*args) -> "bool":
def char_flag(*args) -> "flags_t":
def off_flag(*args) -> "flags_t":
def enum_flag(*args) -> "flags_t":
def stroff_flag(*args) -> "flags_t":
def stkvar_flag(*args) -> "flags_t":
def flt_flag(*args) -> "flags_t":
def custfmt_flag(*args) -> "flags_t":
def seg_flag(*args) -> "flags_t":
def num_flag(*args) -> "flags_t":
def hex_flag(*args) -> "flags_t":
def dec_flag(*args) -> "flags_t":
def oct_flag(*args) -> "flags_t":
def bin_flag(*args) -> "flags_t":
def op_chr(*args) -> "bool":
def op_num(*args) -> "bool":
def op_hex(*args) -> "bool":
def op_dec(*args) -> "bool":
def op_oct(*args) -> "bool":
def op_bin(*args) -> "bool":
def op_flt(*args) -> "bool":
def op_custfmt(*args) -> "bool":
def clr_op_type(*args) -> "bool":
def get_default_radix(*args) -> "int":
def get_radix(*args) -> "int":
def code_flag(*args) -> "flags_t":
def byte_flag(*args) -> "flags_t":
def word_flag(*args) -> "flags_t":
def dword_flag(*args) -> "flags_t":
def qword_flag(*args) -> "flags_t":
def oword_flag(*args) -> "flags_t":
def yword_flag(*args) -> "flags_t":
def zword_flag(*args) -> "flags_t":
def tbyte_flag(*args) -> "flags_t":
def strlit_flag(*args) -> "flags_t":
def stru_flag(*args) -> "flags_t":
def cust_flag(*args) -> "flags_t":
def align_flag(*args) -> "flags_t":
def float_flag(*args) -> "flags_t":
def double_flag(*args) -> "flags_t":
def packreal_flag(*args) -> "flags_t":
def is_byte(*args) -> "bool":
def is_word(*args) -> "bool":
def is_dword(*args) -> "bool":
def is_qword(*args) -> "bool":
def is_oword(*args) -> "bool":
def is_yword(*args) -> "bool":
def is_zword(*args) -> "bool":
def is_tbyte(*args) -> "bool":
def is_float(*args) -> "bool":
def is_double(*args) -> "bool":
def is_pack_real(*args) -> "bool":
def is_strlit(*args) -> "bool":
def is_struct(*args) -> "bool":
def is_align(*args) -> "bool":
def is_custom(*args) -> "bool":
def f_is_byte(*args) -> "bool":
def f_is_word(*args) -> "bool":
def f_is_dword(*args) -> "bool":
def f_is_qword(*args) -> "bool":
def f_is_oword(*args) -> "bool":
def f_is_yword(*args) -> "bool":
def f_is_tbyte(*args) -> "bool":
def f_is_float(*args) -> "bool":
def f_is_double(*args) -> "bool":
def f_is_pack_real(*args) -> "bool":
def f_is_strlit(*args) -> "bool":
def f_is_struct(*args) -> "bool":
def f_is_align(*args) -> "bool":
def f_is_custom(*args) -> "bool":
def is_same_data_type(*args) -> "bool":
def get_flags_by_size(*args) -> "flags_t":
def create_data(*args) -> "bool":
def calc_dflags(*args) -> "flags_t":
def create_byte(*args) -> "bool":
def create_word(*args) -> "bool":
def create_dword(*args) -> "bool":
def create_qword(*args) -> "bool":
def create_oword(*args) -> "bool":
def create_yword(*args) -> "bool":
def create_zword(*args) -> "bool":
def create_tbyte(*args) -> "bool":
def create_float(*args) -> "bool":
def create_double(*args) -> "bool":
def create_packed_real(*args) -> "bool":
def create_struct(*args) -> "bool":
def create_custdata(*args) -> "bool":
def create_align(*args) -> "bool":
def calc_min_align(*args) -> "int":
def calc_max_align(*args) -> "int":
def calc_def_align(*args) -> "int":
def create_16bit_data(*args) -> "bool":
def create_32bit_data(*args) -> "bool":
def get_max_strlit_length(*args) -> "size_t":
def create_strlit(*args) -> "bool":
def get_opinfo(*args) -> "opinfo_t *":
def set_opinfo(*args) -> "bool":
def get_data_elsize(*args) -> "asize_t":
def get_full_data_elsize(*args) -> "asize_t":
def is_varsize_item(*args) -> "int":
def can_define_item(*args) -> "bool":
def has_immd(*args) -> "bool":
def is_func(*args) -> "bool":
def set_immd(*args) -> "bool":
def is_present_in_menus(self, *args) -> "bool":
def __init__(self, *args):
def __get_id(self, *args) -> "int":
def __init__(self, *args):
def is_present_in_menus(self, *args) -> "bool":
def __init__(self, *args):
def __get_id(self, *args) -> "int":
def __init__(self, *args):
def get_custom_data_type(*args) -> "data_type_t const *":
def get_custom_data_format(*args) -> "data_format_t const *":
def attach_custom_data_format(*args) -> "bool":
def detach_custom_data_format(*args) -> "bool":
def is_attached_custom_data_format(*args) -> "bool":
def get_custom_data_types(*args) -> "int":
def get_custom_data_formats(*args) -> "int":
def find_custom_data_type(*args) -> "int":
def find_custom_data_format(*args) -> "int":
def set_cmt(*args) -> "bool":
def get_cmt(*args) -> "qstring *":
def append_cmt(*args) -> "bool":
def get_predef_insn_cmt(*args) -> "qstring *":
def find_byte(*args) -> "ea_t":
def find_byter(*args) -> "ea_t":
def __init__(self, *args):
def all_bytes_defined(self, *args) -> "bool":
def qclear(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def parse_binpat_str(*args) -> "qstring *":
def bin_search3(*args) -> "size_t *":
def next_inited(*args) -> "ea_t":
def prev_inited(*args) -> "ea_t":
def equal_bytes(*args) -> "bool":
def __init__(self, *args):
def update_hidden_range(*args) -> "bool":
def add_hidden_range(*args) -> "bool":
def get_hidden_range(*args) -> "hidden_range_t *":
def getn_hidden_range(*args) -> "hidden_range_t *":
def get_hidden_range_qty(*args) -> "int":
def get_hidden_range_num(*args) -> "int":
def get_prev_hidden_range(*args) -> "hidden_range_t *":
def get_next_hidden_range(*args) -> "hidden_range_t *":
def get_first_hidden_range(*args) -> "hidden_range_t *":
def get_last_hidden_range(*args) -> "hidden_range_t *":
def del_hidden_range(*args) -> "bool":
def add_mapping(*args) -> "bool":
def del_mapping(*args) -> "void":
def use_mapping(*args) -> "ea_t":
def get_mappings_qty(*args) -> "size_t":
def get_mapping(*args) -> "ea_t *, ea_t *, asize_t *":
def visit_patched_bytes(*args) -> "int":
def get_bytes(*args) -> "PyObject *":
def get_bytes_and_mask(*args) -> "PyObject *":
def get_strlit_contents(*args) -> "PyObject *":
def bin_search(*args) -> "ea_t":
def print_strlit_type(*args) -> "PyObject *":
def get_octet(*args) -> "PyObject *":
def get_8bit(*args) -> "PyObject *":
def register_custom_data_type(*args) -> "int":
def unregister_custom_data_type(*args) -> "bool":
def register_custom_data_format(*args) -> "int":
def unregister_custom_data_format(*args) -> "bool":
def __walk_types_and_formats(formats, type_action, format_action, installing):
def register_data_types_and_formats(formats):
def __reg_format(df, dtid):
def __reg_type(dt):
def unregister_data_types_and_formats(formats):
def __unreg_format(df, dtid):
def __unreg_type(dt):
#def may_create_at(self, ea, nbytes):
#def calc_item_size(self, ea, maxsize):
#def printf(self, value, current_ea, operand_num, dtid):
#def scan(self, input, current_ea, operand_num):
#def analyze(self, current_ea, operand_num):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "bpt_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "bpt_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "bpt_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< bpt_t >::const_iterator":
def end(self, *args) -> "qvector< bpt_t >::const_iterator":
def insert(self, *args) -> "qvector< bpt_t >::iterator":
def erase(self, *args) -> "qvector< bpt_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "bpt_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "tev_reg_value_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "tev_reg_value_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "tev_reg_value_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< tev_reg_value_t >::const_iterator":
def end(self, *args) -> "qvector< tev_reg_value_t >::const_iterator":
def insert(self, *args) -> "qvector< tev_reg_value_t >::iterator":
def erase(self, *args) -> "qvector< tev_reg_value_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "tev_reg_value_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "tev_info_reg_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "tev_info_reg_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "tev_info_reg_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< tev_info_reg_t >::const_iterator":
def end(self, *args) -> "qvector< tev_info_reg_t >::const_iterator":
def insert(self, *args) -> "qvector< tev_info_reg_t >::iterator":
def erase(self, *args) -> "qvector< tev_info_reg_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "tev_info_reg_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "memreg_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "memreg_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "memreg_info_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< memreg_info_t >::const_iterator":
def end(self, *args) -> "qvector< memreg_info_t >::const_iterator":
def insert(self, *args) -> "qvector< memreg_info_t >::iterator":
def erase(self, *args) -> "qvector< memreg_info_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "memreg_info_t const &":
def __setitem__(self, *args) -> "void":
def run_to(*args) -> "bool":
def request_run_to(*args) -> "bool":
def run_requests(*args) -> "bool":
def get_running_request(*args) -> "ui_notification_t":
def is_request_running(*args) -> "bool":
def get_running_notification(*args) -> "dbg_notification_t":
def clear_requests_queue(*args) -> "void":
def get_process_state(*args) -> "int":
def set_process_state(*args) -> "int":
def invalidate_dbg_state(*args) -> "int":
def start_process(*args) -> "int":
def request_start_process(*args) -> "int":
def suspend_process(*args) -> "bool":
def request_suspend_process(*args) -> "bool":
def continue_process(*args) -> "bool":
def request_continue_process(*args) -> "bool":
def exit_process(*args) -> "bool":
def request_exit_process(*args) -> "bool":
def get_processes(*args) -> "ssize_t":
def attach_process(*args) -> "int":
def request_attach_process(*args) -> "int":
def detach_process(*args) -> "bool":
def request_detach_process(*args) -> "bool":
def is_debugger_busy(*args) -> "bool":
def get_thread_qty(*args) -> "int":
def getn_thread(*args) -> "thid_t":
def get_current_thread(*args) -> "thid_t":
def getn_thread_name(*args) -> "char const *":
def select_thread(*args) -> "bool":
def request_select_thread(*args) -> "bool":
def suspend_thread(*args) -> "int":
def request_suspend_thread(*args) -> "int":
def resume_thread(*args) -> "int":
def request_resume_thread(*args) -> "int":
def get_first_module(*args) -> "bool":
def get_next_module(*args) -> "bool":
def step_into(*args) -> "bool":
def request_step_into(*args) -> "bool":
def step_over(*args) -> "bool":
def request_step_over(*args) -> "bool":
def step_until_ret(*args) -> "bool":
def request_step_until_ret(*args) -> "bool":
def set_resume_mode(*args) -> "bool":
def request_set_resume_mode(*args) -> "bool":
def get_dbg_reg_info(*args) -> "bool":
def get_sp_val(*args) -> "uint64 *":
def get_ip_val(*args) -> "uint64 *":
def is_reg_integer(*args) -> "bool":
def is_reg_float(*args) -> "bool":
def is_reg_custom(*args) -> "bool":
def set_bptloc_string(*args) -> "int":
def get_bptloc_string(*args) -> "char const *":
def __init__(self, *args):
def type(self, *args) -> "bpt_loctype_t":
def is_empty_path(self, *args) -> "bool":
def path(self, *args) -> "char const *":
def symbol(self, *args) -> "char const *":
def lineno(self, *args) -> "int":
def offset(self, *args) -> "uval_t":
def ea(self, *args) -> "ea_t":
def __init__(self, *args):
def set_abs_bpt(self, *args) -> "void":
def set_src_bpt(self, *args) -> "void":
def set_sym_bpt(self, *args) -> "void":
def set_rel_bpt(self, *args) -> "void":
def compare(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def __init__(self, *args):
def is_hwbpt(self, *args) -> "bool":
def enabled(self, *args) -> "bool":
def is_low_level(self, *args) -> "bool":
def badbpt(self, *args) -> "bool":
def listbpt(self, *args) -> "bool":
def is_compiled(self, *args) -> "bool":
def is_active(self, *args) -> "bool":
def is_partially_active(self, *args) -> "bool":
def is_inactive(self, *args) -> "bool":
def is_page_bpt(self, *args) -> "bool":
def get_size(self, *args) -> "int":
def set_abs_bpt(self, *args) -> "void":
def set_src_bpt(self, *args) -> "void":
def set_sym_bpt(self, *args) -> "void":
def set_rel_bpt(self, *args) -> "void":
def is_absbpt(self, *args) -> "bool":
def is_relbpt(self, *args) -> "bool":
def is_symbpt(self, *args) -> "bool":
def is_srcbpt(self, *args) -> "bool":
def is_tracemodebpt(self, *args) -> "bool":
def is_traceonbpt(self, *args) -> "bool":
def is_traceoffbpt(self, *args) -> "bool":
def set_trace_action(self, *args) -> "bool":
def get_cnd_elang_idx(self, *args) -> "size_t":
def get_bpt_qty(*args) -> "int":
def getn_bpt(*args) -> "bool":
def get_bpt(*args) -> "bool":
def exist_bpt(*args) -> "bool":
def add_bpt(*args) -> "bool":
def request_add_bpt(*args) -> "bool":
def del_bpt(*args) -> "bool":
def request_del_bpt(*args) -> "bool":
def update_bpt(*args) -> "bool":
def find_bpt(*args) -> "bool":
def enable_bpt(*args) -> "bool":
def disable_bpt(*args) -> "bool":
def request_enable_bpt(*args) -> "bool":
def request_disable_bpt(*args) -> "bool":
def check_bpt(*args) -> "int":
def set_trace_size(*args) -> "bool":
def clear_trace(*args) -> "void":
def request_clear_trace(*args) -> "void":
def is_step_trace_enabled(*args) -> "bool":
def enable_step_trace(*args) -> "bool":
def disable_step_trace(*args) -> "bool":
def request_enable_step_trace(*args) -> "bool":
def request_disable_step_trace(*args) -> "bool":
def get_step_trace_options(*args) -> "int":
def set_step_trace_options(*args) -> "void":
def request_set_step_trace_options(*args) -> "void":
def is_insn_trace_enabled(*args) -> "bool":
def enable_insn_trace(*args) -> "bool":
def disable_insn_trace(*args) -> "bool":
def request_enable_insn_trace(*args) -> "bool":
def request_disable_insn_trace(*args) -> "bool":
def get_insn_trace_options(*args) -> "int":
def set_insn_trace_options(*args) -> "void":
def request_set_insn_trace_options(*args) -> "void":
def is_func_trace_enabled(*args) -> "bool":
def enable_func_trace(*args) -> "bool":
def disable_func_trace(*args) -> "bool":
def request_enable_func_trace(*args) -> "bool":
def request_disable_func_trace(*args) -> "bool":
def get_func_trace_options(*args) -> "int":
def set_func_trace_options(*args) -> "void":
def request_set_func_trace_options(*args) -> "void":
def enable_bblk_trace(*args) -> "bool":
def disable_bblk_trace(*args) -> "bool":
def request_enable_bblk_trace(*args) -> "bool":
def request_disable_bblk_trace(*args) -> "bool":
def is_bblk_trace_enabled(*args) -> "bool":
def get_bblk_trace_options(*args) -> "int":
def set_bblk_trace_options(*args) -> "void":
def request_set_bblk_trace_options(*args) -> "void":
def __init__(self, *args):
def get_bytes(self, *args) -> "PyObject *":
def __init__(self, *args):
def get_tev_qty(*args) -> "int":
def get_tev_info(*args) -> "bool":
def get_insn_tev_reg_val(*args) -> "bool":
def get_insn_tev_reg_mem(*args) -> "bool":
def get_insn_tev_reg_result(*args) -> "bool":
def get_call_tev_callee(*args) -> "ea_t":
def get_ret_tev_return(*args) -> "ea_t":
def get_bpt_tev_ea(*args) -> "ea_t":
def get_tev_memory_info(*args) -> "bool":
def get_tev_event(*args) -> "bool":
def get_trace_base_address(*args) -> "ea_t":
def set_trace_base_address(*args) -> "void":
def dbg_add_thread(*args) -> "void":
def dbg_del_thread(*args) -> "void":
def dbg_add_tev(*args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def dbg_add_many_tevs(*args) -> "bool":
def dbg_add_insn_tev(*args) -> "bool":
def dbg_add_bpt_tev(*args) -> "bool":
def dbg_add_call_tev(*args) -> "void":
def dbg_add_ret_tev(*args) -> "void":
def dbg_add_debug_event(*args) -> "void":
def load_trace_file(*args) -> "qstring *":
def save_trace_file(*args) -> "bool":
def is_valid_trace_file(*args) -> "bool":
def set_trace_file_desc(*args) -> "bool":
def get_trace_file_desc(*args) -> "qstring *":
def choose_trace_file(*args) -> "qstring *":
def diff_trace_file(*args) -> "bool":
def graph_trace(*args) -> "bool":
def set_highlight_trace_options(*args) -> "void":
def set_trace_platform(*args) -> "void":
def get_trace_platform(*args) -> "char const *":
def set_trace_dynamic_register_set(*args) -> "void":
def get_trace_dynamic_register_set(*args) -> "void":
def wait_for_next_event(*args) -> "dbg_event_code_t":
def get_debug_event(*args) -> "debug_event_t const *":
def set_debugger_options(*args) -> "uint":
def set_remote_debugger(*args) -> "void":
def get_process_options(*args) -> "qstring *, qstring *, qstring *, qstring *, qstring *, int *":
def set_process_options(*args) -> "void":
def retrieve_exceptions(*args) -> "excvec_t *":
def store_exceptions(*args) -> "bool":
def define_exception(*args) -> "char const *":
def __init__(self, *args):
def create_source_viewer(*args) -> "source_view_t *":
def get_dbg_byte(*args) -> "bool":
def put_dbg_byte(*args) -> "bool":
def invalidate_dbgmem_config(*args) -> "void":
def invalidate_dbgmem_contents(*args) -> "void":
def is_debugger_on(*args) -> "bool":
def is_debugger_memory(*args) -> "bool":
def get_tev_ea(*args) -> "ea_t":
def get_tev_type(*args) -> "int":
def get_tev_tid(*args) -> "int":
def bring_debugger_to_front(*args) -> "void":
def set_manual_regions(*args) -> "void":
def edit_manual_regions(*args) -> "void":
def enable_manual_regions(*args) -> "void":
def handle_debug_event(*args) -> "int":
def add_virt_module(*args) -> "bool":
def del_virt_module(*args) -> "bool":
def internal_ioctl(*args) -> "int":
def get_reg_vals(*args) -> "int":
def get_dbg_memory_info(*args) -> "int":
def set_bpt_group(*args) -> "bool":
def set_bptloc_group(*args) -> "bool":
def get_bpt_group(*args) -> "qstring *":
def rename_bptgrp(*args) -> "bool":
def del_bptgrp(*args) -> "bool":
def get_grp_bpts(*args) -> "ssize_t":
def enable_bptgrp(*args) -> "int":
def get_local_vars(*args) -> "bool":
def srcdbg_request_step_into(*args) -> "bool":
def srcdbg_request_step_over(*args) -> "bool":
def srcdbg_request_step_until_ret(*args) -> "bool":
def hide_all_bpts(*args) -> "int":
def read_dbg_memory(*args) -> "ssize_t":
def get_module_info(*args) -> "bool":
def dbg_bin_search(*args) -> "uint64 *, qstring *":
def load_debugger(*args) -> "bool":
def collect_stack_trace(*args) -> "bool":
def get_global_var(*args) -> "bool":
def get_local_var(*args) -> "bool":
def get_srcinfo_provider(*args) -> "srcinfo_provider_t *":
def get_current_source_file(*args) -> "qstring *":
def get_current_source_line(*args) -> "int":
def add_path_mapping(*args) -> "void":
def srcdbg_step_into(*args) -> "bool":
def srcdbg_step_over(*args) -> "bool":
def srcdbg_step_until_ret(*args) -> "bool":
def set_debugger_event_cond(*args) -> "void":
def get_debugger_event_cond(*args) -> "char const *":
def get_manual_regions(*args) -> "PyObject *":
def dbg_is_loaded(*args) -> "bool":
def refresh_debugger_memory(*args) -> "PyObject *":
def __init__(self, *args):
def hook(self, *args) -> "bool":
def unhook(self, *args) -> "bool":
def dbg_process_start(self, *args) -> "void":
def dbg_process_exit(self, *args) -> "void":
def dbg_process_attach(self, *args) -> "void":
def dbg_process_detach(self, *args) -> "void":
def dbg_thread_start(self, *args) -> "void":
def dbg_thread_exit(self, *args) -> "void":
def dbg_library_load(self, *args) -> "void":
def dbg_library_unload(self, *args) -> "void":
def dbg_information(self, *args) -> "void":
def dbg_exception(self, *args) -> "int":
def dbg_suspend_process(self, *args) -> "void":
def dbg_bpt(self, *args) -> "int":
def dbg_trace(self, *args) -> "int":
def dbg_request_error(self, *args) -> "void":
def dbg_step_into(self, *args) -> "void":
def dbg_step_over(self, *args) -> "void":
def dbg_run_to(self, *args) -> "void":
def dbg_step_until_ret(self, *args) -> "void":
def dbg_bpt_changed(self, *args) -> "void":
def dbg_started_loading_bpts(self, *args) -> "void":
def dbg_finished_loading_bpts(self, *args) -> "void":
def __disown__(self):
def list_bptgrps(*args) -> "PyObject *":
def internal_get_sreg_base(*args) -> "ea_t":
def write_dbg_memory(*args) -> "ssize_t":
def dbg_can_query(*args) -> "bool":
def set_reg_val(*args) -> "PyObject *":
def request_set_reg_val(*args) -> "PyObject *":
def get_reg_val(*args) -> "PyObject *":
def get_tev_reg_val(tev, reg):
def get_tev_reg_mem_qty(tev):
def get_tev_reg_mem(tev, idx):
def get_tev_reg_mem_ea(tev, idx):
def send_dbg_command(command):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "direntry_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "direntry_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "direntry_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< direntry_t >::const_iterator":
def end(self, *args) -> "qvector< direntry_t >::const_iterator":
def insert(self, *args) -> "qvector< direntry_t >::iterator":
def erase(self, *args) -> "qvector< direntry_t >::iterator":
def find(self, *args) -> "qvector< direntry_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "direntry_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "dirtree_cursor_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "dirtree_cursor_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "dirtree_cursor_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< dirtree_cursor_t >::const_iterator":
def end(self, *args) -> "qvector< dirtree_cursor_t >::const_iterator":
def insert(self, *args) -> "qvector< dirtree_cursor_t >::iterator":
def erase(self, *args) -> "qvector< dirtree_cursor_t >::iterator":
def find(self, *args) -> "qvector< dirtree_cursor_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "dirtree_cursor_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def valid(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __init__(self, *args):
def get_name(self, *args) -> "bool":
def get_inode(self, *args) -> "inode_t":
def get_attrs(self, *args) -> "qstring":
def rename_inode(self, *args) -> "bool":
def unlink_inode(self, *args) -> "void":
def __disown__(self):
def __init__(self, *args):
def valid(self, *args) -> "bool":
def is_root_cursor(self, *args) -> "bool":
def set_root_cursor(self, *args) -> "void":
def root_cursor(*args) -> "dirtree_cursor_t":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def dirtree_cursor_t_root_cursor(*args) -> "dirtree_cursor_t":
def __init__(self, *args):
def __init__(self, *args):
def visit(self, *args) -> "ssize_t":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def errstr(*args) -> "char const *":
def chdir(self, *args) -> "dterr_t":
def getcwd(self, *args) -> "qstring":
def get_abspath(self, *args) -> "qstring":
def resolve_cursor(self, *args) -> "direntry_t":
def resolve_path(self, *args) -> "direntry_t":
def isdir(self, *args) -> "bool":
def isfile(self, *args) -> "bool":
def get_entry_name(self, *args) -> "qstring":
def get_dir_size(self, *args) -> "ssize_t":
def get_entry_attrs(self, *args) -> "qstring":
def findfirst(self, *args) -> "bool":
def findnext(self, *args) -> "bool":
def mkdir(self, *args) -> "dterr_t":
def rmdir(self, *args) -> "dterr_t":
def link(self, *args) -> "dterr_t":
def unlink(self, *args) -> "dterr_t":
def rename(self, *args) -> "dterr_t":
def get_rank(self, *args) -> "ssize_t":
def change_rank(self, *args) -> "dterr_t":
def get_parent_cursor(self, *args) -> "dirtree_cursor_t":
def load(self, *args) -> "bool":
def save(self, *args) -> "bool":
def get_id(self, *args) -> "char const *":
def set_id(self, *args) -> "void":
def notify_dirtree(self, *args) -> "void":
def traverse(self, *args) -> "ssize_t":
def find_entry(self, *args) -> "dirtree_cursor_t":
def dirtree_t_errstr(*args) -> "char const *":
def get_std_dirtree(*args) -> "dirtree_t *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def idadir(*args) -> "char const *":
def getsysfile(*args) -> "char const *":
def get_user_idadir(*args) -> "char const *":
def get_ida_subdirs(*args) -> "qstrvec_t *":
def get_special_folder(*args) -> "size_t":
def visit_file(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def enumerate_files2(*args) -> "int":
def fopenWT(*args) -> "FILE *":
def fopenWB(*args) -> "FILE *":
def fopenRT(*args) -> "FILE *":
def fopenRB(*args) -> "FILE *":
def fopenM(*args) -> "FILE *":
def fopenA(*args) -> "FILE *":
def handle(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def read_ioports2(*args) -> "ssize_t":
def parse(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def choose_ioport_device2(*args) -> "bool":
def qlgetz(*args) -> "size_t":
def open_linput(*args) -> "linput_t *":
def __init__(self, *args, **kwargs):
def read(self, *args) -> "ssize_t":
def create_generic_linput(*args) -> "linput_t *":
def create_memory_linput(*args) -> "linput_t *":
def get_linput_type(*args) -> "linput_type_t":
def eclose(*args) -> "void":
def enumerate_files(*args) -> "PyObject *":
def create_bytearray_linput(*args) -> "linput_t *":
def close_linput(*args) -> "void":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def get_entry_qty(*args) -> "size_t":
def add_entry(*args) -> "bool":
def get_entry_ordinal(*args) -> "uval_t":
def get_entry(*args) -> "ea_t":
def get_entry_name(*args) -> "qstring *":
def rename_entry(*args) -> "bool":
def set_entry_forwarder(*args) -> "bool":
def get_entry_forwarder(*args) -> "qstring *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def get_enum_qty(*args) -> "size_t":
def getn_enum(*args) -> "enum_t":
def get_enum_idx(*args) -> "uval_t":
def get_enum(*args) -> "enum_t":
def is_bf(*args) -> "bool":
def is_enum_hidden(*args) -> "bool":
def set_enum_hidden(*args) -> "bool":
def is_enum_fromtil(*args) -> "bool":
def set_enum_fromtil(*args) -> "bool":
def is_ghost_enum(*args) -> "bool":
def set_enum_ghost(*args) -> "bool":
def get_enum_name(*args) -> "qstring *":
def get_enum_name2(*args) -> "qstring *":
def get_enum_width(*args) -> "size_t":
def set_enum_width(*args) -> "bool":
def get_enum_cmt(*args) -> "qstring *":
def get_enum_size(*args) -> "size_t":
def get_enum_flag(*args) -> "flags_t":
def get_enum_member_by_name(*args) -> "const_t":
def get_enum_member_value(*args) -> "uval_t":
def get_enum_member_enum(*args) -> "enum_t":
def get_enum_member_bmask(*args) -> "bmask_t":
def get_enum_member(*args) -> "const_t":
def get_first_bmask(*args) -> "bmask_t":
def get_last_bmask(*args) -> "bmask_t":
def get_next_bmask(*args) -> "bmask_t":
def get_prev_bmask(*args) -> "bmask_t":
def get_first_enum_member(*args) -> "uval_t":
def get_last_enum_member(*args) -> "uval_t":
def get_next_enum_member(*args) -> "uval_t":
def get_prev_enum_member(*args) -> "uval_t":
def get_enum_member_name(*args) -> "qstring *":
def get_enum_member_cmt(*args) -> "qstring *":
def get_first_serial_enum_member(*args) -> "uchar *":
def get_last_serial_enum_member(*args) -> "uchar *":
def get_next_serial_enum_member(*args) -> "uchar *":
def get_prev_serial_enum_member(*args) -> "uchar *":
def visit_enum_member(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def for_all_enum_members(*args) -> "int":
def get_enum_member_serial(*args) -> "uchar":
def get_enum_type_ordinal(*args) -> "int32":
def set_enum_type_ordinal(*args) -> "void":
def add_enum(*args) -> "enum_t":
def del_enum(*args) -> "void":
def set_enum_idx(*args) -> "bool":
def set_enum_bf(*args) -> "bool":
def set_enum_name(*args) -> "bool":
def set_enum_cmt(*args) -> "bool":
def set_enum_flag(*args) -> "bool":
def add_enum_member(*args) -> "int":
def del_enum_member(*args) -> "bool":
def set_enum_member_name(*args) -> "bool":
def set_enum_member_cmt(*args) -> "bool":
def is_one_bit_mask(*args) -> "bool":
def set_bmask_name(*args) -> "bool":
def get_bmask_name(*args) -> "qstring *":
def set_bmask_cmt(*args) -> "bool":
def get_bmask_cmt(*args) -> "qstring *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def compile_idc_file(*args) -> "qstring *":
def compile_idc_text(*args) -> "qstring *":
def py_get_call_idc_func(*args) -> "size_t":
def pyw_register_idc_func(*args) -> "size_t":
def pyw_unregister_idc_func(*args) -> "bool":
def pyw_convert_defvals(*args) -> "bool":
def py_add_idc_func(*args) -> "bool":
def eval_expr(*args) -> "qstring *":
def eval_idc_expr(*args) -> "qstring *":
def idcv_long(*args) -> "error_t":
def idcv_int64(*args) -> "error_t":
def idcv_num(*args) -> "error_t":
def idcv_string(*args) -> "error_t":
def idcv_float(*args) -> "error_t":
def idcv_object(*args) -> "error_t":
def move_idcv(*args) -> "error_t":
def copy_idcv(*args) -> "error_t":
def deep_copy_idcv(*args) -> "error_t":
def free_idcv(*args) -> "void":
def swap_idcvs(*args) -> "void":
def get_idcv_class_name(*args) -> "qstring *":
def get_idcv_attr(*args) -> "error_t":
def set_idcv_attr(*args) -> "error_t":
def del_idcv_attr(*args) -> "error_t":
def first_idcv_attr(*args) -> "char const *":
def last_idcv_attr(*args) -> "char const *":
def next_idcv_attr(*args) -> "char const *":
def prev_idcv_attr(*args) -> "char const *":
def print_idcv(*args) -> "qstring *":
def get_idcv_slice(*args) -> "error_t":
def set_idcv_slice(*args) -> "error_t":
def add_idc_class(*args) -> "idc_class_t *":
def find_idc_class(*args) -> "idc_class_t *":
def deref_idcv(*args) -> "idc_value_t *":
def create_idcv_ref(*args) -> "bool":
def add_idc_gvar(*args) -> "idc_value_t *":
def find_idc_gvar(*args) -> "idc_value_t *":
def __init__(self, *args):
def clear(self, *args) -> "void":
def qstr(self, *args) -> "qstring const &":
def c_str(self, *args) -> "char const *":
def u_str(self, *args) -> "uchar const *":
def swap(self, *args) -> "void":
def is_zero(self, *args) -> "bool":
def is_integral(self, *args) -> "bool":
def is_convertible(self, *args) -> "bool":
def _create_empty_string(self, *args) -> "void":
def create_empty_string(self, *args) -> "void":
def set_string(self, *args) -> "void":
def set_long(self, *args) -> "void":
def set_pvoid(self, *args) -> "void":
def set_int64(self, *args) -> "void":
def set_float(self, *args) -> "void":
def __init__(self, *args):
def find_idc_func(*args) -> "qstring *":
def set_style(self, *args) -> "void":
def prev_block_state(self, *args) -> "int32":
def cur_block_state(self, *args) -> "int32":
def set_block_state(self, *args) -> "void":
def __init__(self, *args):
def __disown__(self):
def set_header_path(*args) -> "bool":
def get_idc_filename(*args) -> "char const *":
def exec_system_script(*args) -> "bool":
def compile_idc_snippet(*args) -> "qstring *":
def exec_idc_script(*args) -> "qstring *":
def throw_idc_exception(*args) -> "error_t":
def __init__(self, *args):
def push_back(self, *args) -> "idc_value_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "idc_value_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "idc_value_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< idc_value_t >::const_iterator":
def end(self, *args) -> "qvector< idc_value_t >::const_iterator":
def insert(self, *args) -> "qvector< idc_value_t >::iterator":
def erase(self, *args) -> "qvector< idc_value_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "idc_value_t const &":
def __setitem__(self, *args) -> "void":
# typedef error_t idaapi idc_func_t(idc_value_t *argv,idc_value_t *r);
def call_idc_func__(*args):
def __init__(self, ctxptr):
def __call__(self, args, res):
def del_idc_func(name):
def add_idc_func(name, fp, args, defvals=(), flags=0):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def is_fixup_custom(*args) -> "bool":
def __init__(self, *args):
def get_type(self, *args) -> "fixup_type_t":
def set_type(self, *args) -> "void":
def set_type_and_flags(self, *args) -> "void":
def is_custom(self, *args) -> "bool":
def get_flags(self, *args) -> "uint32":
def is_extdef(self, *args) -> "bool":
def set_extdef(self, *args) -> "void":
def clr_extdef(self, *args) -> "void":
def is_unused(self, *args) -> "bool":
def set_unused(self, *args) -> "void":
def clr_unused(self, *args) -> "void":
def has_base(self, *args) -> "bool":
def was_created(self, *args) -> "bool":
def get_base(self, *args) -> "ea_t":
def set_base(self, *args) -> "void":
def set_sel(self, *args) -> "void":
def set_target_sel(self, *args) -> "void":
def set(self, *args) -> "void":
def get(self, *args) -> "bool":
def get_handler(self, *args) -> "fixup_handler_t const *":
def get_desc(self, *args) -> "char const *":
def calc_size(self, *args) -> "int":
def get_value(self, *args) -> "uval_t":
def patch_value(self, *args) -> "bool":
def get_fixup(*args) -> "bool":
def exists_fixup(*args) -> "bool":
def set_fixup(*args) -> "void":
def del_fixup(*args) -> "void":
def get_first_fixup_ea(*args) -> "ea_t":
def get_next_fixup_ea(*args) -> "ea_t":
def get_prev_fixup_ea(*args) -> "ea_t":
def get_fixup_handler(*args) -> "fixup_handler_t const *":
def get_fixup_value(*args) -> "uval_t":
def patch_fixup_value(*args) -> "bool":
def get_fixup_desc(*args) -> "fixup_data_t const &":
def calc_fixup_size(*args) -> "int":
def find_custom_fixup(*args) -> "fixup_type_t":
def __init__(self, *args):
def get_fixups(*args) -> "bool":
def contains_fixups(*args) -> "bool":
def gen_fix_fixups(*args) -> "void":
def handle_fixups_in_macro(*args) -> "bool":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def opened(self, *args) -> "bool":
def close(self, *args) -> "void":
def open(self, *args) -> "bool":
def from_fp(*args) -> "qfile_t *":
def from_capsule(*args) -> "qfile_t *":
def tmpfile(*args) -> "qfile_t *":
def get_fp(self, *args) -> "FILE *":
def seek(self, *args) -> "int":
def tell(self, *args) -> "int64":
def readbytes(self, *args) -> "PyObject *":
def read(self, *args) -> "PyObject *":
def gets(self, *args) -> "PyObject *":
def writebytes(self, *args) -> "int":
def write(self, *args) -> "int":
def puts(self, *args) -> "int":
def size(self, *args) -> "int64":
def flush(self, *args) -> "int":
def filename(self, *args) -> "PyObject *":
def get_byte(self, *args) -> "PyObject *":
def put_byte(self, *args) -> "int":
def qfile_t_from_fp(*args) -> "qfile_t *":
def qfile_t_from_capsule(*args) -> "qfile_t *":
def qfile_t_tmpfile(*args) -> "qfile_t *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "xreflist_entry_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "xreflist_entry_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "xreflist_entry_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< xreflist_entry_t >::const_iterator":
def end(self, *args) -> "qvector< xreflist_entry_t >::const_iterator":
def insert(self, *args) -> "qvector< xreflist_entry_t >::iterator":
def erase(self, *args) -> "qvector< xreflist_entry_t >::iterator":
def find(self, *args) -> "qvector< xreflist_entry_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "xreflist_entry_t const &":
def __setitem__(self, *args) -> "void":
def get_stkvar(*args) -> "PyObject *":
def is_funcarg_off(*args) -> "bool":
def lvar_off(*args) -> "sval_t":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def add_frame(*args) -> "bool":
def del_frame(*args) -> "bool":
def set_frame_size(*args) -> "bool":
def get_frame_size(*args) -> "asize_t":
def get_frame_retsize(*args) -> "int":
def get_frame_part(*args) -> "void":
def frame_off_args(*args) -> "ea_t":
def frame_off_retaddr(*args) -> "ea_t":
def frame_off_savregs(*args) -> "ea_t":
def frame_off_lvars(*args) -> "ea_t":
def get_frame(*args) -> "struc_t *":
def soff_to_fpoff(*args) -> "sval_t":
def update_fpd(*args) -> "bool":
def set_purged(*args) -> "bool":
def get_func_by_frame(*args) -> "ea_t":
def define_stkvar(*args) -> "bool":
def build_stkvar_name(*args) -> "qstring *":
def calc_stkvar_struc_offset(*args) -> "ea_t":
def free_regvar(*args) -> "void":
def __init__(self, *args):
def swap(self, *args) -> "void":
def add_regvar(*args) -> "int":
def find_regvar(*args) -> "regvar_t *":
def has_regvar(*args) -> "bool":
def rename_regvar(*args) -> "int":
def set_regvar_cmt(*args) -> "int":
def del_regvar(*args) -> "int":
def add_auto_stkpnt(*args) -> "bool":
def add_user_stkpnt(*args) -> "bool":
def del_stkpnt(*args) -> "bool":
def get_spd(*args) -> "sval_t":
def get_effective_spd(*args) -> "sval_t":
def get_sp_delta(*args) -> "sval_t":
def recalc_spd(*args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def build_stkvar_xrefs(*args) -> "void":
def get_min_spd_ea(*args) -> "ea_t":
def delete_unreferenced_stkvars(*args) -> "int":
def delete_wrong_stkvar_ops(*args) -> "int":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "stkpnt_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "regvar_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "range_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "unsigned long long const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "regarg_t const &":
def __setitem__(self, *args) -> "void":
def free_regarg(*args) -> "void":
def __init__(self, *args):
def swap(self, *args) -> "void":
def is_far(self, *args) -> "bool":
def does_return(self, *args) -> "bool":
def analyzed_sp(self, *args) -> "bool":
def need_prolog_analysis(self, *args) -> "bool":
def __init__(self, *args):
def __get_points__(self, *args) -> "dynamic_wrapped_array_t< stkpnt_t >":
def __get_regvars__(self, *args) -> "dynamic_wrapped_array_t< regvar_t >":
def __get_tails__(self, *args) -> "dynamic_wrapped_array_t< range_t >":
def __get_referers__(self, *args) -> "dynamic_wrapped_array_t< ea_t >":
def __get_regargs__(self, *args) -> "dynamic_wrapped_array_t< regarg_t >":
def addresses(self):
def code_items(self):
def data_items(self):
def head_items(self):
def not_tails(self):
def __iter__(self):
def is_func_entry(*args) -> "bool":
def is_func_tail(*args) -> "bool":
def lock_func_range(*args) -> "void":
def __init__(self, *args):
def is_func_locked(*args) -> "bool":
def get_func(*args) -> "func_t *":
def get_func_chunknum(*args) -> "int":
def func_contains(*args) -> "bool":
def is_same_func(*args) -> "bool":
def getn_func(*args) -> "func_t *":
def get_func_qty(*args) -> "size_t":
def get_func_num(*args) -> "int":
def get_prev_func(*args) -> "func_t *":
def get_next_func(*args) -> "func_t *":
def get_func_ranges(*args) -> "ea_t":
def get_func_cmt(*args) -> "qstring *":
def set_func_cmt(*args) -> "bool":
def update_func(*args) -> "bool":
def add_func_ex(*args) -> "bool":
def add_func(*args) -> "bool":
def del_func(*args) -> "bool":
def set_func_start(*args) -> "int":
def set_func_end(*args) -> "bool":
def reanalyze_function(*args) -> "void":
def find_func_bounds(*args) -> "int":
def get_func_name(*args) -> "qstring *":
def calc_func_size(*args) -> "asize_t":
def get_func_bitness(*args) -> "int":
def get_func_bits(*args) -> "int":
def get_func_bytes(*args) -> "int":
def is_visible_func(*args) -> "bool":
def is_finally_visible_func(*args) -> "bool":
def set_visible_func(*args) -> "void":
def set_func_name_if_jumpfunc(*args) -> "int":
def calc_thunk_func_target(*args) -> "ea_t *":
def func_does_return(*args) -> "bool":
def reanalyze_noret_flag(*args) -> "bool":
def set_noret_insn(*args) -> "bool":
def get_fchunk(*args) -> "func_t *":
def getn_fchunk(*args) -> "func_t *":
def get_fchunk_qty(*args) -> "size_t":
def get_fchunk_num(*args) -> "int":
def get_prev_fchunk(*args) -> "func_t *":
def get_next_fchunk(*args) -> "func_t *":
def append_func_tail(*args) -> "bool":
def remove_func_tail(*args) -> "bool":
def set_tail_owner(*args) -> "bool":
def func_tail_iterator_set(*args) -> "bool":
def func_tail_iterator_set_ea(*args) -> "bool":
def func_parent_iterator_set(*args) -> "bool":
def f_any(*args) -> "bool":
def __init__(self, *args):
def set(self, *args) -> "bool":
def set_ea(self, *args) -> "bool":
def set_range(self, *args) -> "bool":
def chunk(self, *args) -> "range_t const &":
def first(self, *args) -> "bool":
def last(self, *args) -> "bool":
def __next__(self, *args) -> "bool":
def prev(self, *args) -> "bool":
def main(self, *args) -> "bool":
def __iter__(self):
def __init__(self, *args):
def set(self, *args) -> "bool":
def set_range(self, *args) -> "bool":
def first(self, *args) -> "bool":
def last(self, *args) -> "bool":
def current(self, *args) -> "ea_t":
def chunk(self, *args) -> "range_t const &":
def __next__(self, *args) -> "bool":
def prev(self, *args) -> "bool":
def next_addr(self, *args) -> "bool":
def next_head(self, *args) -> "bool":
def next_code(self, *args) -> "bool":
def next_data(self, *args) -> "bool":
def next_not_tail(self, *args) -> "bool":
def prev_addr(self, *args) -> "bool":
def prev_head(self, *args) -> "bool":
def prev_code(self, *args) -> "bool":
def prev_data(self, *args) -> "bool":
def prev_not_tail(self, *args) -> "bool":
def decode_prev_insn(self, *args) -> "bool":
def decode_preceding_insn(self, *args) -> "bool":
def succ(self, *args) -> "bool":
def succ_code(self, *args) -> "bool":
def __iter__(self):
def addresses(self):
def code_items(self):
def data_items(self):
def head_items(self):
def not_tails(self):
def __init__(self, *args):
def set(self, *args) -> "bool":
def parent(self, *args) -> "ea_t":
def first(self, *args) -> "bool":
def last(self, *args) -> "bool":
def __next__(self, *args) -> "bool":
def prev(self, *args) -> "bool":
def reset_fnt(self, *args) -> "void":
def __iter__(self):
def get_prev_func_addr(*args) -> "ea_t":
def get_next_func_addr(*args) -> "ea_t":
def read_regargs(*args) -> "void":
def add_regarg(*args) -> "void":
def plan_to_apply_idasgn(*args) -> "int":
def apply_idasgn_to(*args) -> "int":
def get_idasgn_qty(*args) -> "int":
def get_current_idasgn(*args) -> "int":
def calc_idasgn_state(*args) -> "int":
def del_idasgn(*args) -> "int":
def get_idasgn_title(*args) -> "qstring *":
def apply_startup_sig(*args) -> "bool":
def try_to_add_libfunc(*args) -> "int":
def get_fchunk_referer(*args) -> "ea_t":
def get_idasgn_desc(*args) -> "PyObject *":
def get_idasgn_desc_with_matches(*args) -> "PyObject *":
def func_t__from_ptrval__(*args) -> "func_t *":
def calc_thunk_func_target(*args):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __ref__(self, *args) -> "int":
def get_node_label(self, *args) -> "char *":
def print_graph_attributes(self, *args) -> "void":
def print_node(self, *args) -> "bool":
def print_edge(self, *args) -> "bool":
def print_node_attributes(self, *args) -> "void":
def size(self, *args) -> "int":
def node_qty(self, *args) -> "int":
def exists(self, *args) -> "bool":
def entry(self, *args) -> "int":
def exit(self, *args) -> "int":
def nsucc(self, *args) -> "int":
def npred(self, *args) -> "int":
def succ(self, *args) -> "int":
def pred(self, *args) -> "int":
def empty(self, *args) -> "bool":
def get_node_color(self, *args) -> "bgcolor_t":
def get_edge_color(self, *args) -> "bgcolor_t":
def nedge(self, *args) -> "size_t":
def edge(self, *args) -> "int":
def front(self, *args) -> "int":
def begin(self, *args) -> "node_iterator":
def end(self, *args) -> "node_iterator":
def __init__(self, *args):
def __disown__(self):
def gen_gdl(*args) -> "void":
def display_gdl(*args) -> "int":
def gen_flow_graph(*args) -> "bool":
def gen_simple_call_chart(*args) -> "bool":
def gen_complex_call_chart(*args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def is_noret_block(*args) -> "bool":
def is_ret_block(*args) -> "bool":
def __init__(self, *args):
def create(self, *args) -> "void":
def append_to_flowchart(self, *args) -> "void":
def refresh(self, *args) -> "void":
def calc_block_type(self, *args) -> "fc_block_type_t":
def is_ret_block(self, *args) -> "bool":
def is_noret_block(self, *args) -> "bool":
def print_node_attributes(self, *args) -> "void":
def nsucc(self, *args) -> "int":
def npred(self, *args) -> "int":
def succ(self, *args) -> "int":
def pred(self, *args) -> "int":
def get_node_label(self, *args) -> "char *":
def size(self, *args) -> "int":
def print_names(self, *args) -> "bool":
def __getitem__(self, *args) -> "qbasic_block_t *":
def __init__(self, id, bb, fc):
def preds(self):
def succs(self):
def __init__(self, f=None, bounds=None, flags=0):
def refresh(self):
def _getitem(self, index):
def __iter__(self):
def __getitem__(self, index):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "selection_item_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "selection_item_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "selection_item_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< selection_item_t >::const_iterator":
def end(self, *args) -> "qvector< selection_item_t >::const_iterator":
def insert(self, *args) -> "qvector< selection_item_t >::iterator":
def erase(self, *args) -> "qvector< selection_item_t >::iterator":
def find(self, *args) -> "qvector< selection_item_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "selection_item_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "rect_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "rect_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "rect_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< rect_t >::const_iterator":
def end(self, *args) -> "qvector< rect_t >::const_iterator":
def insert(self, *args) -> "qvector< rect_t >::iterator":
def erase(self, *args) -> "qvector< rect_t >::iterator":
def find(self, *args) -> "qvector< rect_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "rect_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "point_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "point_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "point_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< point_t >::const_iterator":
def end(self, *args) -> "qvector< point_t >::const_iterator":
def insert(self, *args) -> "qvector< point_t >::iterator":
def erase(self, *args) -> "qvector< point_t >::iterator":
def find(self, *args) -> "qvector< point_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "point_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def valid_bg_color(self, *args) -> "bool":
def valid_frame_color(self, *args) -> "bool":
def valid_ea(self, *args) -> "bool":
def valid_text(self, *args) -> "bool":
def valid_flags(self, *args) -> "bool":
def get_flags_for_valid(self, *args) -> "uint32":
def get_node_info(*args) -> "bool":
def set_node_info(*args) -> "void":
def del_node_info(*args) -> "void":
def clr_node_info(*args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def size(self, *args) -> "size_t":
def set(self, *args) -> "void":
def clr(self, *args) -> "bool":
def node(self, *args) -> "int":
def order(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def __lt__(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def reinit(self, *args) -> "void":
def set_visited(self, *args) -> "void":
def is_visited(self, *args) -> "bool":
def visit_node(self, *args) -> "int":
def is_forbidden_edge(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def walk_forward(self, *args) -> "int":
def walk_backward(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def add(self, *args) -> "point_t &":
def sub(self, *args) -> "point_t &":
def negate(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def calc_dist(*args) -> "double":
def __init__(self, *args):
def __init__(self, *args):
def width(self, *args) -> "int":
def height(self, *args) -> "int":
def move_to(self, *args) -> "void":
def move_by(self, *args) -> "void":
def center(self, *args) -> "point_t":
def topleft(self, *args) -> "point_t":
def bottomright(self, *args) -> "point_t":
def grow(self, *args) -> "void":
def intersect(self, *args) -> "void":
def make_union(self, *args) -> "void":
def empty(self, *args) -> "bool":
def is_intersection_empty(self, *args) -> "bool":
def contains(self, *args) -> "bool":
def area(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def add(self, *args) -> "void":
def sub(self, *args) -> "void":
def negate(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def reverse_layout(self, *args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def compare(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def compare(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def has(self, *args) -> "bool":
def add(self, *args) -> "void":
def sub(self, *args) -> "void":
def add_node(self, *args) -> "void":
def del_node(self, *args) -> "void":
def add_point(self, *args) -> "void":
def del_point(self, *args) -> "void":
def nodes_count(self, *args) -> "size_t":
def points_count(self, *args) -> "size_t":
def items_count(self, *args) -> "size_t":
def __init__(self, *args):
def length(self, *args) -> "size_t":
def toright(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __init__(self, *args):
def is_node(self, *args) -> "bool":
def is_edge(self, *args) -> "bool":
def __init__(self, *args):
def empty(self, *args) -> "bool":
def intersect(self, *args) -> "void":
def make_union(self, *args) -> "void":
def move_by(self, *args) -> "void":
def __init__(self, *args):
def length(self, *args) -> "int":
def contains(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def height(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def create_tree_layout(self, *args) -> "bool":
def create_circle_layout(self, *args) -> "bool":
def set_callback(self, *args) -> "void":
def grcall(self, *args) -> "ssize_t":
def get_edge(self, *args) -> "edge_info_t *":
def nrect(self, *args) -> "rect_t":
def __disown__(self):
def __init__(self, *args, **kwargs):
def clear(self, *args) -> "void":
def __init__(self, *args, **kwargs):
def size(self, *args) -> "int":
def node_qty(self, *args) -> "int":
def empty(self, *args) -> "bool":
def exists(self, *args) -> "bool":
def get_node_representative(self, *args) -> "int":
def get_node_group(self, *args) -> "int":
def set_node_group(self, *args) -> "void":
def is_deleted_node(self, *args) -> "bool":
def set_deleted_node(self, *args) -> "void":
def is_subgraph_node(self, *args) -> "bool":
def is_dot_node(self, *args) -> "bool":
def is_group_node(self, *args) -> "bool":
def is_displayable_node(self, *args) -> "bool":
def is_simple_node(self, *args) -> "bool":
def is_collapsed_node(self, *args) -> "bool":
def is_uncollapsed_node(self, *args) -> "bool":
def is_visible_node(self, *args) -> "bool":
def get_first_subgraph_node(self, *args) -> "int":
def get_next_subgraph_node(self, *args) -> "int":
def create_group(self, *args) -> "int":
def delete_group(self, *args) -> "bool":
def change_group_visibility(self, *args) -> "bool":
def nsucc(self, *args) -> "int":
def npred(self, *args) -> "int":
def succ(self, *args) -> "int":
def pred(self, *args) -> "int":
def succset(self, *args) -> "intvec_t const &":
def predset(self, *args) -> "intvec_t const &":
def reset(self, *args) -> "void":
def redo_layout(self, *args) -> "bool":
def resize(self, *args) -> "void":
def add_node(self, *args) -> "int":
def del_node(self, *args) -> "ssize_t":
def add_edge(self, *args) -> "bool":
def del_edge(self, *args) -> "bool":
def replace_edge(self, *args) -> "bool":
def refresh(self, *args) -> "bool":
def set_nrect(self, *args) -> "bool":
def set_edge(self, *args) -> "bool":
def create_digraph_layout(self, *args) -> "bool":
def del_custom_layout(self, *args) -> "void":
def get_custom_layout(self, *args) -> "bool":
def set_custom_layout(self, *args) -> "void":
def get_graph_groups(self, *args) -> "bool":
def set_graph_groups(self, *args) -> "void":
def calc_group_ea(self, *args) -> "ea_t":
def is_user_graph(self, *args) -> "bool":
def visit_node(self, *args) -> "int":
def visit_edge(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def create_graph_viewer(*args) -> "graph_viewer_t *":
def get_graph_viewer(*args) -> "graph_viewer_t *":
def create_mutable_graph(*args) -> "mutable_graph_t *":
def create_disasm_graph(*args) -> "mutable_graph_t *":
def get_viewer_graph(*args) -> "mutable_graph_t *":
def set_viewer_graph(*args) -> "void":
def refresh_viewer(*args) -> "void":
def viewer_fit_window(*args) -> "void":
def viewer_get_curnode(*args) -> "int":
def viewer_center_on(*args) -> "void":
def viewer_set_gli(*args) -> "void":
def viewer_get_gli(*args) -> "bool":
def viewer_set_node_info(*args) -> "void":
def viewer_get_node_info(*args) -> "bool":
def viewer_del_node_info(*args) -> "void":
def viewer_create_groups(*args) -> "bool":
def viewer_delete_groups(*args) -> "bool":
def viewer_set_groups_visibility(*args) -> "bool":
def viewer_attach_menu_item(*args) -> "bool":
def viewer_get_selection(*args) -> "bool":
def viewer_set_titlebar_height(*args) -> "int":
def delete_mutable_graph(*args) -> "void":
def __init__(self, *args, **kwargs):
def create_user_graph_place(*args) -> "user_graph_place_t *":
def pyg_close(*args) -> "void":
def pyg_select_node(*args) -> "void":
def pyg_show(*args) -> "bool":
def __init__(self, v):
def populating_widget_popup(self, w, popup_handle):
def __init__(self, title, close_open = False):
def _qccb(ctx, cmd_id):
def AddNode(self, obj):
def AddEdge(self, src_node, dest_node):
def Clear(self):
def __iter__(self):
def __getitem__(self, idx):
def Count(self):
def Close(self):
def Show(self):
def Select(self, node_id):
def OnRefresh(self):
def AddCommand(self, title, shortcut):
def OnPopup(self, widget, popup_handle):
def OnCommand(self, cmd_id):
#def OnGetText(self, node_id):
#def OnActivate(self):
#def OnDeactivate(self):
#def OnHint(self, node_id):
#def OnEdgeHint(self, src, dst):
#def OnClose(self):
#def OnClick(self, node_id):
#def OnDblClick(self, node_id):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def _kludge_force_declare_TPopupMenu(*args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "bitset_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "bitset_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "bitset_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< bitset_t >::const_iterator":
def end(self, *args) -> "qvector< bitset_t >::const_iterator":
def insert(self, *args) -> "qvector< bitset_t >::iterator":
def erase(self, *args) -> "qvector< bitset_t >::iterator":
def find(self, *args) -> "qvector< bitset_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "bitset_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "mop_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "mop_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "mop_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< mop_t >::const_iterator":
def end(self, *args) -> "qvector< mop_t >::const_iterator":
def insert(self, *args) -> "qvector< mop_t >::iterator":
def erase(self, *args) -> "qvector< mop_t >::iterator":
def find(self, *args) -> "qvector< mop_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "mop_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "mcallarg_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "mcallarg_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "mcallarg_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< mcallarg_t >::const_iterator":
def end(self, *args) -> "qvector< mcallarg_t >::const_iterator":
def insert(self, *args) -> "qvector< mcallarg_t >::iterator":
def erase(self, *args) -> "qvector< mcallarg_t >::iterator":
def find(self, *args) -> "qvector< mcallarg_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "mcallarg_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "block_chains_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "block_chains_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "block_chains_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< block_chains_t >::const_iterator":
def end(self, *args) -> "qvector< block_chains_t >::const_iterator":
def insert(self, *args) -> "qvector< block_chains_t >::iterator":
def erase(self, *args) -> "qvector< block_chains_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "block_chains_t const &":
def __setitem__(self, *args) -> "void":
def at(self, *args) -> "number_format_t &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def at(self, *args) -> "lvar_locator_t &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def __init__(self, *args):
def push_back(self, *args) -> "hexwarn_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "hexwarn_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "hexwarn_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< hexwarn_t >::const_iterator":
def end(self, *args) -> "qvector< hexwarn_t >::const_iterator":
def insert(self, *args) -> "qvector< hexwarn_t >::iterator":
def erase(self, *args) -> "qvector< hexwarn_t >::iterator":
def find(self, *args) -> "qvector< hexwarn_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "hexwarn_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "citem_t *&":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "citem_t *const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "citem_t **":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< citem_t * >::const_iterator":
def end(self, *args) -> "qvector< citem_t * >::const_iterator":
def insert(self, *args) -> "qvector< citem_t * >::iterator":
def erase(self, *args) -> "qvector< citem_t * >::iterator":
def find(self, *args) -> "qvector< citem_t * >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "citem_t *const &":
def __setitem__(self, *args) -> "void":
def at(self, *args) -> "_qstring< char > &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def at(self, *args) -> "citem_cmt_t &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def at(self, *args) -> "int &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def at(self, *args) -> "qvector< int > &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def __init__(self, *args):
def push_back(self, *args) -> "cinsn_t *&":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "cinsn_t *const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "cinsn_t **":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< cinsn_t * >::const_iterator":
def end(self, *args) -> "qvector< cinsn_t * >::const_iterator":
def insert(self, *args) -> "qvector< cinsn_t * >::iterator":
def erase(self, *args) -> "qvector< cinsn_t * >::iterator":
def find(self, *args) -> "qvector< cinsn_t * >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "cinsn_t *const &":
def __setitem__(self, *args) -> "void":
def at(self, *args) -> "cinsnptrvec_t &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def at(self, *args) -> "rangeset_t &":
def size(self, *args) -> "size_t":
def __init__(self, *args):
def user_iflags_second(*args) -> "int32 const &":
def __init__(self, *args):
def reset(self, *args) -> "void":
def __deref__(self, *args) -> "cfunc_t *":
def __ref__(self, *args) -> "cfunc_t &":
def __ptrval__(self, *args) -> "size_t":
def release(self, *args) -> "void":
def build_c_tree(self, *args) -> "void":
def verify(self, *args) -> "void":
def print_dcl(self, *args) -> "void":
def print_func(self, *args) -> "void":
def get_func_type(self, *args) -> "bool":
def get_lvars(self, *args) -> "lvars_t *":
def get_stkoff_delta(self, *args) -> "sval_t":
def find_label(self, *args) -> "citem_t *":
def remove_unused_labels(self, *args) -> "void":
def get_user_cmt(self, *args) -> "char const *":
def set_user_cmt(self, *args) -> "void":
def get_user_iflags(self, *args) -> "int32":
def set_user_iflags(self, *args) -> "void":
def has_orphan_cmts(self, *args) -> "bool":
def del_orphan_cmts(self, *args) -> "int":
def get_user_union_selection(self, *args) -> "bool":
def set_user_union_selection(self, *args) -> "void":
def save_user_labels(self, *args) -> "void":
def save_user_cmts(self, *args) -> "void":
def save_user_numforms(self, *args) -> "void":
def save_user_iflags(self, *args) -> "void":
def save_user_unions(self, *args) -> "void":
def get_line_item(self, *args) -> "bool":
def get_warnings(self, *args) -> "hexwarns_t &":
def get_eamap(self, *args) -> "eamap_t &":
def get_boundaries(self, *args) -> "boundaries_t &":
def get_pseudocode(self, *args) -> "strvec_t const &":
def refresh_func_ctext(self, *args) -> "void":
def gather_derefs(self, *args) -> "bool":
def find_item_coords(self, *args) -> "PyObject *":
def locked(self, *args) -> "bool":
def __str__(self, *args) -> "qstring":
def __init__(self, *args):
def push_back(self, *args) -> "history_item_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "history_item_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "history_item_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< history_item_t >::const_iterator":
def end(self, *args) -> "qvector< history_item_t >::const_iterator":
def insert(self, *args) -> "qvector< history_item_t >::iterator":
def erase(self, *args) -> "qvector< history_item_t >::iterator":
def find(self, *args) -> "qvector< history_item_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "history_item_t const &":
def __setitem__(self, *args) -> "void":
def pop(self, *args) -> "history_item_t":
def top(self, *args) -> "history_item_t &":
def push(self, *args) -> "void":
def __init__(self, *args):
def __next__(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def swap(self, *args) -> "void":
def empty(self, *args) -> "bool":
def size(self, *args) -> "size_t":
def front(self, *args) -> "cinsn_t const &":
def back(self, *args) -> "cinsn_t const &":
def rbegin(self, *args) -> "qlist< cinsn_t >::const_reverse_iterator":
def rend(self, *args) -> "qlist< cinsn_t >::const_reverse_iterator":
def push_front(self, *args) -> "void":
def push_back(self, *args) -> "cinsn_t &":
def clear(self, *args) -> "void":
def pop_front(self, *args) -> "void":
def pop_back(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "cinsn_t const &":
def __setitem__(self, *args) -> "void":
def remove(self, *args) -> "bool":
def find(self, item):
def index(self, item):
def at(self, index):
def begin(self, *args) -> "cinsn_list_t_iterator":
def end(self, *args) -> "cinsn_list_t_iterator":
def insert(self, *args) -> "cinsn_list_t_iterator":
def erase(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "lvar_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "lvar_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "lvar_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< lvar_t >::const_iterator":
def end(self, *args) -> "qvector< lvar_t >::const_iterator":
def insert(self, *args) -> "qvector< lvar_t >::iterator":
def erase(self, *args) -> "qvector< lvar_t >::iterator":
def find(self, *args) -> "qvector< lvar_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "lvar_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "carg_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "carg_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "carg_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< carg_t >::const_iterator":
def end(self, *args) -> "qvector< carg_t >::const_iterator":
def insert(self, *args) -> "qvector< carg_t >::iterator":
def erase(self, *args) -> "qvector< carg_t >::iterator":
def find(self, *args) -> "qvector< carg_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "carg_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "ccase_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "ccase_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "ccase_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< ccase_t >::const_iterator":
def end(self, *args) -> "qvector< ccase_t >::const_iterator":
def insert(self, *args) -> "qvector< ccase_t >::iterator":
def erase(self, *args) -> "qvector< ccase_t >::iterator":
def find(self, *args) -> "qvector< ccase_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "ccase_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "lvar_saved_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "lvar_saved_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "lvar_saved_info_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< lvar_saved_info_t >::const_iterator":
def end(self, *args) -> "qvector< lvar_saved_info_t >::const_iterator":
def insert(self, *args) -> "qvector< lvar_saved_info_t >::iterator":
def erase(self, *args) -> "qvector< lvar_saved_info_t >::iterator":
def find(self, *args) -> "qvector< lvar_saved_info_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "lvar_saved_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "ui_stroff_op_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "ui_stroff_op_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "ui_stroff_op_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< ui_stroff_op_t >::const_iterator":
def end(self, *args) -> "qvector< ui_stroff_op_t >::const_iterator":
def insert(self, *args) -> "qvector< ui_stroff_op_t >::iterator":
def erase(self, *args) -> "qvector< ui_stroff_op_t >::iterator":
def find(self, *args) -> "qvector< ui_stroff_op_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "ui_stroff_op_t const &":
def __setitem__(self, *args) -> "void":
def qswap(*args) -> "void":
def debug_hexrays_ctree(*args) -> "void":
def init_hexrays_plugin(*args) -> "bool":
def get_widget_vdui(*args) -> "vdui_t *":
def boundaries_find(*args) -> "boundaries_iterator_t":
def boundaries_insert(*args) -> "boundaries_iterator_t":
def term_hexrays_plugin(*args) -> "void":
def __init__(self, *args):
def hook(self, *args) -> "bool":
def unhook(self, *args) -> "bool":
def flowchart(self, *args) -> "int":
def stkpnts(self, *args) -> "int":
def prolog(self, *args) -> "int":
def microcode(self, *args) -> "int":
def preoptimized(self, *args) -> "int":
def locopt(self, *args) -> "int":
def prealloc(self, *args) -> "int":
def glbopt(self, *args) -> "int":
def structural(self, *args) -> "int":
def maturity(self, *args) -> "int":
def interr(self, *args) -> "int":
def combine(self, *args) -> "int":
def print_func(self, *args) -> "int":
def func_printed(self, *args) -> "int":
def resolve_stkaddrs(self, *args) -> "int":
def build_callinfo(self, *args) -> "PyObject *":
def open_pseudocode(self, *args) -> "int":
def switch_pseudocode(self, *args) -> "int":
def refresh_pseudocode(self, *args) -> "int":
def close_pseudocode(self, *args) -> "int":
def keyboard(self, *args) -> "int":
def right_click(self, *args) -> "int":
def double_click(self, *args) -> "int":
def curpos(self, *args) -> "int":
def create_hint(self, *args) -> "PyObject *":
def text_ready(self, *args) -> "int":
def populating_popup(self, *args) -> "int":
def lvar_name_changed(self, *args) -> "int":
def lvar_type_changed(self, *args) -> "int":
def lvar_cmt_changed(self, *args) -> "int":
def lvar_mapping_changed(self, *args) -> "int":
def cmt_changed(self, *args) -> "int":
def __disown__(self):
def __init__(self, *args):
def valid(self, *args) -> "bool":
def end(self, *args) -> "unsigned long long":
def last(self, *args) -> "unsigned long long":
def __init__(self, *args):
def swap(self, *args) -> "void":
def getivl(self, *args) -> "ivl_t const &":
def lastivl(self, *args) -> "ivl_t const &":
def nivls(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def clear(self, *args) -> "void":
def qclear(self, *args) -> "void":
def all_values(self, *args) -> "bool":
def set_all_values(self, *args) -> "void":
def single_value(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "ivlset_tpl< ivl_t,unsigned long long >::iterator":
def end(self, *args) -> "ivlset_tpl< ivl_t,unsigned long long >::iterator":
def __init__(self, *args):
def push_back(self, *args) -> "ivlset_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "ivlset_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "ivlset_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< ivlset_t >::const_iterator":
def end(self, *args) -> "qvector< ivlset_t >::const_iterator":
def insert(self, *args) -> "qvector< ivlset_t >::iterator":
def erase(self, *args) -> "qvector< ivlset_t >::iterator":
def find(self, *args) -> "qvector< ivlset_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "ivlset_t const &":
def __setitem__(self, *args) -> "void":
def hexrays_alloc(*args) -> "void *":
def hexrays_free(*args) -> "void":
def __init__(self, *args):
def swap(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def set_none(self, *args) -> "void":
def set_all(self, *args) -> "void":
def set_unk(self, *args) -> "void":
def set_eq(self, *args) -> "void":
def set_cmp(self, *args) -> "void":
def reduce_size(self, *args) -> "bool":
def intersect_with(self, *args) -> "bool":
def unite_with(self, *args) -> "bool":
def inverse(self, *args) -> "void":
def empty(self, *args) -> "bool":
def all_values(self, *args) -> "bool":
def is_unknown(self, *args) -> "bool":
def has(self, *args) -> "bool":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def cvt_to_single_value(self, *args) -> "bool":
def cvt_to_cmp(self, *args) -> "bool":
def get_size(self, *args) -> "int":
def max_value(self, *args) -> "uvlr_t":
def min_svalue(self, *args) -> "uvlr_t":
def max_svalue(self, *args) -> "uvlr_t":
def _register(self, *args) -> "void":
def _deregister(self, *args) -> "void":
def is_may_access(*args) -> "bool":
def get_merror_desc(*args) -> "qstring *":
def must_mcode_close_block(*args) -> "bool":
def is_mcode_propagatable(*args) -> "bool":
def is_mcode_addsub(*args) -> "bool":
def is_mcode_xdsu(*args) -> "bool":
def is_mcode_set(*args) -> "bool":
def is_mcode_set1(*args) -> "bool":
def is_mcode_j1(*args) -> "bool":
def is_mcode_jcond(*args) -> "bool":
def is_mcode_convertible_to_jmp(*args) -> "bool":
def is_mcode_convertible_to_set(*args) -> "bool":
def is_mcode_call(*args) -> "bool":
def is_mcode_fpu(*args) -> "bool":
def is_mcode_commutative(*args) -> "bool":
def is_mcode_shift(*args) -> "bool":
def is_mcode_divmod(*args) -> "bool":
def has_mcode_seloff(*args) -> "bool":
def set2jcnd(*args) -> "mcode_t":
def jcnd2set(*args) -> "mcode_t":
def negate_mcode_relation(*args) -> "mcode_t":
def swap_mcode_relation(*args) -> "mcode_t":
def get_signed_mcode(*args) -> "mcode_t":
def get_unsigned_mcode(*args) -> "mcode_t":
def is_signed_mcode(*args) -> "bool":
def is_unsigned_mcode(*args) -> "bool":
def mcode_modifies_d(*args) -> "bool":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def get_radix(self, *args) -> "int":
def is_fixed(self, *args) -> "bool":
def is_hex(self, *args) -> "bool":
def is_dec(self, *args) -> "bool":
def is_oct(self, *args) -> "bool":
def is_enum(self, *args) -> "bool":
def is_char(self, *args) -> "bool":
def is_stroff(self, *args) -> "bool":
def is_numop(self, *args) -> "bool":
def needs_to_be_inverted(self, *args) -> "bool":
def has_unmutable_type(self, *args) -> "bool":
def _print(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def oneliner(self, *args) -> "bool":
def __disown__(self):
def _print(self, *args) -> "int":
def __init__(self, *args):
def get_s(self, *args) -> "qstring":
def dstr(*args) -> "char const *":
def is_type_correct(*args) -> "bool":
def is_small_udt(*args) -> "bool":
def is_nonbool_type(*args) -> "bool":
def is_bool_type(*args) -> "bool":
def is_ptr_or_array(*args) -> "bool":
def is_paf(*args) -> "bool":
def is_inplace_def(*args) -> "bool":
def partial_type_num(*args) -> "int":
def get_float_type(*args) -> "tinfo_t":
def get_int_type_by_width_and_sign(*args) -> "tinfo_t":
def get_unk_type(*args) -> "tinfo_t":
def dummy_ptrtype(*args) -> "tinfo_t":
def get_member_type(*args) -> "bool":
def make_pointer(*args) -> "tinfo_t":
def create_typedef(*args) -> "tinfo_t":
def get_type(*args) -> "bool":
def set_type(*args) -> "bool":
def reg1(self, *args) -> "int":
def _set_reg1(self, *args) -> "void":
def set_reg1(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def is_aliasable(self, *args) -> "bool":
def __init__(self, *args):
def print_vdloc(*args) -> "qstring *":
def arglocs_overlap(*args) -> "bool":
def __init__(self, *args):
def get_stkoff(self, *args) -> "sval_t":
def is_reg1(self, *args) -> "bool":
def is_reg2(self, *args) -> "bool":
def is_reg_var(self, *args) -> "bool":
def is_stk_var(self, *args) -> "bool":
def is_scattered(self, *args) -> "bool":
def get_reg1(self, *args) -> "mreg_t":
def get_reg2(self, *args) -> "mreg_t":
def get_scattered(self, *args) -> "scattered_aloc_t &":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args, **kwargs):
def used(self, *args) -> "bool":
def typed(self, *args) -> "bool":
def mreg_done(self, *args) -> "bool":
def has_nice_name(self, *args) -> "bool":
def is_unknown_width(self, *args) -> "bool":
def has_user_info(self, *args) -> "bool":
def has_user_name(self, *args) -> "bool":
def has_user_type(self, *args) -> "bool":
def is_result_var(self, *args) -> "bool":
def is_arg_var(self, *args) -> "bool":
def is_fake_var(self, *args) -> "bool":
def is_overlapped_var(self, *args) -> "bool":
def is_floating_var(self, *args) -> "bool":
def is_spoiled_var(self, *args) -> "bool":
def is_noptr_var(self, *args) -> "bool":
def is_mapdst_var(self, *args) -> "bool":
def is_thisarg(self, *args) -> "bool":
def is_forced_var(self, *args) -> "bool":
def has_regname(self, *args) -> "bool":
def in_asm(self, *args) -> "bool":
def is_dummy_arg(self, *args) -> "bool":
def is_notarg(self, *args) -> "bool":
def is_automapped(self, *args) -> "bool":
def is_used_byref(self, *args) -> "bool":
def is_decl_unused(self, *args) -> "bool":
def set_used(self, *args) -> "void":
def clear_used(self, *args) -> "void":
def set_typed(self, *args) -> "void":
def set_non_typed(self, *args) -> "void":
def clr_user_info(self, *args) -> "void":
def set_user_name(self, *args) -> "void":
def set_user_type(self, *args) -> "void":
def clr_user_type(self, *args) -> "void":
def clr_user_name(self, *args) -> "void":
def set_mreg_done(self, *args) -> "void":
def clr_mreg_done(self, *args) -> "void":
def set_unknown_width(self, *args) -> "void":
def clr_unknown_width(self, *args) -> "void":
def set_arg_var(self, *args) -> "void":
def clr_arg_var(self, *args) -> "void":
def set_fake_var(self, *args) -> "void":
def clr_fake_var(self, *args) -> "void":
def set_overlapped_var(self, *args) -> "void":
def clr_overlapped_var(self, *args) -> "void":
def set_floating_var(self, *args) -> "void":
def clr_floating_var(self, *args) -> "void":
def set_spoiled_var(self, *args) -> "void":
def clr_spoiled_var(self, *args) -> "void":
def set_mapdst_var(self, *args) -> "void":
def clr_mapdst_var(self, *args) -> "void":
def set_noptr_var(self, *args) -> "void":
def clr_noptr_var(self, *args) -> "void":
def set_thisarg(self, *args) -> "void":
def clr_thisarg(self, *args) -> "void":
def set_forced_var(self, *args) -> "void":
def clr_forced_var(self, *args) -> "void":
def set_dummy_arg(self, *args) -> "void":
def clr_dummy_arg(self, *args) -> "void":
def set_notarg(self, *args) -> "void":
def clr_notarg(self, *args) -> "void":
def set_automapped(self, *args) -> "void":
def clr_automapped(self, *args) -> "void":
def set_used_byref(self, *args) -> "void":
def clr_used_byref(self, *args) -> "void":
def set_decl_unused(self, *args) -> "void":
def clr_decl_unused(self, *args) -> "void":
def has_common(self, *args) -> "bool":
def has_common_bit(self, *args) -> "bool":
def type(self, *args) -> "tinfo_t &":
def accepts_type(self, *args) -> "bool":
def set_lvar_type(self, *args) -> "bool":
def set_final_lvar_type(self, *args) -> "void":
def set_width(self, *args) -> "bool":
def append_list(self, *args) -> "void":
def is_aliasable(self, *args) -> "bool":
def find_input_lvar(self, *args) -> "int":
def find_stkvar(self, *args) -> "int":
def find(self, *args) -> "lvar_t *":
def find_lvar(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def has_info(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def is_kept(self, *args) -> "bool":
def clear_keep(self, *args) -> "void":
def set_keep(self, *args) -> "void":
def is_forced_lvar(self, *args) -> "bool":
def set_forced_lvar(self, *args) -> "void":
def clr_forced_lvar(self, *args) -> "void":
def is_noptr_lvar(self, *args) -> "bool":
def set_noptr_lvar(self, *args) -> "void":
def clr_noptr_lvar(self, *args) -> "void":
def is_nomap_lvar(self, *args) -> "bool":
def set_nomap_lvar(self, *args) -> "void":
def clr_nomap_lvar(self, *args) -> "void":
def is_unused_lvar(self, *args) -> "bool":
def set_unused_lvar(self, *args) -> "void":
def clr_unused_lvar(self, *args) -> "void":
def __init__(self, *args):
def swap(self, *args) -> "void":
def clear(self, *args) -> "void":
def empty(self, *args) -> "bool":
def find_info(self, *args) -> "lvar_saved_info_t *":
def keep_info(self, *args) -> "void":
def restore_user_lvar_settings(*args) -> "bool":
def save_user_lvar_settings(*args) -> "void":
def modify_lvars(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def modify_user_lvars(*args) -> "bool":
def modify_user_lvar_info(*args) -> "bool":
def locate_lvar(*args) -> "bool":
def rename_lvar(*args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def empty(self, *args) -> "bool":
def __init__(self, *args):
def restore_user_defined_calls(*args) -> "bool":
def save_user_defined_calls(*args) -> "void":
def parse_user_call(*args) -> "bool":
def convert_to_user_call(*args) -> "merror_t":
def match(self, *args) -> "bool":
def apply(self, *args) -> "merror_t":
def __init__(self, *args):
def __disown__(self):
def install_microcode_filter(*args) -> "bool":
def cleanup(self, *args) -> "void":
def match(self, *args) -> "bool":
def apply(self, *args) -> "merror_t":
def empty(self, *args) -> "bool":
def install(self, *args) -> "void":
def remove(self, *args) -> "bool":
def init(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def swap(self, *args) -> "void":
def copy(self, *args) -> "bitset_t &":
def add(self, *args) -> "bool":
def sub(self, *args) -> "bool":
def cut_at(self, *args) -> "bool":
def shift_down(self, *args) -> "void":
def has(self, *args) -> "bool":
def has_all(self, *args) -> "bool":
def has_any(self, *args) -> "bool":
def dstr(self, *args) -> "char const *":
def empty(self, *args) -> "bool":
def count(self, *args) -> "int":
def last(self, *args) -> "int":
def clear(self, *args) -> "void":
def fill_with_ones(self, *args) -> "void":
def has_common(self, *args) -> "bool":
def intersect(self, *args) -> "bool":
def is_subset_of(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def itat(self, *args) -> "bitset_t::iterator":
def begin(self, *args) -> "bitset_t::iterator":
def end(self, *args) -> "bitset_t::iterator":
def front(self, *args) -> "int":
def back(self, *args) -> "int":
def inc(self, *args) -> "void":
def itv(self, *args) -> "int":
def __iter__(self):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __ref__(self, *args) -> "int":
def __init__(self, *args):
def empty(self, *args) -> "bool":
def clear(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def extend_to_cover(self, *args) -> "bool":
def intersect(self, *args) -> "void":
def overlap(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def contains(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def add(self, *args) -> "bool":
def addmasked(self, *args) -> "bool":
def sub(self, *args) -> "bool":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def count(self, *args) -> "asize_t":
def has_common(self, *args) -> "bool":
def contains(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def intersect(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def dstr(self, *args) -> "char const *":
def __init__(self, *args):
def swap(self, *args) -> "void":
def addmem(self, *args) -> "bool":
def add(self, *args) -> "bool":
def sub(self, *args) -> "bool":
def count(self, *args) -> "asize_t":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def empty(self, *args) -> "bool":
def clear(self, *args) -> "void":
def has(self, *args) -> "bool":
def has_all(self, *args) -> "bool":
def has_any(self, *args) -> "bool":
def has_memory(self, *args) -> "bool":
def has_common(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def intersect(self, *args) -> "bool":
def is_subset_of(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def get_temp_regs(*args) -> "mlist_t const &":
def is_kreg(*args) -> "bool":
def reg2mreg(*args) -> "mreg_t":
def mreg2reg(*args) -> "int":
def get_mreg_name(*args) -> "qstring *":
def func(self, *args) -> "int":
 instruction's use/def lists have changed, you must mark the block level
def install(self, *args) -> "void":
def remove(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def func(self, *args) -> "int":
def install(self, *args) -> "void":
def remove(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args, **kwargs):
def __init__(self, *args):
def __init__(self, *args):
def visit_minsn(self, *args) -> "int":
def __disown__(self):
def __init__(self, *args):
def visit_mop(self, *args) -> "int":
def __disown__(self):
def visit_scif_mop(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def __init__(self, *args):
def visit_mop(self, *args) -> "int":
def __disown__(self):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def swap(self, *args) -> "void":
def var(self, *args) -> "lvar_t &":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def swap(self, *args) -> "void":
def get_stkvar(self, *args) -> "member_t *":
def __init__(self, *args):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def update_value(self, *args) -> "void":
def dereference_uint16(self, *args) -> "uint16 *":
def dereference_const_uint16(self, *args) -> "uint16 const *":
def _print(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
do not display use-def chains and other attrs
def set_impptr_done(self, *args) -> "void":
def set_udt(self, *args) -> "void":
def set_undef_val(self, *args) -> "void":
def set_lowaddr(self, *args) -> "void":
def is_impptr_done(self, *args) -> "bool":
def is_udt(self, *args) -> "bool":
def probably_floating(self, *args) -> "bool":
def is_undef_val(self, *args) -> "bool":
def is_lowaddr(self, *args) -> "bool":
def is_ccflags(self, *args) -> "bool":
def is_pcval(self, *args) -> "bool":
def __init__(self, *args):
def assign(self, *args) -> "mop_t &":
def zero(self, *args) -> "void":
def swap(self, *args) -> "void":
def erase(self, *args) -> "void":
def erase_but_keep_size(self, *args) -> "void":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def create_from_mlist(self, *args) -> "bool":
def create_from_ivlset(self, *args) -> "bool":
def create_from_vdloc(self, *args) -> "void":
def create_from_scattered_vdloc(self, *args) -> "void":
def create_from_insn(self, *args) -> "void":
def make_number(self, *args) -> "void":
def make_fpnum(self, *args) -> "bool":
def _make_reg(self, *args) -> "void":
def make_reg(self, *args) -> "void":
def _make_lvar(self, *args) -> "void":
def _make_gvar(self, *args) -> "void":
def make_gvar(self, *args) -> "void":
def _make_stkvar(self, *args) -> "void":
def make_stkvar(self, *args) -> "void":
def make_reg_pair(self, *args) -> "void":
def _make_insn(self, *args) -> "void":
def make_insn(self, *args) -> "void":
def _make_blkref(self, *args) -> "void":
def make_blkref(self, *args) -> "void":
def make_helper(self, *args) -> "void":
def _make_strlit(self, *args) -> "void":
def _make_callinfo(self, *args) -> "void":
def _make_cases(self, *args) -> "void":
def _make_pair(self, *args) -> "void":
def empty(self, *args) -> "bool":
def is_reg(self, *args) -> "bool":
def is_arglist(self, *args) -> "bool":
def is_cc(self, *args) -> "bool":
def is_bit_reg(self, *args) -> "bool":
def is_kreg(self, *args) -> "bool":
def is_mob(self, *args) -> "bool":
def is_scattered(self, *args) -> "bool":
def is_glbaddr(self, *args) -> "bool":
def is_stkaddr(self, *args) -> "bool":
def is_insn(self, *args) -> "bool":
def has_side_effects(self, *args) -> "bool":
def may_use_aliased_memory(self, *args) -> "bool":
def is01(self, *args) -> "bool":
def is_sign_extended_from(self, *args) -> "bool":
def is_zero_extended_from(self, *args) -> "bool":
def is_extended_from(self, *args) -> "bool":
def equal_mops(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def lexcompare(self, *args) -> "int":
def for_all_ops(self, *args) -> "int":
def for_all_scattered_submops(self, *args) -> "int":
def value(self, *args) -> "uint64":
def signed_value(self, *args) -> "int64":
def unsigned_value(self, *args) -> "uint64":
def update_numop_value(self, *args) -> "void":
def is_constant(self, *args) -> "bool":
def is_equal_to(self, *args) -> "bool":
def is_zero(self, *args) -> "bool":
def is_one(self, *args) -> "bool":
def is_positive_constant(self, *args) -> "bool":
def is_negative_constant(self, *args) -> "bool":
def get_stkvar(self, *args) -> "member_t *":
def get_stkoff(self, *args) -> "bool":
def get_insn(self, *args) -> "minsn_t *":
def make_low_half(self, *args) -> "bool":
def make_high_half(self, *args) -> "bool":
def make_first_half(self, *args) -> "bool":
def make_second_half(self, *args) -> "bool":
def shift_mop(self, *args) -> "bool":
def change_size(self, *args) -> "bool":
def double_size(self, *args) -> "bool":
def preserve_side_effects(self, *args) -> "bool":
def apply_ld_mcode(self, *args) -> "void":
def apply_xdu(self, *args) -> "void":
def apply_xds(self, *args) -> "void":
def _register(self, *args) -> "void":
def _deregister(self, *args) -> "void":
def _get_t(self, *args) -> "mopt_t":
def _set_t(self, *args) -> "void":
def _ensure_no_t(self):
def __dbg_get_meminfo(self, *args) -> "qstring":
def __dbg_get_registered_kind(self, *args) -> "int":
def _obj_id(self, *args) -> "PyObject *":
def _ensure_cond(self, ok, cond_str):
def _ensure_no_obj(self, o, attr, attr_is_acquired):
def _ensure_ownership_transferrable(self, v):
def _acquire_ownership(self, v, acquire):
def _maybe_disown_and_deregister(self):
def _own_and_register(self):
def replace_by(self, o):
def _meminfo(self):
def _get_nnn(self, *args) -> "mnumber_t *":
def _set_nnn(self, *args) -> "void":
def _get_d(self, *args) -> "minsn_t *":
def _set_d(self, *args) -> "void":
def _get_s(self, *args) -> "stkvar_ref_t *":
def _set_s(self, *args) -> "void":
def _get_f(self, *args) -> "mcallinfo_t *":
def _set_f(self, *args) -> "void":
def _get_l(self, *args) -> "lvar_ref_t *":
def _set_l(self, *args) -> "void":
def _get_a(self, *args) -> "mop_addr_t *":
def _set_a(self, *args) -> "void":
def _get_c(self, *args) -> "mcases_t *":
def _set_c(self, *args) -> "void":
def _get_fpc(self, *args) -> "fnumber_t *":
def _set_fpc(self, *args) -> "void":
def _get_pair(self, *args) -> "mop_pair_t *":
def _set_pair(self, *args) -> "void":
def _get_scif(self, *args) -> "scif_t *":
def _set_scif(self, *args) -> "void":
def _get_r(self, *args) -> "mreg_t":
def _set_r(self, *args) -> "void":
def _get_g(self, *args) -> "ea_t":
def _set_g(self, *args) -> "void":
def _get_b(self, *args) -> "int":
def _set_b(self, *args) -> "void":
def _get_cstr(self, *args) -> "char const *":
def _set_cstr(self, *args) -> "void":
def _get_helper(self, *args) -> "char const *":
def _set_helper(self, *args) -> "void":
def lexcompare(*args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def lexcompare(self, *args) -> "int":
def __init__(self, *args):
def copy_mop(self, *args) -> "void":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def set_regarg(self, *args) -> "void":
def make_int(self, *args) -> "void":
def make_uint(self, *args) -> "void":
def __init__(self, *args):
def lexcompare(self, *args) -> "int":
def set_type(self, *args) -> "bool":
def get_type(self, *args) -> "tinfo_t":
def is_vararg(self, *args) -> "bool":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def swap(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def empty(self, *args) -> "bool":
def size(self, *args) -> "size_t":
def resize(self, *args) -> "void":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def __init__(self, *args):
def __init__(self, *args):
def set(self, *args) -> "void":
def set_stkoff(self, *args) -> "void":
def set_reg(self, *args) -> "void":
def undef(self, *args) -> "void":
def defined(self, *args) -> "bool":
def is_reg(self, *args) -> "bool":
def is_stkoff(self, *args) -> "bool":
def get_reg(self, *args) -> "mreg_t":
def get_stkoff(self, *args) -> "sval_t":
def inc(self, *args) -> "void":
def add(self, *args) -> "voff_t":
def diff(self, *args) -> "sval_t":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def set(self, *args) -> "void":
def set_stkoff(self, *args) -> "void":
def set_reg(self, *args) -> "void":
def extend_to_cover(self, *args) -> "bool":
def intersect(self, *args) -> "uval_t":
def overlap(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def contains(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def __init__(self, *args):
def set_value(self, *args) -> "void":
def key(self, *args) -> "voff_t const &":
def is_inited(self, *args) -> "bool":
def is_reg(self, *args) -> "bool":
def is_stkoff(self, *args) -> "bool":
def is_replaced(self, *args) -> "bool":
def is_overlapped(self, *args) -> "bool":
def is_fake(self, *args) -> "bool":
def is_passreg(self, *args) -> "bool":
def is_term(self, *args) -> "bool":
def set_inited(self, *args) -> "void":
def set_replaced(self, *args) -> "void":
def set_overlapped(self, *args) -> "void":
def set_term(self, *args) -> "void":
def get_reg(self, *args) -> "mreg_t":
def get_stkoff(self, *args) -> "sval_t":
def overlap(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def endoff(self, *args) -> "voff_t const":
def __lt__(self, *args) -> "bool":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def append_list(self, *args) -> "void":
def clear_varnum(self, *args) -> "void":
def get_reg_chain(self, *args) -> "chain_t *":
def get_stk_chain(self, *args) -> "chain_t *":
def get_chain(self, *args) -> "chain_t *":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def __init__(self, *args):
def __init__(self, *args):
def visit_chain(self, *args) -> "int":
def __disown__(self):
def __init__(self, *args):
def for_all_chains(self, *args) -> "int":
def is_locked(self, *args) -> "bool":
def acquire(self, *args) -> "void":
def release(self, *args) -> "void":
def swap(self, *args) -> "void":
def is_optional(self, *args) -> "bool":
def is_combined(self, *args) -> "bool":
def is_farcall(self, *args) -> "bool":
def is_cleaning_pop(self, *args) -> "bool":
def is_extstx(self, *args) -> "bool":
def is_tailcall(self, *args) -> "bool":
def is_fpinsn(self, *args) -> "bool":
def is_assert(self, *args) -> "bool":
def is_persistent(self, *args) -> "bool":
def is_wild_match(self, *args) -> "bool":
def is_propagatable(self, *args) -> "bool":
def is_ignlowsrc(self, *args) -> "bool":
def is_inverted_jx(self, *args) -> "bool":
def was_noret_icall(self, *args) -> "bool":
def is_multimov(self, *args) -> "bool":
def is_combinable(self, *args) -> "bool":
def was_split(self, *args) -> "bool":
def is_mbarrier(self, *args) -> "bool":
def set_optional(self, *args) -> "void":
def clr_combined(self, *args) -> "void":
def set_farcall(self, *args) -> "void":
def set_cleaning_pop(self, *args) -> "void":
def set_extstx(self, *args) -> "void":
def set_tailcall(self, *args) -> "void":
def clr_tailcall(self, *args) -> "void":
def set_fpinsn(self, *args) -> "void":
def clr_fpinsn(self, *args) -> "void":
def set_assert(self, *args) -> "void":
def clr_assert(self, *args) -> "void":
def set_persistent(self, *args) -> "void":
def set_wild_match(self, *args) -> "void":
def clr_propagatable(self, *args) -> "void":
def set_ignlowsrc(self, *args) -> "void":
def clr_ignlowsrc(self, *args) -> "void":
def set_inverted_jx(self, *args) -> "void":
def set_noret_icall(self, *args) -> "void":
def clr_noret_icall(self, *args) -> "void":
def set_multimov(self, *args) -> "void":
def clr_multimov(self, *args) -> "void":
def set_combinable(self, *args) -> "void":
def clr_combinable(self, *args) -> "void":
def set_mbarrier(self, *args) -> "void":
def set_split_size(self, *args) -> "void":
def get_split_size(self, *args) -> "int":
def __init__(self, *args):
def swap(self, *args) -> "void":
def _print(self, *args) -> "void":
def dstr(self, *args) -> "char const *":
def setaddr(self, *args) -> "void":
def optimize_solo(self, *args) -> "int":
def optimize_subtree(self, *args) -> "int":
def for_all_ops(self, *args) -> "int":
def for_all_insns(self, *args) -> "int":
def _make_nop(self, *args) -> "void":
def equal_insns(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def lexcompare(self, *args) -> "int":
def is_noret_call(self, *args) -> "bool":
def is_unknown_call(self, *args) -> "bool":
def is_helper(self, *args) -> "bool":
def find_call(self, *args) -> "minsn_t *":
def contains_call(self, *args) -> "bool":
def has_side_effects(self, *args) -> "bool":
def get_role(self, *args) -> "funcrole_t":
def is_memcpy(self, *args) -> "bool":
def is_memset(self, *args) -> "bool":
def is_alloca(self, *args) -> "bool":
def is_bswap(self, *args) -> "bool":
def is_readflags(self, *args) -> "bool":
def contains_opcode(self, *args) -> "bool":
def find_opcode(self, *args) -> "minsn_t *":
def find_ins_op(self, *args) -> "minsn_t *":
def find_num_op(self, *args) -> "mop_t *":
def is_mov(self, *args) -> "bool":
def is_like_move(self, *args) -> "bool":
def modifes_d(self, *args) -> "bool":
def modifies_pair_mop(self, *args) -> "bool":
def is_between(self, *args) -> "bool":
def is_after(self, *args) -> "bool":
def may_use_aliased_memory(self, *args) -> "bool":
def _register(self, *args) -> "void":
def _deregister(self, *args) -> "void":
def __dbg_get_meminfo(self, *args) -> "qstring":
def __dbg_get_registered_kind(self, *args) -> "int":
def _obj_id(self, *args) -> "PyObject *":
def _ensure_cond(self, ok, cond_str):
def _ensure_no_obj(self, o, attr, attr_is_acquired):
def _ensure_ownership_transferrable(self, v):
def _acquire_ownership(self, v, acquire):
def _maybe_disown_and_deregister(self):
def _own_and_register(self):
def replace_by(self, o):
def _meminfo(self):
def getf_reginsn(*args) -> "minsn_t *":
def getb_reginsn(*args) -> "minsn_t *":
def __init__(self, *args, **kwargs):
mustbdef = property(_ida_hexrays.mblock_t_mustbdef_get, _ida_hexrays.mblock_t_mustbdef_set, doc=r"""mustbdef""")
maybdef = property(_ida_hexrays.mblock_t_maybdef_get, _ida_hexrays.mblock_t_maybdef_set, doc=r"""maybdef""")
def mark_lists_dirty(self, *args) -> "void":
def request_propagation(self, *args) -> "void":
def needs_propagation(self, *args) -> "bool":
def request_demote64(self, *args) -> "void":
def lists_dirty(self, *args) -> "bool":
def lists_ready(self, *args) -> "bool":
def make_lists_ready(self, *args) -> "int":
def npred(self, *args) -> "int":
def nsucc(self, *args) -> "int":
def pred(self, *args) -> "int":
def succ(self, *args) -> "int":
def empty(self, *args) -> "bool":
def _print(self, *args) -> "void":
def dump(self, *args) -> "void":
def dump_block(self, *args) -> "void":
def insert_into_block(self, *args) -> "minsn_t *":
def remove_from_block(self, *args) -> "minsn_t *":
def for_all_insns(self, *args) -> "int":
def for_all_ops(self, *args) -> "int":
def for_all_uses(self, *args) -> "int":
def optimize_insn(self, *args) -> "int":
def optimize_block(self, *args) -> "int":
def build_lists(self, *args) -> "int":
def optimize_useless_jump(self, *args) -> "int":
def append_use_list(self, *args) -> "void":
def append_def_list(self, *args) -> "void":
@param op: (C++: const mop_t &) operand to calculate the def list of
def build_use_list(self, *args) -> "mlist_t":
def build_def_list(self, *args) -> "mlist_t":
@param ins: (C++: const minsn_t &) instruction to calculate the def list of
def is_used(self, *args) -> "bool":
def find_first_use(self, *args) -> "minsn_t *":
def is_redefined(self, *args) -> "bool":
def find_redefinition(self, *args) -> "minsn_t *":
def is_rhs_redefined(self, *args) -> "bool":
def find_access(self, *args) -> "minsn_t *":
def find_def(self, *args) -> "minsn_t *":
def find_use(self, *args) -> "minsn_t *":
def get_valranges(self, *args) -> "bool":
def make_nop(self, *args) -> "void":
recommended function to use because it also marks the block use-def lists dirty.
def get_reginsn_qty(self, *args) -> "size_t":
def is_call_block(self, *args) -> "bool":
def is_unknown_call(self, *args) -> "bool":
def is_nway(self, *args) -> "bool":
def is_branch(self, *args) -> "bool":
def is_simple_goto_block(self, *args) -> "bool":
def is_simple_jcnd_block(self, *args) -> "bool":
def preds(self):
def succs(self):
use/def lists are ready (not dirty)
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def start(self, *args) -> "ea_t":
def empty(self, *args) -> "bool":
def clear(self, *args) -> "void":
def is_snippet(self, *args) -> "bool":
def is_fragmented(self, *args) -> "bool":
def is_snippet(self, *args) -> "bool":
def set(self, *args) -> "bool":
def next(self, *args) -> "bool":
def chunk(self, *args) -> "range_t const &":
def __init__(self, *args):
def __init__(self, *args, **kwargs):
def precise_defeas(self, *args) -> "bool":
def optimized(self, *args) -> "bool":
def short_display(self, *args) -> "bool":
def show_reduction(self, *args) -> "bool":
def graph_insns(self, *args) -> "bool":
def loaded_gdl(self, *args) -> "bool":
def should_beautify(self, *args) -> "bool":
def rtype_refined(self, *args) -> "bool":
def may_refine_rettype(self, *args) -> "bool":
def use_wingraph32(self, *args) -> "bool":
def display_numaddrs(self, *args) -> "bool":
def display_valnums(self, *args) -> "bool":
def is_pattern(self, *args) -> "bool":
def is_thunk(self, *args) -> "bool":
def saverest_done(self, *args) -> "bool":
def callinfo_built(self, *args) -> "bool":
def really_alloc(self, *args) -> "bool":
def lvars_allocated(self, *args) -> "bool":
def chain_varnums_ok(self, *args) -> "bool":
def returns_fpval(self, *args) -> "bool":
def has_passregs(self, *args) -> "bool":
def generated_asserts(self, *args) -> "bool":
def propagated_asserts(self, *args) -> "bool":
def deleted_pairs(self, *args) -> "bool":
def common_stkvars_stkargs(self, *args) -> "bool":
def lvar_names_ok(self, *args) -> "bool":
def lvars_renamed(self, *args) -> "bool":
def has_over_chains(self, *args) -> "bool":
def valranges_done(self, *args) -> "bool":
def argidx_ok(self, *args) -> "bool":
def argidx_sorted(self, *args) -> "bool":
def code16_bit_removed(self, *args) -> "bool":
def has_stack_retval(self, *args) -> "bool":
def is_ctr(self, *args) -> "bool":
def is_dtr(self, *args) -> "bool":
def is_cdtr(self, *args) -> "bool":
def get_mba_flags(self, *args) -> "int":
def get_mba_flags2(self, *args) -> "int":
def set_mba_flags(self, *args) -> "void":
def clr_mba_flags(self, *args) -> "void":
def set_mba_flags2(self, *args) -> "void":
def clr_mba_flags2(self, *args) -> "void":
def clr_cdtr(self, *args) -> "void":
def calc_shins_flags(self, *args) -> "int":
def stkoff_vd2ida(self, *args) -> "sval_t":
def stkoff_ida2vd(self, *args) -> "sval_t":
def argbase(self, *args) -> "sval_t":
def idaloc2vd(self, *args) -> "vdloc_t":
def vd2idaloc(self, *args) -> "argloc_t":
def is_stkarg(self, *args) -> "bool":
def get_ida_argloc(self, *args) -> "argloc_t":
def write_to_const_detected(self, *args) -> "bool":
def bad_call_sp_detected(self, *args) -> "bool":
def regargs_is_not_aligned(self, *args) -> "bool":
def has_bad_sp(self, *args) -> "bool":
def term(self, *args) -> "void":
def get_curfunc(self, *args) -> "func_t *":
def use_frame(self, *args) -> "bool":
def is_snippet(self, *args) -> "bool":
def set_maturity(self, *args) -> "bool":
def optimize_local(self, *args) -> "int":
def build_graph(self, *args) -> "merror_t":
def get_graph(self, *args) -> "mbl_graph_t *":
def analyze_calls(self, *args) -> "int":
def optimize_global(self, *args) -> "merror_t":
def alloc_lvars(self, *args) -> "void":
def dump(self, *args) -> "void":
def dump_mba(self, *args) -> "void":
def _print(self, *args) -> "void":
def verify(self, *args) -> "void":
def mark_chains_dirty(self, *args) -> "void":
Mark the microcode use-def chains dirty. Call this function is any inter-block
def get_mblock(self, *args) -> "mblock_t *":
def insert_block(self, *args) -> "mblock_t *":
def remove_block(self, *args) -> "bool":
def copy_block(self, *args) -> "mblock_t *":
def remove_empty_and_unreachable_blocks(self, *args) -> "bool":
def combine_blocks(self, *args) -> "bool":
def for_all_ops(self, *args) -> "int":
def for_all_insns(self, *args) -> "int":
def for_all_topinsns(self, *args) -> "int":
def find_mop(self, *args) -> "mop_t *":
def create_helper_call(self, *args) -> "minsn_t *":
def arg(self, *args) -> "lvar_t const &":
def alloc_fict_ea(self, *args) -> "ea_t":
def map_fict_ea(self, *args) -> "ea_t":
def get_std_region(self, *args) -> "ivl_t const &":
def get_lvars_region(self, *args) -> "ivl_t const &":
def get_shadow_region(self, *args) -> "ivl_t const &":
def get_args_region(self, *args) -> "ivl_t const &":
def get_stack_region(self, *args) -> "ivl_t":
def serialize(self, *args) -> "void":
def deserialize(*args) -> "mba_t *":
def save_snapshot(self, *args) -> "void":
def alloc_kreg(self, *args) -> "mreg_t":
def free_kreg(self, *args) -> "void":
def _register(self, *args) -> "void":
def _deregister(self, *args) -> "void":
def mba_t_deserialize(*args) -> "mba_t *":
def __init__(self, *args):
def front(self, *args) -> "block_chains_t &":
def back(self, *args) -> "block_chains_t &":
def for_all_chains(self, *args) -> "int":
def __init__(self, *args, **kwargs):
def is_ud_chain_dirty(self, *args) -> "bool":
Is the use-def chain of the specified kind dirty?
def is_du_chain_dirty(self, *args) -> "bool":
def get_chain_stamp(self, *args) -> "int":
def get_ud(self, *args) -> "graph_chains_t *":
Get use-def chains.
def get_du(self, *args) -> "graph_chains_t *":
def is_redefined_globally(self, *args) -> "bool":
def is_used_globally(self, *args) -> "bool":
def get_mblock(self, *args) -> "mblock_t *":
def __init__(self, *args):
def ok(self, *args) -> "bool":
def has_dslot(self, *args) -> "bool":
def dslot_with_xrefs(self, *args) -> "bool":
def is_severed_dslot(self, *args) -> "bool":
def start(self, *args) -> "void":
def next(self, *args) -> "merror_t":
def __init__(self, *args, **kwargs):
def analyze_prolog(self, *args) -> "merror_t":
def gen_micro(self, *args) -> "merror_t":
def load_operand(self, *args) -> "mreg_t":
def microgen_completed(self, *args) -> "void":
def prepare_gen_micro(self, *args) -> "merror_t":
def load_effective_address(self, *args) -> "mreg_t":
def store_operand(self, *args) -> "bool":
def emit_micro_mvm(self, *args) -> "minsn_t *":
def emit(self, *args) -> "minsn_t *":
def get_hexrays_version(*args) -> "char const *":
def checkout_hexrays_license(*args) -> "bool":
def open_pseudocode(*args) -> "vdui_t *":
def close_pseudocode(*args) -> "bool":
def decompile_many(*args) -> "bool":
def __init__(self, *args):
def desc(self, *args) -> "qstring":
def __init__(self, *args):
def desc(self, *args) -> "qstring":
def __init__(self, *args):
def send_database(*args) -> "void":
def is_reg(self, *args) -> "bool":
def is_use(self, *args) -> "bool":
def is_def(self, *args) -> "bool":
def append_to_list(self, *args) -> "bool":
def cvt_to_ivl(self, *args) -> "vivl_t":
def __init__(self, *args):
def get_current_operand(*args) -> "bool":
def remitem(*args) -> "void":
def negated_relation(*args) -> "ctype_t":
def swapped_relation(*args) -> "ctype_t":
def get_op_signness(*args) -> "type_sign_t":
def asgop(*args) -> "ctype_t":
def asgop_revert(*args) -> "ctype_t":
def op_uses_x(*args) -> "bool":
def op_uses_y(*args) -> "bool":
def op_uses_z(*args) -> "bool":
def is_binary(*args) -> "bool":
def is_unary(*args) -> "bool":
def is_relational(*args) -> "bool":
def is_assignment(*args) -> "bool":
def accepts_udts(*args) -> "bool":
def is_prepost(*args) -> "bool":
def is_commutative(*args) -> "bool":
def is_additive(*args) -> "bool":
def is_multiplicative(*args) -> "bool":
def is_bitop(*args) -> "bool":
def is_logical(*args) -> "bool":
def is_loop(*args) -> "bool":
def is_break_consumer(*args) -> "bool":
def is_lvalue(*args) -> "bool":
def accepts_small_udts(*args) -> "bool":
def __init__(self, *args):
def _print(self, *args) -> "void":
def value(self, *args) -> "uint64":
def assign(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def getv(self, *args) -> "lvar_t &":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def maintain_parents(self, *args) -> "bool":
def must_prune(self, *args) -> "bool":
def must_restart(self, *args) -> "bool":
def is_postorder(self, *args) -> "bool":
def only_insns(self, *args) -> "bool":
def prune_now(self, *args) -> "void":
def clr_prune(self, *args) -> "void":
def set_restart(self, *args) -> "void":
def clr_restart(self, *args) -> "void":
def __init__(self, *args):
def apply_to(self, *args) -> "int":
def apply_to_exprs(self, *args) -> "int":
def parent_expr(self, *args) -> "cexpr_t *":
def parent_insn(self, *args) -> "cinsn_t *":
def visit_insn(self, *args) -> "int":
def visit_expr(self, *args) -> "int":
def leave_insn(self, *args) -> "int":
def leave_expr(self, *args) -> "int":
def __disown__(self):
def __init__(self, *args):
def recalc_parent_types(self, *args) -> "bool":
def get_block(self, *args) -> "cblock_t *":
def __disown__(self):
def __init__(self, *args):
def calc_rvalue_type(self, *args) -> "bool":
def __disown__(self):
def __lt__(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def c_str(self, *args) -> "char const *":
def __str__(self, *args) -> "char const *":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def swap(self, *args) -> "void":
def is_expr(self, *args) -> "bool":
def contains_expr(self, *args) -> "bool":
def contains_label(self, *args) -> "bool":
def find_parent_of(self, *args) -> "citem_t *":
def find_closest_addr(self, *args) -> "citem_t *":
def print1(self, *args) -> "void":
def _get_op(self, *args) -> "ctype_t":
def _set_op(self, *args) -> "void":
def _ensure_no_op(self):
def __dbg_get_meminfo(self, *args) -> "qstring":
def __dbg_get_registered_kind(self, *args) -> "int":
def _obj_id(self, *args) -> "PyObject *":
def _ensure_cond(self, ok, cond_str):
def _ensure_no_obj(self, o, attr, attr_is_acquired):
def _ensure_ownership_transferrable(self, v):
def _acquire_ownership(self, v, acquire):
def _maybe_disown_and_deregister(self):
def _own_and_register(self):
def replace_by(self, o):
def _meminfo(self):
def cpadone(self, *args) -> "bool":
def is_odd_lvalue(self, *args) -> "bool":
def is_fpop(self, *args) -> "bool":
def is_cstr(self, *args) -> "bool":
def is_undef_val(self, *args) -> "bool":
def is_jumpout(self, *args) -> "bool":
def is_vftable(self, *args) -> "bool":
def set_cpadone(self, *args) -> "void":
def set_vftable(self, *args) -> "void":
def __init__(self, *args):
def swap(self, *args) -> "void":
def assign(self, *args) -> "cexpr_t &":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def _replace_by(self, *args) -> "void":
def cleanup(self, *args) -> "void":
def put_number(self, *args) -> "void":
def print1(self, *args) -> "void":
def calc_type(self, *args) -> "void":
def equal_effect(self, *args) -> "bool":
def is_child_of(self, *args) -> "bool":
def contains_operator(self, *args) -> "bool":
def contains_comma(self, *args) -> "bool":
def contains_insn(self, *args) -> "bool":
def contains_insn_or_label(self, *args) -> "bool":
def contains_comma_or_insn_or_label(self, *args) -> "bool":
def is_nice_expr(self, *args) -> "bool":
def is_nice_cond(self, *args) -> "bool":
def is_call_object_of(self, *args) -> "bool":
def is_call_arg_of(self, *args) -> "bool":
def get_type_sign(self, *args) -> "type_sign_t":
def is_type_unsigned(self, *args) -> "bool":
def is_type_signed(self, *args) -> "bool":
def get_high_nbit_bound(self, *args) -> "bit_bound_t":
def get_low_nbit_bound(self, *args) -> "int":
def requires_lvalue(self, *args) -> "bool":
def has_side_effects(self, *args) -> "bool":
def numval(self, *args) -> "uint64":
def is_const_value(self, *args) -> "bool":
def is_negative_const(self, *args) -> "bool":
def is_non_negative_const(self, *args) -> "bool":
def is_non_zero_const(self, *args) -> "bool":
def is_zero_const(self, *args) -> "bool":
def get_const_value(self, *args) -> "bool":
def maybe_ptr(self, *args) -> "bool":
def get_ptr_or_array(self, *args) -> "cexpr_t *":
def find_op(self, *args) -> "cexpr_t *":
def find_num_op(self, *args) -> "cexpr_t *":
def theother(self, *args) -> "cexpr_t *":
def get_1num_op(self, *args) -> "bool":
def _register(self, *args) -> "void":
def _deregister(self, *args) -> "void":
def get_v(self, *args) -> "var_ref_t *":
def set_v(self, *args) -> "void":
def _get_n(self, *args) -> "cnumber_t *":
def _set_n(self, *args) -> "void":
def _get_fpc(self, *args) -> "fnumber_t *":
def _set_fpc(self, *args) -> "void":
def _get_x(self, *args) -> "cexpr_t *":
def _set_x(self, *args) -> "void":
def _get_y(self, *args) -> "cexpr_t *":
def _set_y(self, *args) -> "void":
def _get_z(self, *args) -> "cexpr_t *":
def _set_z(self, *args) -> "void":
def _get_a(self, *args) -> "carglist_t *":
def _set_a(self, *args) -> "void":
def _get_insn(self, *args) -> "cinsn_t *":
def _set_insn(self, *args) -> "void":
def _get_m(self, *args) -> "int":
def _set_m(self, *args) -> "void":
def _get_ptrsize(self, *args) -> "int":
def _set_ptrsize(self, *args) -> "void":
def _get_obj_ea(self, *args) -> "ea_t":
def _set_obj_ea(self, *args) -> "void":
def _get_refwidth(self, *args) -> "int":
def _set_refwidth(self, *args) -> "void":
def _get_helper(self, *args) -> "char const *":
def _set_helper(self, *args) -> "void":
def _get_string(self, *args) -> "char const *":
def _set_string(self, *args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def assign(self, *args) -> "cif_t &":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def cleanup(self, *args) -> "void":
def __init__(self, *args):
def assign(self, *args) -> "cloop_t &":
def cleanup(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def one_insn(self, *args) -> "bool":
def __init__(self, *args):
def swap(self, *args) -> "void":
def assign(self, *args) -> "cinsn_t &":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def _replace_by(self, *args) -> "void":
def cleanup(self, *args) -> "void":
def zero(self, *args) -> "void":
def new_insn(self, *args) -> "cinsn_t &":
def create_if(self, *args) -> "cif_t &":
def _print(self, *args) -> "void":
def print1(self, *args) -> "void":
def is_ordinary_flow(self, *args) -> "bool":
def contains_insn(self, *args) -> "bool":
def collect_free_breaks(self, *args) -> "bool":
def collect_free_continues(self, *args) -> "bool":
def contains_free_break(self, *args) -> "bool":
def contains_free_continue(self, *args) -> "bool":
def _register(self, *args) -> "void":
def _deregister(self, *args) -> "void":
def insn_is_epilog(*args) -> "bool":
def is_epilog(self):
def _get_cblock(self, *args) -> "cblock_t *":
def _set_cblock(self, *args) -> "void":
def _get_cexpr(self, *args) -> "cexpr_t *":
def _set_cexpr(self, *args) -> "void":
def _get_cif(self, *args) -> "cif_t *":
def _set_cif(self, *args) -> "void":
def _get_cfor(self, *args) -> "cfor_t *":
def _set_cfor(self, *args) -> "void":
def _get_cwhile(self, *args) -> "cwhile_t *":
def _set_cwhile(self, *args) -> "void":
def _get_cdo(self, *args) -> "cdo_t *":
def _set_cdo(self, *args) -> "void":
def _get_cswitch(self, *args) -> "cswitch_t *":
def _set_cswitch(self, *args) -> "void":
def _get_creturn(self, *args) -> "creturn_t *":
def _set_creturn(self, *args) -> "void":
def _get_cgoto(self, *args) -> "cgoto_t *":
def _set_cgoto(self, *args) -> "void":
def _get_casm(self, *args) -> "casm_t *":
def _set_casm(self, *args) -> "void":
def cinsn_t_insn_is_epilog(*args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def _deregister(self, *args) -> "void":
def consume_cexpr(self, *args) -> "void":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def size(self, *args) -> "size_t":
def value(self, *args) -> "uint64 const &":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def get_index(self, *args) -> "int":
def get_itp(self, *args) -> "item_preciser_t":
def is_valid_anchor(self, *args) -> "bool":
def is_citem_anchor(self, *args) -> "bool":
def is_lvar_anchor(self, *args) -> "bool":
def is_itp_anchor(self, *args) -> "bool":
def is_blkcmt_anchor(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def get_memptr(self, *args) -> "member_t *":
def get_lvar(self, *args) -> "lvar_t *":
def get_ea(self, *args) -> "ea_t":
def get_label_num(self, *args) -> "int":
def is_citem(self, *args) -> "bool":
def _get_it(self, *args) -> "citem_t *":
def _get_e(self, *args) -> "cexpr_t *":
def _get_i(self, *args) -> "cinsn_t *":
def _get_l(self, *args) -> "lvar_t *":
def _get_f(self, *args) -> "cfunc_t *":
def _ll_lnot(*args) -> "cexpr_t *":
def _ll_new_block(*args) -> "cinsn_t *":
def _ll_create_helper(*args) -> "cexpr_t *":
def _ll_call_helper(*args) -> "cexpr_t *":
def _ll_make_num(*args) -> "cexpr_t *":
def _ll_make_ref(*args) -> "cexpr_t *":
def _ll_dereference(*args) -> "cexpr_t *":
def save_user_labels(*args) -> "void":
def save_user_labels2(*args) -> "void":
def save_user_cmts(*args) -> "void":
def save_user_numforms(*args) -> "void":
def save_user_iflags(*args) -> "void":
def save_user_unions(*args) -> "void":
def restore_user_labels(*args) -> "user_labels_t *":
def restore_user_labels2(*args) -> "user_labels_t *":
def restore_user_cmts(*args) -> "user_cmts_t *":
def restore_user_numforms(*args) -> "user_numforms_t *":
def restore_user_iflags(*args) -> "user_iflags_t *":
def restore_user_unions(*args) -> "user_unions_t *":
def __init__(self, *args, **kwargs):
def release(self, *args) -> "void":
def build_c_tree(self, *args) -> "void":
def verify(self, *args) -> "void":
def print_dcl(self, *args) -> "void":
def print_func(self, *args) -> "void":
def get_func_type(self, *args) -> "bool":
def get_lvars(self, *args) -> "lvars_t *":
def get_stkoff_delta(self, *args) -> "sval_t":
def find_label(self, *args) -> "citem_t *":
def remove_unused_labels(self, *args) -> "void":
def get_user_cmt(self, *args) -> "char const *":
def set_user_cmt(self, *args) -> "void":
def get_user_iflags(self, *args) -> "int32":
def set_user_iflags(self, *args) -> "void":
def has_orphan_cmts(self, *args) -> "bool":
def del_orphan_cmts(self, *args) -> "int":
def get_user_union_selection(self, *args) -> "bool":
def set_user_union_selection(self, *args) -> "void":
def save_user_labels(self, *args) -> "void":
def save_user_cmts(self, *args) -> "void":
def save_user_numforms(self, *args) -> "void":
def save_user_iflags(self, *args) -> "void":
def save_user_unions(self, *args) -> "void":
def get_line_item(self, *args) -> "bool":
def get_warnings(self, *args) -> "hexwarns_t &":
def get_eamap(self, *args) -> "eamap_t &":
def get_boundaries(self, *args) -> "boundaries_t &":
def get_pseudocode(self, *args) -> "strvec_t const &":
def refresh_func_ctext(self, *args) -> "void":
def gather_derefs(self, *args) -> "bool":
def locked(self, *args) -> "bool":
def find_item_coords(self, *args) -> "PyObject *":
def __str__(self, *args) -> "qstring":
def close_hexrays_waitbox(*args) -> "void":
def decompile(*args) -> "cfuncptr_t":
def decompile_func(*args) -> "cfuncptr_t":
def gen_microcode(*args) -> "mba_t *":
def create_cfunc(*args) -> "cfuncptr_t":
def mark_cfunc_dirty(*args) -> "bool":
def clear_cached_cfuncs(*args) -> "void":
def has_cached_cfunc(*args) -> "bool":
def get_ctype_name(*args) -> "char const *":
def create_field_name(*args) -> "qstring":
def in_ctree(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args, **kwargs):
def visible(self, *args) -> "bool":
def valid(self, *args) -> "bool":
def locked(self, *args) -> "bool":
def set_visible(self, *args) -> "void":
def set_valid(self, *args) -> "void":
def set_locked(self, *args) -> "bool":
def refresh_view(self, *args) -> "void":
def refresh_ctext(self, *args) -> "void":
def switch_to(self, *args) -> "void":
def in_ctree(self, *args) -> "bool":
def get_number(self, *args) -> "cnumber_t *":
def get_current_label(self, *args) -> "int":
def clear(self, *args) -> "void":
def refresh_cpos(self, *args) -> "bool":
def get_current_item(self, *args) -> "bool":
def ui_rename_lvar(self, *args) -> "bool":
def rename_lvar(self, *args) -> "bool":
def ui_set_call_type(self, *args) -> "bool":
def ui_set_lvar_type(self, *args) -> "bool":
def set_lvar_type(self, *args) -> "bool":
def set_noptr_lvar(self, *args) -> "bool":
def ui_edit_lvar_cmt(self, *args) -> "bool":
def set_lvar_cmt(self, *args) -> "bool":
def ui_map_lvar(self, *args) -> "bool":
def ui_unmap_lvar(self, *args) -> "bool":
def map_lvar(self, *args) -> "bool":
def set_strmem_type(self, *args) -> "bool":
def rename_strmem(self, *args) -> "bool":
def set_global_type(self, *args) -> "bool":
def rename_global(self, *args) -> "bool":
def rename_label(self, *args) -> "bool":
def jump_enter(self, *args) -> "bool":
def ctree_to_disasm(self, *args) -> "bool":
def calc_cmt_type(self, *args) -> "cmt_type_t":
def edit_cmt(self, *args) -> "bool":
def edit_func_cmt(self, *args) -> "bool":
def del_orphan_cmts(self, *args) -> "bool":
def set_num_radix(self, *args) -> "bool":
def set_num_enum(self, *args) -> "bool":
def set_num_stroff(self, *args) -> "bool":
def invert_sign(self, *args) -> "bool":
def invert_bits(self, *args) -> "bool":
def collapse_item(self, *args) -> "bool":
def collapse_lvars(self, *args) -> "bool":
def split_item(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def apply(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def select_udt_by_offset(*args) -> "int":
hx_create_typedef = _ida_hexrays.hx_create_typedef
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def user_numforms_first(*args) -> "operand_locator_t const &":
def user_numforms_second(*args) -> "number_format_t &":
def user_numforms_find(*args) -> "user_numforms_iterator_t":
def user_numforms_insert(*args) -> "user_numforms_iterator_t":
def user_numforms_begin(*args) -> "user_numforms_iterator_t":
def user_numforms_end(*args) -> "user_numforms_iterator_t":
def user_numforms_next(*args) -> "user_numforms_iterator_t":
def user_numforms_prev(*args) -> "user_numforms_iterator_t":
def user_numforms_erase(*args) -> "void":
def user_numforms_clear(*args) -> "void":
def user_numforms_size(*args) -> "size_t":
def user_numforms_free(*args) -> "void":
def user_numforms_new(*args) -> "user_numforms_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def lvar_mapping_first(*args) -> "lvar_locator_t const &":
def lvar_mapping_second(*args) -> "lvar_locator_t &":
def lvar_mapping_find(*args) -> "lvar_mapping_iterator_t":
def lvar_mapping_insert(*args) -> "lvar_mapping_iterator_t":
def lvar_mapping_begin(*args) -> "lvar_mapping_iterator_t":
def lvar_mapping_end(*args) -> "lvar_mapping_iterator_t":
def lvar_mapping_next(*args) -> "lvar_mapping_iterator_t":
def lvar_mapping_prev(*args) -> "lvar_mapping_iterator_t":
def lvar_mapping_erase(*args) -> "void":
def lvar_mapping_clear(*args) -> "void":
def lvar_mapping_size(*args) -> "size_t":
def lvar_mapping_free(*args) -> "void":
def lvar_mapping_new(*args) -> "lvar_mapping_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def udcall_map_first(*args) -> "ea_t const &":
def udcall_map_second(*args) -> "udcall_t &":
def udcall_map_find(*args) -> "udcall_map_iterator_t":
def udcall_map_insert(*args) -> "udcall_map_iterator_t":
def udcall_map_begin(*args) -> "udcall_map_iterator_t":
def udcall_map_end(*args) -> "udcall_map_iterator_t":
def udcall_map_next(*args) -> "udcall_map_iterator_t":
def udcall_map_prev(*args) -> "udcall_map_iterator_t":
def udcall_map_erase(*args) -> "void":
def udcall_map_clear(*args) -> "void":
def udcall_map_size(*args) -> "size_t":
def udcall_map_free(*args) -> "void":
def udcall_map_new(*args) -> "udcall_map_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def user_cmts_first(*args) -> "treeloc_t const &":
def user_cmts_second(*args) -> "citem_cmt_t &":
def user_cmts_find(*args) -> "user_cmts_iterator_t":
def user_cmts_insert(*args) -> "user_cmts_iterator_t":
def user_cmts_begin(*args) -> "user_cmts_iterator_t":
def user_cmts_end(*args) -> "user_cmts_iterator_t":
def user_cmts_next(*args) -> "user_cmts_iterator_t":
def user_cmts_prev(*args) -> "user_cmts_iterator_t":
def user_cmts_erase(*args) -> "void":
def user_cmts_clear(*args) -> "void":
def user_cmts_size(*args) -> "size_t":
def user_cmts_free(*args) -> "void":
def user_cmts_new(*args) -> "user_cmts_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def user_iflags_first(*args) -> "citem_locator_t const &":
def user_iflags_find(*args) -> "user_iflags_iterator_t":
def user_iflags_insert(*args) -> "user_iflags_iterator_t":
def user_iflags_begin(*args) -> "user_iflags_iterator_t":
def user_iflags_end(*args) -> "user_iflags_iterator_t":
def user_iflags_next(*args) -> "user_iflags_iterator_t":
def user_iflags_prev(*args) -> "user_iflags_iterator_t":
def user_iflags_erase(*args) -> "void":
def user_iflags_clear(*args) -> "void":
def user_iflags_size(*args) -> "size_t":
def user_iflags_free(*args) -> "void":
def user_iflags_new(*args) -> "user_iflags_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def user_unions_first(*args) -> "ea_t const &":
def user_unions_second(*args) -> "intvec_t &":
def user_unions_find(*args) -> "user_unions_iterator_t":
def user_unions_insert(*args) -> "user_unions_iterator_t":
def user_unions_begin(*args) -> "user_unions_iterator_t":
def user_unions_end(*args) -> "user_unions_iterator_t":
def user_unions_next(*args) -> "user_unions_iterator_t":
def user_unions_prev(*args) -> "user_unions_iterator_t":
def user_unions_erase(*args) -> "void":
def user_unions_clear(*args) -> "void":
def user_unions_size(*args) -> "size_t":
def user_unions_free(*args) -> "void":
def user_unions_new(*args) -> "user_unions_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def user_labels_first(*args) -> "int const &":
def user_labels_second(*args) -> "qstring &":
def user_labels_find(*args) -> "user_labels_iterator_t":
def user_labels_insert(*args) -> "user_labels_iterator_t":
def user_labels_begin(*args) -> "user_labels_iterator_t":
def user_labels_end(*args) -> "user_labels_iterator_t":
def user_labels_next(*args) -> "user_labels_iterator_t":
def user_labels_prev(*args) -> "user_labels_iterator_t":
def user_labels_erase(*args) -> "void":
def user_labels_clear(*args) -> "void":
def user_labels_size(*args) -> "size_t":
def user_labels_free(*args) -> "void":
def user_labels_new(*args) -> "user_labels_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def eamap_first(*args) -> "ea_t const &":
def eamap_second(*args) -> "cinsnptrvec_t &":
def eamap_find(*args) -> "eamap_iterator_t":
def eamap_insert(*args) -> "eamap_iterator_t":
def eamap_begin(*args) -> "eamap_iterator_t":
def eamap_end(*args) -> "eamap_iterator_t":
def eamap_next(*args) -> "eamap_iterator_t":
def eamap_prev(*args) -> "eamap_iterator_t":
def eamap_erase(*args) -> "void":
def eamap_clear(*args) -> "void":
def eamap_size(*args) -> "size_t":
def eamap_free(*args) -> "void":
def eamap_new(*args) -> "eamap_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def boundaries_first(*args) -> "cinsn_t *const &":
def boundaries_second(*args) -> "rangeset_t &":
def boundaries_begin(*args) -> "boundaries_iterator_t":
def boundaries_end(*args) -> "boundaries_iterator_t":
def boundaries_next(*args) -> "boundaries_iterator_t":
def boundaries_prev(*args) -> "boundaries_iterator_t":
def boundaries_erase(*args) -> "void":
def boundaries_clear(*args) -> "void":
def boundaries_size(*args) -> "size_t":
def boundaries_free(*args) -> "void":
def boundaries_new(*args) -> "boundaries_t *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def block_chains_get(*args) -> "chain_t &":
def block_chains_find(*args) -> "block_chains_iterator_t":
def block_chains_insert(*args) -> "block_chains_iterator_t":
def block_chains_begin(*args) -> "block_chains_iterator_t":
def block_chains_end(*args) -> "block_chains_iterator_t":
def block_chains_next(*args) -> "block_chains_iterator_t":
def block_chains_prev(*args) -> "block_chains_iterator_t":
def block_chains_erase(*args) -> "void":
def block_chains_clear(*args) -> "void":
def block_chains_size(*args) -> "size_t":
def block_chains_free(*args) -> "void":
def block_chains_new(*args) -> "block_chains_t *":
def __init__(self, info):
def decompile(ea, hf=None, flags=0):
def citem_to_specific_type(self):
def property_op_to_typename(self):
def cexpr_operands(self):
def cinsn_details(self):
def cfunc_type(self):
def _map_as_dict(maptype, name, keytype, valuetype):
def _map___iter__(self):
def _map___getitem__(self, key):
def _map___setitem__(self, key, value):
def _map___delitem__(self, key):
def _map___contains__(self, key):
def _map_clear(self):
def _map_copy(self):
def _map_get(self, key, default=None):
def _map_iterkeys(self):
def _map_itervalues(self):
def _map_iteritems(self):
def _map_keys(self):
def _map_values(self):
def _map_items(self):
def _map_has_key(self, key):
def _map_pop(self, key):
def _map_popitem(self):
def _map_setdefault(self, key, default=None):
def _call_with_transferrable_ownership(fun, *args):
def lnot(e):
def make_ref(e):
def dereference(e, ptrsize, is_float=False):
def call_helper(rettype, args, *rest):
def new_block():
def make_num(*args):
def create_helper(*args):
def __init__(self, callback):
def maturity(self, *args): return self.callback(hxe_maturity, *args)
def interr(self, *args): return self.callback(hxe_interr, *args)
def print_func(self, *args): return self.callback(hxe_print_func, *args)
def func_printed(self, *args): return self.callback(hxe_func_printed, *args)
def open_pseudocode(self, *args): return self.callback(hxe_open_pseudocode, *args)
def switch_pseudocode(self, *args): return self.callback(hxe_switch_pseudocode, *args)
def refresh_pseudocode(self, *args): return self.callback(hxe_refresh_pseudocode, *args)
def close_pseudocode(self, *args): return self.callback(hxe_close_pseudocode, *args)
def keyboard(self, *args): return self.callback(hxe_keyboard, *args)
def right_click(self, *args): return self.callback(hxe_right_click, *args)
def double_click(self, *args): return self.callback(hxe_double_click, *args)
def curpos(self, *args): return self.callback(hxe_curpos, *args)
def create_hint(self, *args): return self.callback(hxe_create_hint, *args)
def text_ready(self, *args): return self.callback(hxe_text_ready, *args)
def populating_popup(self, *args): return self.callback(hxe_populating_popup, *args)
def install_hexrays_callback(callback):
def remove_hexrays_callback(callback):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def is_filetype_like_binary(*args) -> "bool":
def __init__(self, *args):
def __init__(self, *args, **kwargs):
def get_abiname(self, *args) -> "qstring":
def getinf_str(*args) -> "qstring *":
def delinf(*args) -> "bool":
def inf_get_version(*args) -> "ushort":
def inf_set_version(*args) -> "bool":
def inf_get_genflags(*args) -> "ushort":
def inf_set_genflags(*args) -> "bool":
def inf_is_auto_enabled(*args) -> "bool":
def inf_set_auto_enabled(*args) -> "bool":
def inf_use_allasm(*args) -> "bool":
def inf_set_use_allasm(*args) -> "bool":
def inf_loading_idc(*args) -> "bool":
def inf_set_loading_idc(*args) -> "bool":
def inf_no_store_user_info(*args) -> "bool":
def inf_set_no_store_user_info(*args) -> "bool":
def inf_readonly_idb(*args) -> "bool":
def inf_set_readonly_idb(*args) -> "bool":
def inf_check_manual_ops(*args) -> "bool":
def inf_set_check_manual_ops(*args) -> "bool":
def inf_allow_non_matched_ops(*args) -> "bool":
def inf_set_allow_non_matched_ops(*args) -> "bool":
def inf_is_graph_view(*args) -> "bool":
def inf_set_graph_view(*args) -> "bool":
def inf_get_lflags(*args) -> "uint32":
def inf_set_lflags(*args) -> "bool":
def inf_decode_fpp(*args) -> "bool":
def inf_set_decode_fpp(*args) -> "bool":
def inf_is_32bit_or_higher(*args) -> "bool":
def inf_is_32bit_exactly(*args) -> "bool":
def inf_set_32bit(*args) -> "bool":
def inf_is_16bit(*args) -> "bool":
def inf_is_64bit(*args) -> "bool":
def inf_set_64bit(*args) -> "bool":
def inf_is_dll(*args) -> "bool":
def inf_set_dll(*args) -> "bool":
def inf_is_flat_off32(*args) -> "bool":
def inf_set_flat_off32(*args) -> "bool":
def inf_is_be(*args) -> "bool":
def inf_set_be(*args) -> "bool":
def inf_is_wide_high_byte_first(*args) -> "bool":
def inf_set_wide_high_byte_first(*args) -> "bool":
def inf_dbg_no_store_path(*args) -> "bool":
def inf_set_dbg_no_store_path(*args) -> "bool":
def inf_is_snapshot(*args) -> "bool":
def inf_set_snapshot(*args) -> "bool":
def inf_pack_idb(*args) -> "bool":
def inf_set_pack_idb(*args) -> "bool":
def inf_compress_idb(*args) -> "bool":
def inf_set_compress_idb(*args) -> "bool":
def inf_is_kernel_mode(*args) -> "bool":
def inf_set_kernel_mode(*args) -> "bool":
def inf_get_app_bitness(*args) -> "uint":
def inf_get_database_change_count(*args) -> "uint32":
def inf_set_database_change_count(*args) -> "bool":
def inf_get_filetype(*args) -> "filetype_t":
def inf_set_filetype(*args) -> "bool":
def inf_get_ostype(*args) -> "ushort":
def inf_set_ostype(*args) -> "bool":
def inf_get_apptype(*args) -> "ushort":
def inf_set_apptype(*args) -> "bool":
def inf_get_asmtype(*args) -> "uchar":
def inf_set_asmtype(*args) -> "bool":
def inf_get_specsegs(*args) -> "uchar":
def inf_set_specsegs(*args) -> "bool":
def inf_get_af(*args) -> "uint32":
def inf_set_af(*args) -> "bool":
def inf_trace_flow(*args) -> "bool":
def inf_set_trace_flow(*args) -> "bool":
def inf_mark_code(*args) -> "bool":
def inf_set_mark_code(*args) -> "bool":
def inf_create_jump_tables(*args) -> "bool":
def inf_set_create_jump_tables(*args) -> "bool":
def inf_noflow_to_data(*args) -> "bool":
def inf_set_noflow_to_data(*args) -> "bool":
def inf_create_all_xrefs(*args) -> "bool":
def inf_set_create_all_xrefs(*args) -> "bool":
def inf_del_no_xref_insns(*args) -> "bool":
def inf_set_del_no_xref_insns(*args) -> "bool":
def inf_create_func_from_ptr(*args) -> "bool":
def inf_set_create_func_from_ptr(*args) -> "bool":
def inf_create_func_from_call(*args) -> "bool":
def inf_set_create_func_from_call(*args) -> "bool":
def inf_create_func_tails(*args) -> "bool":
def inf_set_create_func_tails(*args) -> "bool":
def inf_should_create_stkvars(*args) -> "bool":
def inf_set_should_create_stkvars(*args) -> "bool":
def inf_propagate_stkargs(*args) -> "bool":
def inf_set_propagate_stkargs(*args) -> "bool":
def inf_propagate_regargs(*args) -> "bool":
def inf_set_propagate_regargs(*args) -> "bool":
def inf_should_trace_sp(*args) -> "bool":
def inf_set_should_trace_sp(*args) -> "bool":
def inf_full_sp_ana(*args) -> "bool":
def inf_set_full_sp_ana(*args) -> "bool":
def inf_noret_ana(*args) -> "bool":
def inf_set_noret_ana(*args) -> "bool":
def inf_guess_func_type(*args) -> "bool":
def inf_set_guess_func_type(*args) -> "bool":
def inf_truncate_on_del(*args) -> "bool":
def inf_set_truncate_on_del(*args) -> "bool":
def inf_create_strlit_on_xref(*args) -> "bool":
def inf_set_create_strlit_on_xref(*args) -> "bool":
def inf_check_unicode_strlits(*args) -> "bool":
def inf_set_check_unicode_strlits(*args) -> "bool":
def inf_create_off_using_fixup(*args) -> "bool":
def inf_set_create_off_using_fixup(*args) -> "bool":
def inf_create_off_on_dref(*args) -> "bool":
def inf_set_create_off_on_dref(*args) -> "bool":
def inf_op_offset(*args) -> "bool":
def inf_set_op_offset(*args) -> "bool":
def inf_data_offset(*args) -> "bool":
def inf_set_data_offset(*args) -> "bool":
def inf_use_flirt(*args) -> "bool":
def inf_set_use_flirt(*args) -> "bool":
def inf_append_sigcmt(*args) -> "bool":
def inf_set_append_sigcmt(*args) -> "bool":
def inf_allow_sigmulti(*args) -> "bool":
def inf_set_allow_sigmulti(*args) -> "bool":
def inf_hide_libfuncs(*args) -> "bool":
def inf_set_hide_libfuncs(*args) -> "bool":
def inf_rename_jumpfunc(*args) -> "bool":
def inf_set_rename_jumpfunc(*args) -> "bool":
def inf_rename_nullsub(*args) -> "bool":
def inf_set_rename_nullsub(*args) -> "bool":
def inf_coagulate_data(*args) -> "bool":
def inf_set_coagulate_data(*args) -> "bool":
def inf_coagulate_code(*args) -> "bool":
def inf_set_coagulate_code(*args) -> "bool":
def inf_final_pass(*args) -> "bool":
def inf_set_final_pass(*args) -> "bool":
def inf_get_af2(*args) -> "uint32":
def inf_set_af2(*args) -> "bool":
def inf_handle_eh(*args) -> "bool":
def inf_set_handle_eh(*args) -> "bool":
def inf_handle_rtti(*args) -> "bool":
def inf_set_handle_rtti(*args) -> "bool":
def inf_macros_enabled(*args) -> "bool":
def inf_set_macros_enabled(*args) -> "bool":
def inf_get_baseaddr(*args) -> "uval_t":
def inf_set_baseaddr(*args) -> "bool":
def inf_get_start_ss(*args) -> "sel_t":
def inf_set_start_ss(*args) -> "bool":
def inf_get_start_cs(*args) -> "sel_t":
def inf_set_start_cs(*args) -> "bool":
def inf_get_start_ip(*args) -> "ea_t":
def inf_set_start_ip(*args) -> "bool":
def inf_get_start_ea(*args) -> "ea_t":
def inf_set_start_ea(*args) -> "bool":
def inf_get_start_sp(*args) -> "ea_t":
def inf_set_start_sp(*args) -> "bool":
def inf_get_main(*args) -> "ea_t":
def inf_set_main(*args) -> "bool":
def inf_get_min_ea(*args) -> "ea_t":
def inf_set_min_ea(*args) -> "bool":
def inf_get_max_ea(*args) -> "ea_t":
def inf_set_max_ea(*args) -> "bool":
def inf_get_omin_ea(*args) -> "ea_t":
def inf_set_omin_ea(*args) -> "bool":
def inf_get_omax_ea(*args) -> "ea_t":
def inf_set_omax_ea(*args) -> "bool":
def inf_get_lowoff(*args) -> "ea_t":
def inf_set_lowoff(*args) -> "bool":
def inf_get_highoff(*args) -> "ea_t":
def inf_set_highoff(*args) -> "bool":
def inf_get_maxref(*args) -> "uval_t":
def inf_set_maxref(*args) -> "bool":
def inf_get_netdelta(*args) -> "sval_t":
def inf_set_netdelta(*args) -> "bool":
def inf_get_xrefnum(*args) -> "uchar":
def inf_set_xrefnum(*args) -> "bool":
def inf_get_type_xrefnum(*args) -> "uchar":
def inf_set_type_xrefnum(*args) -> "bool":
def inf_get_refcmtnum(*args) -> "uchar":
def inf_set_refcmtnum(*args) -> "bool":
def inf_get_xrefflag(*args) -> "uchar":
def inf_set_xrefflag(*args) -> "bool":
def inf_show_xref_seg(*args) -> "bool":
def inf_set_show_xref_seg(*args) -> "bool":
def inf_show_xref_tmarks(*args) -> "bool":
def inf_set_show_xref_tmarks(*args) -> "bool":
def inf_show_xref_fncoff(*args) -> "bool":
def inf_set_show_xref_fncoff(*args) -> "bool":
def inf_show_xref_val(*args) -> "bool":
def inf_set_show_xref_val(*args) -> "bool":
def inf_get_max_autoname_len(*args) -> "ushort":
def inf_set_max_autoname_len(*args) -> "bool":
def inf_get_nametype(*args) -> "char":
def inf_set_nametype(*args) -> "bool":
def inf_get_short_demnames(*args) -> "uint32":
def inf_set_short_demnames(*args) -> "bool":
def inf_get_long_demnames(*args) -> "uint32":
def inf_set_long_demnames(*args) -> "bool":
def inf_get_demnames(*args) -> "uchar":
def inf_set_demnames(*args) -> "bool":
def inf_get_listnames(*args) -> "uchar":
def inf_set_listnames(*args) -> "bool":
def inf_get_indent(*args) -> "uchar":
def inf_set_indent(*args) -> "bool":
def inf_get_cmt_indent(*args) -> "uchar":
def inf_set_cmt_indent(*args) -> "bool":
def inf_get_margin(*args) -> "ushort":
def inf_set_margin(*args) -> "bool":
def inf_get_lenxref(*args) -> "ushort":
def inf_set_lenxref(*args) -> "bool":
def inf_get_outflags(*args) -> "uint32":
def inf_set_outflags(*args) -> "bool":
def inf_show_void(*args) -> "bool":
def inf_set_show_void(*args) -> "bool":
def inf_show_auto(*args) -> "bool":
def inf_set_show_auto(*args) -> "bool":
def inf_gen_null(*args) -> "bool":
def inf_set_gen_null(*args) -> "bool":
def inf_show_line_pref(*args) -> "bool":
def inf_set_show_line_pref(*args) -> "bool":
def inf_line_pref_with_seg(*args) -> "bool":
def inf_set_line_pref_with_seg(*args) -> "bool":
def inf_gen_lzero(*args) -> "bool":
def inf_set_gen_lzero(*args) -> "bool":
def inf_gen_org(*args) -> "bool":
def inf_set_gen_org(*args) -> "bool":
def inf_gen_assume(*args) -> "bool":
def inf_set_gen_assume(*args) -> "bool":
def inf_gen_tryblks(*args) -> "bool":
def inf_set_gen_tryblks(*args) -> "bool":
def inf_get_cmtflg(*args) -> "uchar":
def inf_set_cmtflg(*args) -> "bool":
def inf_show_repeatables(*args) -> "bool":
def inf_set_show_repeatables(*args) -> "bool":
def inf_show_all_comments(*args) -> "bool":
def inf_set_show_all_comments(*args) -> "bool":
def inf_hide_comments(*args) -> "bool":
def inf_set_hide_comments(*args) -> "bool":
def inf_show_src_linnum(*args) -> "bool":
def inf_set_show_src_linnum(*args) -> "bool":
def inf_test_mode(*args) -> "bool":
def inf_show_hidden_insns(*args) -> "bool":
def inf_set_show_hidden_insns(*args) -> "bool":
def inf_show_hidden_funcs(*args) -> "bool":
def inf_set_show_hidden_funcs(*args) -> "bool":
def inf_show_hidden_segms(*args) -> "bool":
def inf_set_show_hidden_segms(*args) -> "bool":
def inf_get_limiter(*args) -> "uchar":
def inf_set_limiter(*args) -> "bool":
def inf_is_limiter_thin(*args) -> "bool":
def inf_set_limiter_thin(*args) -> "bool":
def inf_is_limiter_thick(*args) -> "bool":
def inf_set_limiter_thick(*args) -> "bool":
def inf_is_limiter_empty(*args) -> "bool":
def inf_set_limiter_empty(*args) -> "bool":
def inf_get_bin_prefix_size(*args) -> "short":
def inf_set_bin_prefix_size(*args) -> "bool":
def inf_get_prefflag(*args) -> "uchar":
def inf_set_prefflag(*args) -> "bool":
def inf_prefix_show_segaddr(*args) -> "bool":
def inf_set_prefix_show_segaddr(*args) -> "bool":
def inf_prefix_show_funcoff(*args) -> "bool":
def inf_set_prefix_show_funcoff(*args) -> "bool":
def inf_prefix_show_stack(*args) -> "bool":
def inf_set_prefix_show_stack(*args) -> "bool":
def inf_prefix_truncate_opcode_bytes(*args) -> "bool":
def inf_set_prefix_truncate_opcode_bytes(*args) -> "bool":
def inf_get_strlit_flags(*args) -> "uchar":
def inf_set_strlit_flags(*args) -> "bool":
def inf_strlit_names(*args) -> "bool":
def inf_set_strlit_names(*args) -> "bool":
def inf_strlit_name_bit(*args) -> "bool":
def inf_set_strlit_name_bit(*args) -> "bool":
def inf_strlit_serial_names(*args) -> "bool":
def inf_set_strlit_serial_names(*args) -> "bool":
def inf_unicode_strlits(*args) -> "bool":
def inf_set_unicode_strlits(*args) -> "bool":
def inf_strlit_autocmt(*args) -> "bool":
def inf_set_strlit_autocmt(*args) -> "bool":
def inf_strlit_savecase(*args) -> "bool":
def inf_set_strlit_savecase(*args) -> "bool":
def inf_get_strlit_break(*args) -> "uchar":
def inf_set_strlit_break(*args) -> "bool":
def inf_get_strlit_zeroes(*args) -> "char":
def inf_set_strlit_zeroes(*args) -> "bool":
def inf_get_strtype(*args) -> "int32":
def inf_set_strtype(*args) -> "bool":
def inf_get_strlit_sernum(*args) -> "uval_t":
def inf_set_strlit_sernum(*args) -> "bool":
def inf_get_datatypes(*args) -> "uval_t":
def inf_set_datatypes(*args) -> "bool":
def inf_get_abibits(*args) -> "uint32":
def inf_set_abibits(*args) -> "bool":
def inf_is_mem_aligned4(*args) -> "bool":
def inf_set_mem_aligned4(*args) -> "bool":
def inf_pack_stkargs(*args) -> "bool":
def inf_set_pack_stkargs(*args) -> "bool":
def inf_big_arg_align(*args) -> "bool":
def inf_set_big_arg_align(*args) -> "bool":
def inf_stack_ldbl(*args) -> "bool":
def inf_set_stack_ldbl(*args) -> "bool":
def inf_stack_varargs(*args) -> "bool":
def inf_set_stack_varargs(*args) -> "bool":
def inf_is_hard_float(*args) -> "bool":
def inf_set_hard_float(*args) -> "bool":
def inf_abi_set_by_user(*args) -> "bool":
def inf_set_abi_set_by_user(*args) -> "bool":
def inf_use_gcc_layout(*args) -> "bool":
def inf_set_use_gcc_layout(*args) -> "bool":
def inf_map_stkargs(*args) -> "bool":
def inf_set_map_stkargs(*args) -> "bool":
def inf_huge_arg_align(*args) -> "bool":
def inf_set_huge_arg_align(*args) -> "bool":
def inf_get_appcall_options(*args) -> "uint32":
def inf_set_appcall_options(*args) -> "bool":
def inf_get_privrange_start_ea(*args) -> "ea_t":
def inf_set_privrange_start_ea(*args) -> "bool":
def inf_get_privrange_end_ea(*args) -> "ea_t":
def inf_set_privrange_end_ea(*args) -> "bool":
def inf_get_cc_id(*args) -> "comp_t":
def inf_set_cc_id(*args) -> "bool":
def inf_get_cc_cm(*args) -> "cm_t":
def inf_set_cc_cm(*args) -> "bool":
def inf_get_cc_size_i(*args) -> "uchar":
def inf_set_cc_size_i(*args) -> "bool":
def inf_get_cc_size_b(*args) -> "uchar":
def inf_set_cc_size_b(*args) -> "bool":
def inf_get_cc_size_e(*args) -> "uchar":
def inf_set_cc_size_e(*args) -> "bool":
def inf_get_cc_defalign(*args) -> "uchar":
def inf_set_cc_defalign(*args) -> "bool":
def inf_get_cc_size_s(*args) -> "uchar":
def inf_set_cc_size_s(*args) -> "bool":
def inf_get_cc_size_l(*args) -> "uchar":
def inf_set_cc_size_l(*args) -> "bool":
def inf_get_cc_size_ll(*args) -> "uchar":
def inf_set_cc_size_ll(*args) -> "bool":
def inf_get_cc_size_ldbl(*args) -> "uchar":
def inf_set_cc_size_ldbl(*args) -> "bool":
def inf_get_procname(*args) -> "size_t":
def inf_set_procname(*args) -> "bool":
def inf_get_strlit_pref(*args) -> "size_t":
def inf_set_strlit_pref(*args) -> "bool":
def inf_get_cc(*args) -> "bool":
def inf_set_cc(*args) -> "bool":
def inf_set_privrange(*args) -> "bool":
def inf_get_privrange(*args) -> "range_t":
def inf_get_af_low(*args) -> "ushort":
def inf_set_af_low(*args) -> "void":
def inf_get_af_high(*args) -> "ushort":
def inf_set_af_high(*args) -> "void":
def inf_get_af2_low(*args) -> "ushort":
def inf_set_af2_low(*args) -> "void":
def inf_get_pack_mode(*args) -> "int":
def inf_set_pack_mode(*args) -> "int":
def inf_inc_database_change_count(*args) -> "void":
def inf_get_demname_form(*args) -> "uchar":
def inf_postinc_strlit_sernum(*args) -> "uval_t":
def inf_like_binary(*args) -> "bool":
def calc_default_idaplace_flags(*args) -> "int":
def to_ea(*args) -> "ea_t":
def get_dbctx_id(*args) -> "ssize_t":
def get_dbctx_qty(*args) -> "size_t":
def switch_dbctx(*args) -> "dbctx_t *":
def __make_idainfo_bound(func, attr):
def __func(self, *args):
def __make_idainfo_accessors(
def __make_idainfo_getter(name):
def idainfo_is_32bit(): return not inf_is_16bit() # in reality this means "is 32bit or higher"
def __wrap_hooks_callback(klass, new_name, old_name, do_call):
def __wrapper(self, *args):
def __set_module_dynattrs(modname, pdict):
def __init__(self, orig):
def __getattribute__(self, name):
def __setattr__(self, name, value):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def require(modulename, package=None):
def _replace_module_function(replacement):
def replfun(func):
def __init__(self, lnk = None):
def __del__(self):
def _free(self):
def copy(self):
def _create_clink(self):
def _del_clink(self, lnk):
def _get_clink_ptr(self):
def assign(self, other):
def __init__(self, **kwds):
def __getitem__(self, idx):
def _qvector_front(self):
def _qvector_back(self):
def _bounded_getitem_iterator(self):
def __init__(self, cvt_id, value):
def __set_value(self, v):
def __get_value(self):
def __init__(self, v):
def __op(self, op_n, other, rev=False):
def __add__(self, other):  return self.__op(0, other)
def __sub__(self, other):  return self.__op(1, other)
def __mul__(self, other):  return self.__op(2, other)
def __div__(self, other):  return self.__op(3, other)
def __radd__(self, other): return self.__op(0, other, True)
def __rsub__(self, other): return self.__op(1, other, True)
def __rmul__(self, other): return self.__op(2, other, True)
def __rdiv__(self, other): return self.__op(3, other, True)
def __init__(self, v):
def cstr(self):
def as_cstr(val):
def as_UTF16(s):
def as_uint32(v):
def as_int32(v):
def as_signed(v, nbits = 32):
def copy_bits(v, s, e=-1):
def struct_unpack(buffer, signed = False, offs = 0):
def _utf8_native(utf8):
def IDAPython_ExecSystem(cmd):
def IDAPython_FormatExc(etype, value=None, tb=None, limit=None):
def IDAPython_ExecScript(path, g, print_error=True):
def IDAPython_LoadProcMod(path, g, print_error=True):
def IDAPython_UnLoadProcMod(script, g, print_error=True):
def __init__(self):
def debug(self, *args):
def dir_namespace(self, m, prefix):
def maybe_extend_syntactically(self, ns, name, line, syntax_char):
def get_candidates(self, qname, line, match_syntax_char):
def __call__(self, line, x):
def _listify_types(*classes):
#def notify_when_callback(nw_code)
#def notify_when_callback(nw_code, is_old_database)
Notify when the database is opened. Its callback is of the form: def notify_when_callback(nw_code, is_old_database)
Notify when the database is closed. Its callback is of the form: def notify_when_callback(nw_code)
Notify when the IDA starts. Its callback is of the form: def notify_when_callback(nw_code)
Notify when the IDA terminates. Its callback is of the form: def notify_when_callback(nw_code)
def notify_when(when, callback):
 def notify_when_callback(nw_code)
 def notify_when_callback(nw_code, is_old_database)
def __install_excepthook():
def __init__(self):
def format_seq(self, num_printer, storage, item, opn, cls):
def format_item(self, num_printer, storage, item):
def _print_hex(self, x):
def displayhook(self, item):
def _make_badattr_property(bad_attr, new_attr):
def _raise(*args):
def _make_one_time_warning_message(bad_attr, new_attr):
def f():
def _make_missed_695bwcompat_property(bad_attr, new_attr, has_setter):
def _getter(self):
def _setter(self, v):
def parse_command_line3(*args) -> "PyObject *":
def get_inf_structure(*args) -> "idainfo *":
def set_script_timeout(*args) -> "int":
def disable_script_timeout(*args) -> "void":
def enable_extlang_python(*args) -> "void":
def enable_python_cli(*args) -> "void":
def format_basestring(*args) -> "PyObject *":
def pygc_refresh(*args) -> "void":
def pygc_create_groups(*args) -> "PyObject *":
def pygc_delete_groups(*args) -> "PyObject *":
def pygc_set_groups_visibility(*args) -> "PyObject *":
def pycim_get_widget(*args) -> "TWidget *":
def pycim_view_close(*args) -> "void":
def __init__(self, *args):
def close(self, *args) -> "void":
def open(self, *args) -> "bool":
def set_linput(self, *args) -> "void":
def from_linput(*args) -> "loader_input_t *":
def from_capsule(*args) -> "loader_input_t *":
def from_fp(*args) -> "loader_input_t *":
def get_linput(self, *args) -> "linput_t *":
def open_memory(self, *args) -> "bool":
def seek(self, *args) -> "int64":
def tell(self, *args) -> "int64":
def getz(self, *args) -> "PyObject *":
def gets(self, *args) -> "PyObject *":
def read(self, *args) -> "PyObject *":
def opened(self, *args) -> "bool":
def readbytes(self, *args) -> "PyObject *":
def file2base(self, *args) -> "int":
def size(self, *args) -> "int64":
def filename(self, *args) -> "PyObject *":
def get_byte(self, *args) -> "PyObject *":
def loader_input_t_from_linput(*args) -> "loader_input_t *":
def loader_input_t_from_capsule(*args) -> "loader_input_t *":
def loader_input_t_from_fp(*args) -> "loader_input_t *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def mark_position(*args) -> "void":
def get_marked_pos(*args) -> "ea_t":
def get_mark_comment(*args) -> "PyObject *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "exception_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "exception_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "exception_info_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< exception_info_t >::const_iterator":
def end(self, *args) -> "qvector< exception_info_t >::const_iterator":
def insert(self, *args) -> "qvector< exception_info_t >::iterator":
def erase(self, *args) -> "qvector< exception_info_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "exception_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "process_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "process_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "process_info_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< process_info_t >::const_iterator":
def end(self, *args) -> "qvector< process_info_t >::const_iterator":
def insert(self, *args) -> "qvector< process_info_t >::iterator":
def erase(self, *args) -> "qvector< process_info_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "process_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "call_stack_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "call_stack_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "call_stack_info_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< call_stack_info_t >::const_iterator":
def end(self, *args) -> "qvector< call_stack_info_t >::const_iterator":
def insert(self, *args) -> "qvector< call_stack_info_t >::iterator":
def erase(self, *args) -> "qvector< call_stack_info_t >::iterator":
def find(self, *args) -> "qvector< call_stack_info_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "call_stack_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "memory_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "memory_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "memory_info_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< memory_info_t >::const_iterator":
def end(self, *args) -> "qvector< memory_info_t >::const_iterator":
def insert(self, *args) -> "qvector< memory_info_t >::iterator":
def erase(self, *args) -> "qvector< memory_info_t >::iterator":
def find(self, *args) -> "qvector< memory_info_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "memory_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def set_debug_event_code(*args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def copy(self, *args) -> "debug_event_t &":
def clear(self, *args) -> "void":
def clear_all(self, *args) -> "void":
def eid(self, *args) -> "event_id_t":
def set_eid(self, *args) -> "void":
def modinfo(self, *args) -> "modinfo_t const &":
def exit_code(self, *args) -> "int const &":
def info(self, *args) -> "qstring const &":
def bpt(self, *args) -> "bptaddr_t const &":
def exc(self, *args) -> "excinfo_t const &":
def set_modinfo(self, *args) -> "modinfo_t &":
def set_exit_code(self, *args) -> "void":
def set_info(self, *args) -> "qstring &":
def set_bpt(self, *args) -> "bptaddr_t &":
def set_exception(self, *args) -> "excinfo_t &":
def bpt_ea(self, *args) -> "ea_t":
def break_on(self, *args) -> "bool":
def handle(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def clear(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def swap(self, *args) -> "void":
def set_int(self, *args) -> "void":
def set_float(self, *args) -> "void":
def set_bytes(self, *args) -> "bytevec_t &":
def set_unavailable(self, *args) -> "void":
def bytes(self, *args) -> "bytevec_t const &":
def get_data(self, *args) -> "void const *":
def get_data_size(self, *args) -> "size_t":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def dbg_appcall(*args) -> "error_t":
def cleanup_appcall(*args) -> "error_t":
def __init__(self, *args):
def dbg_get_registers(*args) -> "PyObject *":
def dbg_get_thread_sreg_base(*args) -> "PyObject *":
def dbg_read_memory(*args) -> "PyObject *":
def dbg_write_memory(*args) -> "PyObject *":
def dbg_get_name(*args) -> "PyObject *":
def dbg_get_memory_info(*args) -> "PyObject *":
def appcall(*args) -> "PyObject *":
def get_event_module_name(*args) -> "size_t":
def get_event_module_base(*args) -> "ea_t":
def get_event_module_size(*args) -> "asize_t":
def get_event_exc_info(*args) -> "size_t":
def get_event_info(*args) -> "size_t":
def get_event_bpt_hea(*args) -> "ea_t":
def get_event_exc_code(*args) -> "uint":
def get_event_exc_ea(*args) -> "ea_t":
def can_exc_continue(*args) -> "bool":
def __init__(self, tp):
def pack(self, L):
def try_to_convert_to_list(self, obj):
def unpack(self, buf, as_list=True):
def __init__(self, ea, tinfo_or_typestr = None, fields = None):
def __get_timeout(self):
def __set_timeout(self, v):
def __get_options(self):
def __set_options(self, v):
def __call__(self, *args):
def __get_ea(self):
def __set_ea(self, val):
def __get_tif(self):
def __get_size(self):
def __get_type(self):
def __get_fields(self):
def retrieve(self, src=None, flags=0):
def store(self, obj, dest_ea=None, base_ea=0, flags=0):
def __init__(self, default=None):
def __getattr__(self, attr):
def __init__(self):
def __get_consts(self):
def __name_or_ea(name_or_ea):
def __typedecl_or_tinfo(typedecl_or_tinfo, flags = None):
def proto(name_or_ea, proto_or_tinfo, flags = None):
def __getattr__(self, name_or_ea):
def __getitem__(self, idx):
def valueof(name, default=0):
def int64(v):
def byref(val):
def buffer(str = None, size = 0, fill="\x00"):
def obj(**kwds):
def cstr(val):
def UTF16(s):
def array(type_name):
def typedobj(typedecl_or_tinfo, ea=None):
def set_appcall_options(opt):
def get_appcall_options():
def cleanup_appcall(tid = 0):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "reg_access_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "reg_access_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "reg_access_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< reg_access_t >::const_iterator":
def end(self, *args) -> "qvector< reg_access_t >::const_iterator":
def insert(self, *args) -> "qvector< reg_access_t >::iterator":
def erase(self, *args) -> "qvector< reg_access_t >::iterator":
def find(self, *args) -> "qvector< reg_access_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "reg_access_t const &":
def __setitem__(self, *args) -> "void":
def AssembleLine(*args) -> "PyObject *":
def has_cf_chg(*args) -> "bool":
def has_cf_use(*args) -> "bool":
def has_insn_feature(*args) -> "bool":
def is_call_insn(*args) -> "bool":
def is_ret_insn(*args) -> "bool":
def is_indirect_jump_insn(*args) -> "bool":
def is_basic_block_end(*args) -> "bool":
a_comdef = property(_ida_idp.asm_t_a_comdef_get, _ida_idp.asm_t_a_comdef_set, doc=r"""a_comdef""")
def __init__(self, *args):
def get_ph(*args) -> "processor_t *":
def get_ash(*args) -> "asm_t *":
def str2reg(*args) -> "int":
def is_align_insn(*args) -> "int":
def get_reg_name(*args) -> "qstring *":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def __init__(self, *args):
def parse_reg_name(*args) -> "bool":
def have_common_bits(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def set_processor_type(*args) -> "bool":
def get_idp_name(*args) -> "size_t":
def set_target_assembler(*args) -> "bool":
def gen_idb_event(*args) -> "void":
def set_module_data(*args) -> "void *":
def clr_module_data(*args) -> "void *":
def get_module_data(*args) -> "void *":
def __init__(self, *args):
def __init__(self, *args):
def register_cfgopts(*args) -> "bool":
def cfg_get_cc_parm(*args) -> "char const *":
def cfg_get_cc_header_path(*args) -> "char const *":
def cfg_get_cc_predefined_macros(*args) -> "char const *":
def process_config_directive(*args) -> "void":
def assemble(*args) -> "bool":
def ph_get_id(*args) -> "size_t":
def ph_get_version(*args) -> "size_t":
def ph_get_flag(*args) -> "size_t":
def ph_get_cnbits(*args) -> "size_t":
def ph_get_dnbits(*args) -> "size_t":
def ph_get_reg_first_sreg(*args) -> "size_t":
def ph_get_reg_last_sreg(*args) -> "size_t":
def ph_get_segreg_size(*args) -> "size_t":
def ph_get_reg_code_sreg(*args) -> "size_t":
def ph_get_reg_data_sreg(*args) -> "size_t":
def ph_get_icode_return(*args) -> "size_t":
def ph_get_instruc_start(*args) -> "size_t":
def ph_get_instruc_end(*args) -> "size_t":
def ph_get_tbyte_size(*args) -> "size_t":
def ph_get_instruc(*args) -> "PyObject *":
def ph_get_regnames(*args) -> "PyObject *":
def ph_get_operand_info(*args) -> "PyObject *":
def ph_calcrel(*args) -> "bytevec_t *, size_t *":
def ph_find_reg_value(*args) -> "uint64 *":
def ph_find_op_value(*args) -> "uint64 *":
def ph_get_reg_accesses(*args) -> "ssize_t":
def __init__(self, *args):
def hook(self, *args) -> "bool":
def unhook(self, *args) -> "bool":
def ev_init(self, *args) -> "int":
def ev_term(self, *args) -> "int":
def ev_newprc(self, *args) -> "int":
def ev_newasm(self, *args) -> "int":
def ev_newfile(self, *args) -> "int":
def ev_oldfile(self, *args) -> "int":
def ev_newbinary(self, *args) -> "int":
def ev_endbinary(self, *args) -> "int":
def ev_set_idp_options(self, *args) -> "int":
def ev_set_proc_options(self, *args) -> "int":
def ev_ana_insn(self, *args) -> "bool":
def ev_emu_insn(self, *args) -> "bool":
def ev_out_header(self, *args) -> "int":
def ev_out_footer(self, *args) -> "int":
def ev_out_segstart(self, *args) -> "int":
def ev_out_segend(self, *args) -> "int":
def ev_out_assumes(self, *args) -> "int":
def ev_out_insn(self, *args) -> "bool":
def ev_out_mnem(self, *args) -> "int":
def ev_out_operand(self, *args) -> "bool":
def ev_out_data(self, *args) -> "int":
def ev_out_label(self, *args) -> "int":
def ev_out_special_item(self, *args) -> "int":
def ev_gen_stkvar_def(self, *args) -> "int":
def ev_gen_regvar_def(self, *args) -> "int":
def ev_gen_src_file_lnnum(self, *args) -> "int":
def ev_creating_segm(self, *args) -> "int":
def ev_moving_segm(self, *args) -> "int":
def ev_coagulate(self, *args) -> "int":
def ev_undefine(self, *args) -> "int":
def ev_treat_hindering_item(self, *args) -> "int":
def ev_rename(self, *args) -> "int":
def ev_is_far_jump(self, *args) -> "int":
def ev_is_sane_insn(self, *args) -> "int":
def ev_is_cond_insn(self, *args) -> "int":
def ev_is_call_insn(self, *args) -> "int":
def ev_is_ret_insn(self, *args) -> "int":
def ev_may_be_func(self, *args) -> "int":
def ev_is_basic_block_end(self, *args) -> "int":
def ev_is_indirect_jump(self, *args) -> "int":
def ev_is_insn_table_jump(self, *args) -> "int":
def ev_is_switch(self, *args) -> "int":
def ev_calc_switch_cases(self, *args) -> "int":
def ev_create_switch_xrefs(self, *args) -> "int":
def ev_is_align_insn(self, *args) -> "int":
def ev_is_alloca_probe(self, *args) -> "int":
def ev_delay_slot_insn(self, *args) -> "PyObject *":
def ev_is_sp_based(self, *args) -> "int":
def ev_can_have_type(self, *args) -> "int":
def ev_cmp_operands(self, *args) -> "int":
def ev_adjust_refinfo(self, *args) -> "int":
def ev_get_operand_string(self, *args) -> "PyObject *":
def ev_get_reg_name(self, *args) -> "PyObject *":
def ev_str2reg(self, *args) -> "int":
def ev_get_autocmt(self, *args) -> "PyObject *":
def ev_get_bg_color(self, *args) -> "int":
def ev_is_jump_func(self, *args) -> "int":
def ev_func_bounds(self, *args) -> "int":
def ev_verify_sp(self, *args) -> "int":
def ev_verify_noreturn(self, *args) -> "int":
def ev_create_func_frame(self, *args) -> "int":
def ev_get_frame_retsize(self, *args) -> "int":
def ev_get_stkvar_scale_factor(self, *args) -> "int":
def ev_demangle_name(self, *args) -> "PyObject *":
def ev_add_cref(self, *args) -> "int":
def ev_add_dref(self, *args) -> "int":
def ev_del_cref(self, *args) -> "int":
def ev_del_dref(self, *args) -> "int":
def ev_coagulate_dref(self, *args) -> "int":
def ev_may_show_sreg(self, *args) -> "int":
def ev_auto_queue_empty(self, *args) -> "int":
def ev_validate_flirt_func(self, *args) -> "int":
def ev_adjust_libfunc_ea(self, *args) -> "int":
def ev_assemble(self, *args) -> "PyObject *":
def ev_extract_address(self, *args) -> "int":
def ev_realcvt(self, *args) -> "int":
def ev_gen_asm_or_lst(self, *args) -> "int":
def ev_gen_map_file(self, *args) -> "int":
def ev_create_flat_group(self, *args) -> "int":
def ev_getreg(self, *args) -> "int":
def ev_analyze_prolog(self, *args) -> "int":
def ev_calc_spdelta(self, *args) -> "int":
def ev_calcrel(self, *args) -> "int":
def ev_find_reg_value(self, *args) -> "PyObject *":
def ev_find_op_value(self, *args) -> "PyObject *":
def ev_replaying_undo(self, *args) -> "int":
def ev_ending_undo(self, *args) -> "int":
def ev_set_code16_mode(self, *args) -> "int":
def ev_get_code16_mode(self, *args) -> "int":
def ev_get_procmod(self, *args) -> "int":
def ev_asm_installed(self, *args) -> "int":
def ev_get_reg_accesses(self, *args) -> "int":
def ev_is_control_flow_guard(self, *args) -> "int":
def ev_create_merge_handlers(self, *args) -> "int":
def ev_privrange_changed(self, *args) -> "int":
def ev_next_exec_insn(self, *args) -> "int":
def ev_calc_step_over(self, *args) -> "int":
def ev_calc_next_eas(self, *args) -> "int":
def ev_get_macro_insn_head(self, *args) -> "int":
def ev_get_dbr_opnum(self, *args) -> "int":
def ev_insn_reads_tbit(self, *args) -> "int":
def ev_clean_tbit(self, *args) -> "int":
def ev_get_reg_info(self, *args) -> "int":
def ev_update_call_stack(self, *args) -> "int":
def ev_setup_til(self, *args) -> "int":
def ev_get_abi_info(self, *args) -> "int":
def ev_max_ptr_size(self, *args) -> "int":
def ev_get_default_enum_size(self, *args) -> "int":
def ev_get_cc_regs(self, *args) -> "int":
def ev_get_simd_types(self, *args) -> "int":
def ev_calc_cdecl_purged_bytes(self, *args) -> "int":
def ev_calc_purged_bytes(self, *args) -> "int":
def ev_calc_retloc(self, *args) -> "int":
def ev_calc_arglocs(self, *args) -> "int":
def ev_calc_varglocs(self, *args) -> "int":
def ev_adjust_argloc(self, *args) -> "int":
def ev_lower_func_type(self, *args) -> "int":
def ev_equal_reglocs(self, *args) -> "int":
def ev_use_stkarg_type(self, *args) -> "int":
def ev_use_regarg_type(self, *args) -> "PyObject *":
def ev_use_arg_types(self, *args) -> "int":
def ev_arg_addrs_ready(self, *args) -> "int":
def ev_decorate_name(self, *args) -> "PyObject *":
def ev_arch_changed(self, *args) -> "int":
def ev_get_stkarg_area_info(self, *args) -> "int":
def ev_last_cb_before_loader(self, *args) -> "int":
def ev_loader(self, *args) -> "int":
def __disown__(self):
def get_idp_notifier_addr(*args) -> "PyObject *":
def get_idp_notifier_ud_addr(*args) -> "PyObject *":
def delay_slot_insn(*args) -> "bool":
def get_reg_info(*args) -> "char const *":
def sizeof_ldbl(*args) -> "size_t":
def __init__(self):
def get_idpdesc(self):
def get_uFlag(self):
def get_auxpref(self, insn):
def _get_idp_notifier_addr(self):
def _get_idp_notifier_ud_addr(self):
def _get_idb_notifier_addr(self):
def _get_idb_notifier_ud_addr(self):
def _make_forced_value_wrapper(self, val, meth=None):
def f(*args):
def _make_int_returning_wrapper(self, meth, intval=0):
def f(*args):
def _get_notify(self, what, unimp_val=0, imp_forced_val=None, add_prefix=True, mandatory_impl=None):
def ev_newprc(self, *args):
def ev_newfile(self, *args):
def ev_oldfile(self, *args):
def ev_newbinary(self, *args):
def ev_endbinary(self, *args):
def ev_set_idp_options(self, keyword, value_type, value, idb_loaded):
def ev_set_proc_options(self, *args):
def ev_ana_insn(self, *args):
def ev_emu_insn(self, *args):
def ev_out_header(self, *args):
def ev_out_footer(self, *args):
def ev_out_segstart(self, ctx, s):
def ev_out_segend(self, ctx, s):
def ev_out_assumes(self, *args):
def ev_out_insn(self, *args):
def ev_out_mnem(self, *args):
def ev_out_operand(self, *args):
def ev_out_data(self, *args):
def ev_out_label(self, *args):
def ev_out_special_item(self, *args):
def ev_gen_regvar_def(self, ctx, v):
def ev_gen_src_file_lnnum(self, *args):
def ev_creating_segm(self, s):
def ev_moving_segm(self, s, to_ea, flags):
def ev_coagulate(self, *args):
def ev_undefine(self, *args):
def ev_treat_hindering_item(self, *args):
def ev_rename(self, *args):
def ev_is_far_jump(self, *args):
def ev_is_sane_insn(self, *args):
def ev_is_call_insn(self, *args):
def ev_is_ret_insn(self, *args):
def ev_may_be_func(self, *args):
def ev_is_basic_block_end(self, *args):
def ev_is_indirect_jump(self, *args):
def ev_is_insn_table_jump(self, *args):
def ev_is_switch(self, *args):
def ev_create_switch_xrefs(self, *args):
def ev_is_align_insn(self, *args):
def ev_is_alloca_probe(self, *args):
def ev_is_sp_based(self, mode, insn, op):
def ev_can_have_type(self, *args):
def ev_cmp_operands(self, *args):
def ev_get_operand_string(self, buf, insn, opnum):
def ev_str2reg(self, *args):
def ev_get_autocmt(self, *args):
def ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea):
def ev_verify_sp(self, pfn):
def ev_verify_noreturn(self, pfn):
def ev_create_func_frame(self, pfn):
def ev_get_frame_retsize(self, frsize, pfn):
def ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea):
def ev_may_show_sreg(self, *args):
def ev_auto_queue_empty(self, *args):
def ev_validate_flirt_func(self, *args):
def ev_assemble(self, *args):
def ev_gen_map_file(self, nlines, fp):
def ev_calc_step_over(self, target, ip):
def closebase(self, *args):
def savebase(self, *args):
def auto_empty(self, *args):
def auto_empty_finally(self, *args):
def determined_main(self, *args):
def idasgn_loaded(self, *args):
def kernel_config_loaded(self, *args):
def compiler_changed(self, *args):
def segm_moved(self, from_ea, to_ea, size, changed_netmap):
def func_added(self, pfn):
def set_func_start(self, *args):
def set_func_end(self, *args):
def deleting_func(self, pfn):
def sgr_changed(self, *args):
def make_code(self, *args):
def make_data(self, *args):
def renamed(self, *args):
def __init__(self, *args):
def hook(self, *args) -> "bool":
def unhook(self, *args) -> "bool":
def closebase(self, *args) -> "void":
def savebase(self, *args) -> "void":
def upgraded(self, *args) -> "void":
def auto_empty(self, *args) -> "void":
def auto_empty_finally(self, *args) -> "void":
def determined_main(self, *args) -> "void":
def local_types_changed(self, *args) -> "void":
def extlang_changed(self, *args) -> "void":
def idasgn_loaded(self, *args) -> "void":
def kernel_config_loaded(self, *args) -> "void":
def loader_finished(self, *args) -> "void":
def flow_chart_created(self, *args) -> "void":
def compiler_changed(self, *args) -> "void":
def changing_ti(self, *args) -> "void":
def ti_changed(self, *args) -> "void":
def changing_op_ti(self, *args) -> "void":
def op_ti_changed(self, *args) -> "void":
def changing_op_type(self, *args) -> "void":
def op_type_changed(self, *args) -> "void":
def enum_created(self, *args) -> "void":
def deleting_enum(self, *args) -> "void":
def enum_deleted(self, *args) -> "void":
def renaming_enum(self, *args) -> "void":
def enum_renamed(self, *args) -> "void":
def changing_enum_bf(self, *args) -> "void":
def enum_bf_changed(self, *args) -> "void":
def changing_enum_cmt(self, *args) -> "void":
def enum_cmt_changed(self, *args) -> "void":
def enum_member_created(self, *args) -> "void":
def deleting_enum_member(self, *args) -> "void":
def enum_member_deleted(self, *args) -> "void":
def struc_created(self, *args) -> "void":
def deleting_struc(self, *args) -> "void":
def struc_deleted(self, *args) -> "void":
def changing_struc_align(self, *args) -> "void":
def struc_align_changed(self, *args) -> "void":
def renaming_struc(self, *args) -> "void":
def struc_renamed(self, *args) -> "void":
def expanding_struc(self, *args) -> "void":
def struc_expanded(self, *args) -> "void":
def struc_member_created(self, *args) -> "void":
def deleting_struc_member(self, *args) -> "void":
def struc_member_deleted(self, *args) -> "void":
def renaming_struc_member(self, *args) -> "void":
def struc_member_renamed(self, *args) -> "void":
def changing_struc_member(self, *args) -> "void":
def struc_member_changed(self, *args) -> "void":
def changing_struc_cmt(self, *args) -> "void":
def struc_cmt_changed(self, *args) -> "void":
def segm_added(self, *args) -> "void":
def deleting_segm(self, *args) -> "void":
def segm_deleted(self, *args) -> "void":
def changing_segm_start(self, *args) -> "void":
def segm_start_changed(self, *args) -> "void":
def changing_segm_end(self, *args) -> "void":
def segm_end_changed(self, *args) -> "void":
def changing_segm_name(self, *args) -> "void":
def segm_name_changed(self, *args) -> "void":
def changing_segm_class(self, *args) -> "void":
def segm_class_changed(self, *args) -> "void":
def segm_attrs_updated(self, *args) -> "void":
def segm_moved(self, *args) -> "void":
def allsegs_moved(self, *args) -> "void":
def func_added(self, *args) -> "void":
def func_updated(self, *args) -> "void":
def set_func_start(self, *args) -> "void":
def set_func_end(self, *args) -> "void":
def deleting_func(self, *args) -> "void":
def frame_deleted(self, *args) -> "void":
def thunk_func_created(self, *args) -> "void":
def func_tail_appended(self, *args) -> "void":
def deleting_func_tail(self, *args) -> "void":
def func_tail_deleted(self, *args) -> "void":
def tail_owner_changed(self, *args) -> "void":
def func_noret_changed(self, *args) -> "void":
def stkpnts_changed(self, *args) -> "void":
def updating_tryblks(self, *args) -> "void":
def tryblks_updated(self, *args) -> "void":
def deleting_tryblks(self, *args) -> "void":
def sgr_changed(self, *args) -> "void":
def make_code(self, *args) -> "void":
def make_data(self, *args) -> "void":
def destroyed_items(self, *args) -> "void":
def renamed(self, *args) -> "void":
def byte_patched(self, *args) -> "void":
def changing_cmt(self, *args) -> "void":
def cmt_changed(self, *args) -> "void":
def changing_range_cmt(self, *args) -> "void":
def range_cmt_changed(self, *args) -> "void":
def extra_cmt_changed(self, *args) -> "void":
def item_color_changed(self, *args) -> "void":
def callee_addr_changed(self, *args) -> "void":
def bookmark_changed(self, *args) -> "void":
def sgr_deleted(self, *args) -> "void":
def adding_segm(self, *args) -> "void":
def func_deleted(self, *args) -> "void":
def dirtree_mkdir(self, *args) -> "void":
def dirtree_rmdir(self, *args) -> "void":
def dirtree_link(self, *args) -> "void":
def dirtree_move(self, *args) -> "void":
def dirtree_rank(self, *args) -> "void":
def dirtree_rminode(self, *args) -> "void":
def dirtree_segm_moved(self, *args) -> "void":
def enum_width_changed(self, *args) -> "void":
def enum_flag_changed(self, *args) -> "void":
def enum_ordinal_changed(self, *args) -> "void":
def __disown__(self):
def get_idb_notifier_addr(*args) -> "PyObject *":
def get_idb_notifier_ud_addr(*args) -> "PyObject *":
def __init__(self, proc):
def __dummy(self, *args):
def __make_parent_caller(self, key):
def call_parent(*args):
def __init__(self, fun):
def __init__(self, dispatcher):
def ev_newfile(self, name):
def ev_oldfile(self, name):
def __init__(self, dispatcher):
def closebase(self):
def __init__(self):
def _find(self, fun):
def dispatch(self, slot, *args):
def notify_when(self, when, fun):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "unsigned short const &":
def __setitem__(self, *args) -> "void":
def _get_bytes(self, *args) -> "bytevec_t":
def _set_bytes(self, *args) -> "void":
def clear(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def from_10bytes(self, *args) -> "fpvalue_error_t":
def to_10bytes(self, *args) -> "fpvalue_error_t":
def from_12bytes(self, *args) -> "fpvalue_error_t":
def to_12bytes(self, *args) -> "fpvalue_error_t":
def to_str(self, *args) -> "void":
def from_sval(self, *args) -> "void":
def from_int64(self, *args) -> "void":
def from_uint64(self, *args) -> "void":
def to_sval(self, *args) -> "fpvalue_error_t":
def to_int64(self, *args) -> "fpvalue_error_t":
def to_uint64(self, *args) -> "fpvalue_error_t":
def fadd(self, *args) -> "fpvalue_error_t":
def fsub(self, *args) -> "fpvalue_error_t":
def fmul(self, *args) -> "fpvalue_error_t":
def fdiv(self, *args) -> "fpvalue_error_t":
def mul_pow2(self, *args) -> "fpvalue_error_t":
def eabs(self, *args) -> "void":
def is_negative(self, *args) -> "bool":
def negate(self, *args) -> "void":
def get_kind(self, *args) -> "fpvalue_kind_t":
def __init__(self, *args):
def _get_bytes(self, *args) -> "void":
def _set_bytes(self, *args) -> "void":
def _get_10bytes(self, *args) -> "void":
def _set_10bytes(self, *args) -> "void":
def _get_float(self, *args) -> "double":
def _set_float(self, *args) -> "void":
def __str__(self, *args) -> "qstring":
def _get_shorts(self, *args) -> "wrapped_array_t< uint16,FPVAL_NWORDS >":
def from_str(self, *args) -> "fpvalue_error_t":
def assign(self, *args) -> "void":
def __iter__(self):
def __getitem__(self, i):
def __setitem__(self, i, v):
def __add__(self, *args) -> "fpvalue_t":
def __sub__(self, *args) -> "fpvalue_t":
def __mul__(self, *args) -> "fpvalue_t":
def __truediv__(self, *args) -> "fpvalue_t":
def ecleaz(*args) -> "void":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def _kludge_force_declare_dirspec_t(*args) -> "void":
def _kludge_force_declare_dirtree_t(*args) -> "void":
def refresh_choosers(*args) -> "void":
def textctrl_info_t_create(*args) -> "PyObject *":
def textctrl_info_t_destroy(*args) -> "bool":
def textctrl_info_t_get_clink(*args) -> "textctrl_info_t *":
def textctrl_info_t_get_clink_ptr(*args) -> "PyObject *":
def register_timer(*args) -> "PyObject *":
def unregister_timer(*args) -> "bool":
def choose_idasgn(*args) -> "PyObject *":
def get_highlight(*args) -> "PyObject *":
def py_load_custom_icon_fn(*args) -> "int":
def py_load_custom_icon_data(*args) -> "int":
def msg(*args) -> "PyObject *":
def ask_text(*args) -> "PyObject *":
def ask_str(*args) -> "PyObject *":
def str2ea(*args) -> "ea_t":
def process_ui_action(*args) -> "bool":
def del_hotkey(*args) -> "bool":
def add_hotkey(*args) -> "PyObject *":
def take_database_snapshot(*args) -> "PyObject *":
def py_ss_restore_callback(*args) -> "void":
def restore_database_snapshot(*args) -> "PyObject *":
def execute_sync(*args) -> "int":
def execute_ui_requests(*args) -> "bool":
def __init__(self, *args, **kwargs):
def get_dict(self, *args) -> "PyObject *":
def __init__(self, *args):
def hook(self, *args) -> "bool":
def unhook(self, *args) -> "bool":
def range(self, *args) -> "void":
def idcstart(self, *args) -> "void":
def idcstop(self, *args) -> "void":
def suspend(self, *args) -> "void":
def resume(self, *args) -> "void":
def saving(self, *args) -> "void":
def saved(self, *args) -> "void":
def database_closed(self, *args) -> "void":
def debugger_menu_change(self, *args) -> "void":
def widget_visible(self, *args) -> "void":
def widget_closing(self, *args) -> "void":
def widget_invisible(self, *args) -> "void":
def get_ea_hint(self, *args) -> "PyObject *":
def get_item_hint(self, *args) -> "PyObject *":
def get_custom_viewer_hint(self, *args) -> "PyObject *":
def database_inited(self, *args) -> "void":
def ready_to_run(self, *args) -> "void":
def preprocess_action(self, *args) -> "int":
def postprocess_action(self, *args) -> "void":
def get_chooser_item_attrs(self, *args) -> "void":
def updating_actions(self, *args) -> "void":
def updated_actions(self, *args) -> "void":
def populating_widget_popup(self, *args) -> "void":
def finish_populating_widget_popup(self, *args) -> "void":
def plugin_loaded(self, *args) -> "void":
def plugin_unloading(self, *args) -> "void":
def current_widget_changed(self, *args) -> "void":
def screen_ea_changed(self, *args) -> "void":
def create_desktop_widget(self, *args) -> "PyObject *":
def get_lines_rendering_info(self, *args) -> "void":
def get_widget_config(self, *args) -> "PyObject *":
def set_widget_config(self, *args) -> "void":
def initing_database(self, *args) -> "void":
def destroying_procmod(self, *args) -> "void":
def destroying_plugmod(self, *args) -> "void":
def desktop_applied(self, *args) -> "void":
def __disown__(self):
def register_action(*args) -> "bool":
def get_registered_actions(*args) -> "PyObject *":
def attach_dynamic_action_to_popup(*args) -> "bool":
def __init__(self, *args):
def py_chooser_base_t_get_row(*args) -> "PyObject *":
def gen_disasm_text(*args) -> "void":
def set_nav_colorizer(*args) -> "PyObject *":
def my_colorizer(ea, nbytes):
def call_nav_colorizer(*args) -> "uint32":
def msg_get_lines(*args) -> "PyObject *":
def TWidget__from_ptrval__(*args) -> "TWidget *":
def add_spaces(*args) -> "PyObject *":
def show_wait_box(*args) -> "void":
def hide_wait_box(*args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "line_rendering_output_entry_t *&":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "line_rendering_output_entry_t *const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "line_rendering_output_entry_t **":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator":
def end(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator":
def insert(self, *args) -> "qvector< line_rendering_output_entry_t * >::iterator":
def erase(self, *args) -> "qvector< line_rendering_output_entry_t * >::iterator":
def find(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "line_rendering_output_entry_t *const &":
def __setitem__(self, *args) -> "void":
def _internal_push_back(self, *args) -> "void":
def push_back(self, e):
def __init__(self, *args):
def push_back(self, *args) -> "twinline_t const *&":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "twinline_t const *const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "twinline_t const **":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< twinline_t const * >::const_iterator":
def end(self, *args) -> "qvector< twinline_t const * >::const_iterator":
def insert(self, *args) -> "qvector< twinline_t const * >::iterator":
def erase(self, *args) -> "qvector< twinline_t const * >::iterator":
def find(self, *args) -> "qvector< twinline_t const * >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "twinline_t const *const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "section_lines_refs_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "section_lines_refs_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "section_lines_refs_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< section_lines_refs_t >::const_iterator":
def end(self, *args) -> "qvector< section_lines_refs_t >::const_iterator":
def insert(self, *args) -> "qvector< section_lines_refs_t >::iterator":
def erase(self, *args) -> "qvector< section_lines_refs_t >::iterator":
def find(self, *args) -> "qvector< section_lines_refs_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "section_lines_refs_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "twinline_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "twinline_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "twinline_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< twinline_t >::const_iterator":
def end(self, *args) -> "qvector< twinline_t >::const_iterator":
def insert(self, *args) -> "qvector< twinline_t >::iterator":
def erase(self, *args) -> "qvector< twinline_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "twinline_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "void":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "sync_source_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "sync_source_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< sync_source_t >::const_iterator":
def end(self, *args) -> "qvector< sync_source_t >::const_iterator":
def insert(self, *args) -> "qvector< sync_source_t >::iterator":
def erase(self, *args) -> "qvector< sync_source_t >::iterator":
def find(self, *args) -> "qvector< sync_source_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "sync_source_t const &":
def __setitem__(self, *args) -> "void":
def get_kernel_version(*args) -> "size_t":
def __init__(self, *args, **kwargs):
def _print(self, *args) -> "void":
def touval(self, *args) -> "uval_t":
def clone(self, *args) -> "place_t *":
def copyfrom(self, *args) -> "void":
def makeplace(self, *args) -> "place_t *":
def compare(self, *args) -> "int":
def adjust(self, *args) -> "void":
def prev(self, *args) -> "bool":
def next(self, *args) -> "bool":
def beginning(self, *args) -> "bool":
def ending(self, *args) -> "bool":
def serialize(self, *args) -> "void":
def id(self, *args) -> "int":
def name(self, *args) -> "char const *":
def toea(self, *args) -> "ea_t":
def rebase(self, *args) -> "bool":
def enter(self, *args) -> "place_t *":
def leave(self, *args) -> "void":
def compare2(self, *args) -> "int":
def deserialize(self, *args) -> "bool":
def as_idaplace_t(*args) -> "idaplace_t *":
def as_enumplace_t(*args) -> "enumplace_t *":
def as_structplace_t(*args) -> "structplace_t *":
def as_simpleline_place_t(*args) -> "simpleline_place_t *":
def generate(self, *args) -> "PyObject *":
def place_t_as_idaplace_t(*args) -> "idaplace_t *":
def place_t_as_enumplace_t(*args) -> "enumplace_t *":
def place_t_as_structplace_t(*args) -> "structplace_t *":
def place_t_as_simpleline_place_t(*args) -> "simpleline_place_t *":
def l_compare2(*args) -> "int":
def __init__(self, *args):
def __init__(self, *args, **kwargs):
def __init__(self, *args, **kwargs):
def __init__(self, *args, **kwargs):
def __init__(self, *args, **kwargs):
def internal_register_place_class(*args) -> "int":
def get_place_class(*args) -> "place_t const *":
def get_place_class_template(*args) -> "place_t const *":
def is_place_class_ea_capable(*args) -> "bool":
def get_place_class_id(*args) -> "int":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def is_register(self, *args) -> "bool":
def is_widget(self, *args) -> "bool":
def get_widget(self, *args) -> "TWidget const *":
def get_register(self, *args) -> "char const *":
def has_widget(self, *args) -> "bool":
def has_register(self, *args) -> "bool":
def has(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def place_as_idaplace_t(self):
def place_as_enumplace_t(self):
def place_as_structplace_t(self):
def place_as_simpleline_place_t(self):
def place(self, view):
def __init__(self, *args):
def __init__(self, *args):
def set_place(self, *args) -> "int":
def get_place(self, *args) -> "place_t *":
def get_bg_color(self, *args) -> "bgcolor_t":
def get_pfx_color(self, *args) -> "bgcolor_t":
def get_dlnnum(self, *args) -> "int":
def get_linecnt(self, *args) -> "int":
def userdata(self, *args) -> "void *":
def set_userdata(self, *args) -> "void":
def beginning(self, *args) -> "bool":
def ending(self, *args) -> "bool":
def down(self, *args) -> "qstring const *":
def up(self, *args) -> "qstring const *":
def __init__(self, *args):
def __init__(self, *args):
def is_bg_color_empty(self, *args) -> "bool":
def is_bg_color_key(self, *args) -> "bool":
def is_bg_color_direct(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def clear(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def swap(self, *args) -> "void":
def request_refresh(*args) -> "void":
def clear_refresh_request(*args) -> "void":
def is_refresh_requested(*args) -> "bool":
def is_chooser_widget(*args) -> "bool":
def __init__(self, *args):
def reset(self, *args) -> "void":
def __init__(self, *args, **kwargs):
def is_same(self, *args) -> "bool":
def can_ins(self, *args) -> "bool":
def can_del(self, *args) -> "bool":
def can_edit(self, *args) -> "bool":
def can_refresh(self, *args) -> "bool":
def popup_allowed(self, *args) -> "bool":
def is_status_bar_hidden(self, *args) -> "bool":
def should_restore_geometry(self, *args) -> "bool":
def is_modal(self, *args) -> "bool":
def is_multi(self, *args) -> "bool":
def ask_item_attrs(self, *args) -> "bool":
def is_noidb(self, *args) -> "bool":
def is_force_default(self, *args) -> "bool":
def get_builtin_number(self, *args) -> "uint":
def is_quick_filter_visible_initially(self, *args) -> "bool":
def get_quick_filter_initial_mode(self, *args) -> "int":
def has_dirtree(self, *args) -> "bool":
def has_diff_capability(self, *args) -> "bool":
def can_sort(self, *args) -> "bool":
def can_filter(self, *args) -> "bool":
def should_rename_trigger_edit(self, *args) -> "bool":
def is_dirtree_persisted(self, *args) -> "bool":
def get_count(self, *args) -> "size_t":
def get_ea(self, *args) -> "ea_t":
def get_row(self, *args) -> "PyObject *":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def _source_as_size(self, *args) -> "size_t":
def _target_as_size(self, *args) -> "size_t":
def get_source_QEvent(self):
def get_target_QWidget(self):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def reset(self, *args) -> "void":
def __init__(self, *args):
def reset(self, *args) -> "void":
def __init__(self, *args):
def reset(self, *args) -> "void":
def has_flag(self, *args) -> "bool":
def is_action_enabled(*args) -> "bool":
def __init__(self, *args):
def cancel_exec_request(*args) -> "bool":
def cancel_thread_exec_requests(*args) -> "int":
def get_synced_group(*args) -> "synced_group_t const *":
def banner(*args) -> "bool":
def is_msg_inited(*args) -> "bool":
def refresh_idaview(*args) -> "void":
def refresh_idaview_anyway(*args) -> "void":
def analyzer_options(*args) -> "void":
def get_screen_ea(*args) -> "ea_t":
def get_opnum(*args) -> "int":
def get_cursor(*args) -> "int *, int *":
def get_output_cursor(*args) -> "int *, int *":
def get_curline(*args) -> "char const *":
def open_url(*args) -> "void":
def get_hexdump_ea(*args) -> "ea_t":
def get_key_code(*args) -> "ushort":
def lookup_key_code(*args) -> "ushort":
def refresh_navband(*args) -> "void":
def refresh_chooser(*args) -> "bool":
def close_chooser(*args) -> "bool":
def set_dock_pos(*args) -> "bool":
def free_custom_icon(*args) -> "void":
def __init__(self, *args):
def unregister_action(*args) -> "bool":
def create_toolbar(*args) -> "bool":
def delete_toolbar(*args) -> "bool":
def create_menu(*args) -> "bool":
def delete_menu(*args) -> "bool":
def attach_action_to_menu(*args) -> "bool":
def detach_action_from_menu(*args) -> "bool":
def attach_action_to_toolbar(*args) -> "bool":
def detach_action_from_toolbar(*args) -> "bool":
def register_and_attach_to_menu(*args) -> "bool":
def display_widget(*args) -> "void":
def close_widget(*args) -> "void":
def activate_widget(*args) -> "void":
def find_widget(*args) -> "TWidget *":
def get_current_widget(*args) -> "TWidget *":
def get_widget_type(*args) -> "twidget_type_t":
def get_widget_title(*args) -> "qstring *":
def custom_viewer_jump(*args) -> "bool":
def ea_viewer_history_push_and_jump(*args) -> "bool":
def get_ea_viewer_history_info(*args) -> "bool":
def refresh_custom_viewer(*args) -> "void":
def repaint_custom_viewer(*args) -> "void":
def jumpto(*args) -> "bool":
def get_custom_viewer_place(*args) -> "int *, int *":
def get_custom_viewer_location(*args) -> "bool":
def is_idaq(*args) -> "bool":
def attach_action_to_popup(*args) -> "bool":
def detach_action_from_popup(*args) -> "bool":
def update_action_label(*args) -> "bool":
def update_action_shortcut(*args) -> "bool":
def update_action_tooltip(*args) -> "bool":
def update_action_icon(*args) -> "bool":
def update_action_state(*args) -> "bool":
def update_action_checkable(*args) -> "bool":
def update_action_checked(*args) -> "bool":
def update_action_visibility(*args) -> "bool":
def get_action_label(*args) -> "qstring *":
def get_action_shortcut(*args) -> "qstring *":
def get_action_tooltip(*args) -> "qstring *":
def get_action_icon(*args) -> "int *":
def get_action_state(*args) -> "action_state_t *":
def get_action_checkable(*args) -> "bool *":
def get_action_checked(*args) -> "bool *":
def get_action_visibility(*args) -> "bool *":
def set_custom_viewer_qt_aware(*args) -> "bool":
def get_custom_viewer_curline(*args) -> "char const *":
def get_custom_viewer_place_xcoord(*args) -> "int":
def get_user_input_event(*args) -> "bool":
def get_output_curline(*args) -> "qstring *":
def get_output_selected_text(*args) -> "qstring *":
def get_current_viewer(*args) -> "TWidget *":
def get_view_renderer_type(*args) -> "tcc_renderer_type_t":
def set_view_renderer_type(*args) -> "void":
def create_empty_widget(*args) -> "TWidget *":
def msg_clear(*args) -> "void":
def msg_save(*args) -> "bool":
def get_active_modal_widget(*args) -> "TWidget *":
def get_navband_pixel(*args) -> "bool *":
def get_navband_ea(*args) -> "ea_t":
def get_window_id(*args) -> "void *":
def is_idaview(*args) -> "bool":
def read_selection(*args) -> "bool":
def read_range_selection(*args) -> "ea_t *, ea_t *":
def unmark_selection(*args) -> "void":
def create_code_viewer(*args) -> "TWidget *":
def set_code_viewer_handler(*args) -> "void *":
def set_code_viewer_user_data(*args) -> "bool":
def get_viewer_user_data(*args) -> "void *":
def get_viewer_place_type(*args) -> "tcc_place_type_t":
def set_code_viewer_line_handlers(*args) -> "void":
def set_code_viewer_lines_icon_margin(*args) -> "bool":
def set_code_viewer_lines_alignment(*args) -> "bool":
def set_code_viewer_lines_radix(*args) -> "bool":
def set_code_viewer_is_source(*args) -> "bool":
def get_tab_size(*args) -> "int":
def clr_cancelled(*args) -> "void":
def set_cancelled(*args) -> "void":
def user_cancelled(*args) -> "bool":
def ui_load_new_file(*args) -> "bool":
def ui_run_debugger(*args) -> "bool":
def load_dbg_dbginfo(*args) -> "bool":
def add_idc_hotkey(*args) -> "int":
def set_highlight(*args) -> "bool":
def open_exports_window(*args) -> "TWidget *":
def open_imports_window(*args) -> "TWidget *":
def open_names_window(*args) -> "TWidget *":
def open_funcs_window(*args) -> "TWidget *":
def open_strings_window(*args) -> "TWidget *":
def open_segments_window(*args) -> "TWidget *":
def open_segregs_window(*args) -> "TWidget *":
def open_selectors_window(*args) -> "TWidget *":
def open_signatures_window(*args) -> "TWidget *":
def open_tils_window(*args) -> "TWidget *":
def open_loctypes_window(*args) -> "TWidget *":
def open_calls_window(*args) -> "TWidget *":
def open_problems_window(*args) -> "TWidget *":
def open_bpts_window(*args) -> "TWidget *":
def open_threads_window(*args) -> "TWidget *":
def open_modules_window(*args) -> "TWidget *":
def open_trace_window(*args) -> "TWidget *":
def open_stack_window(*args) -> "TWidget *":
def open_xrefs_window(*args) -> "TWidget *":
def open_frame_window(*args) -> "TWidget *":
def open_navband_window(*args) -> "TWidget *":
def open_enums_window(*args) -> "TWidget *":
def open_structs_window(*args) -> "TWidget *":
def open_disasm_window(*args) -> "TWidget *":
def open_hexdump_window(*args) -> "TWidget *":
def open_notepad_window(*args) -> "TWidget *":
def open_bookmarks_window(*args) -> "TWidget *":
def sync_sources(*args) -> "bool":
def choose_til(*args) -> "qstring *":
def choose_entry(*args) -> "ea_t":
def choose_name(*args) -> "ea_t":
def choose_stkvar_xref(*args) -> "ea_t":
def choose_xref(*args) -> "ea_t":
def choose_enum(*args) -> "enum_t":
def choose_enum_by_value(*args) -> "uchar *":
def choose_func(*args) -> "func_t *":
def choose_segm(*args) -> "segment_t *":
def choose_struc(*args) -> "struc_t *":
def choose_srcp(*args) -> "sreg_range_t *":
def get_chooser_obj(*args) -> "void *":
def enable_chooser_item_attrs(*args) -> "bool":
def replace_wait_box(*args) -> "void":
def beep(*args) -> "void":
def display_copyright_warning(*args) -> "bool":
def ask_for_feedback(*args) -> "void":
def _ask_addr(*args) -> "ea_t *":
def _ask_seg(*args) -> "sel_t *":
def _ask_long(*args) -> "sval_t *":
def error(*args) -> "void":
def warning(*args) -> "void":
def info(*args) -> "void":
def nomem(*args) -> "void":
def ask_yn(*args) -> "int":
def ask_buttons(*args) -> "int":
def ask_file(*args) -> "char *":
def __init__(self, *args):
def register_addon(*args) -> "int":
def addon_count(*args) -> "int":
def get_addon_info(*args) -> "bool":
def get_addon_info_idx(*args) -> "bool":
def __init__(self, *args):
def qcleanline(*args) -> "qstring *":
def strarray(*args) -> "char const *":
def ea2str(*args) -> "size_t":
def get_user_strlist_options(*args) -> "void":
def del_idc_hotkey(*args) -> "bool":
def __init__(self, *args):
def push_back(self, *args) -> "disasm_line_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "disasm_line_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "disasm_line_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< disasm_line_t >::const_iterator":
def end(self, *args) -> "qvector< disasm_line_t >::const_iterator":
def insert(self, *args) -> "qvector< disasm_line_t >::iterator":
def erase(self, *args) -> "qvector< disasm_line_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "disasm_line_t const &":
def __setitem__(self, *args) -> "void":
def load_custom_icon(file_name=None, data=None, format=None):
def ask_long(defval, format):
def ask_addr(defval, format):
def ask_seg(defval, format):
def ask_ident(defval, format):
def __init__(self):
def activate(self, ctx):
def update(self, ctx):
def __init__(self, caption, flags, menu_index, icon, emb, shortcut):
def __init__(self, parent, cmd_id):
def activate(self, ctx):
def update(self, ctx):
def __init__(self, callback):
def add(self, caption, flags, menu_index, icon, emb, shortcut):
def populate_popup(self, widget, popup):
def __enter__(self):
def __exit__(self, type, value, tb):
def choose_find(*args) -> "PyObject *":
def choose_refresh(*args) -> "void":
def choose_close(*args) -> "void":
def choose_get_widget(*args) -> "TWidget *":
def choose_choose(*args) -> "PyObject *":
def choose_activate(*args) -> "void":
def choose_create_embedded_chobj(*args) -> "PyObject *":
def get_chooser_data(*args) -> "PyObject *":
def __init__(self, v):
def populating_widget_popup(self, widget, popup_handle):
def __init__(self, title, cols, flags = 0, popup_names = None,
def _qccb(ctx, cmd_id):
def Embedded(self, create_chobj=False):
def GetEmbSelection(self):
def Show(self, modal=False):
def Activate(self):
def Refresh(self):
def Close(self):
def GetWidget(self):
def adjust_last_item(self, n):
def AddCommand(self,
def OnPopup(self, widget, popup_handle):
def textctrl_info_t_assign(*args) -> "bool":
def textctrl_info_t_set_text(*args) -> "bool":
def textctrl_info_t_get_text(*args) -> "char const *":
def textctrl_info_t_set_flags(*args) -> "bool":
def textctrl_info_t_get_flags(*args) -> "unsigned int":
def textctrl_info_t_set_tabsize(*args) -> "bool":
def textctrl_info_t_get_tabsize(*args) -> "unsigned int":
def formchgcbfa_enable_field(*args) -> "bool":
def formchgcbfa_show_field(*args) -> "bool":
def formchgcbfa_move_field(*args) -> "bool":
def formchgcbfa_get_focused_field(*args) -> "int":
def formchgcbfa_set_focused_field(*args) -> "bool":
def formchgcbfa_refresh_field(*args) -> "void":
def formchgcbfa_close(*args) -> "void":
def formchgcbfa_get_field_value(*args) -> "PyObject *":
def formchgcbfa_set_field_value(*args) -> "bool":
def py_get_ask_form(*args) -> "size_t":
def py_get_open_form(*args) -> "size_t":
def py_register_compiled_form(*args) -> "void":
def py_unregister_compiled_form(*args) -> "void":
# typedef int (idaapi *buttoncb_t)(int button_code, form_actions_t &fa);
# typedef int (idaapi *formchgcb_t)(int field_id, form_actions_t &fa);
def __init__(self, text="", flags=0, tabsize=0):
def _create_clink(self):
def _del_clink(self, lnk):
def _get_clink_ptr(self):
def assign(self, other):
def __set_text(self, s):
def __get_text(self):
def __set_flags__(self, flags):
def __get_flags__(self):
def __set_tabsize__(self, tabsize):
def __get_tabsize__(self):
Button - def handler(code)
def create_string_buffer(value, size=None):
def fieldtype_to_ctype(tp, i64 = False):
def __init__(self, tp, value):
def __set_value(self, v):
def __init__(self, size=None, value=None):
def __get_value(self):
def __set_value(self, v):
def __init__(self):
def get_tag(self):
def get_arg(self):
def free(self):
def is_input_field(self):
def __init__(self, tp):
def get_tag(self):
def __init__(self, value, tp=None, size=ida_pro.MAXSTR):
def __init__(self, value, tp=None):
def __init__(self, tag, parent):
def assign_pos(self):
def get_tag(self):
def is_input_field(self):
def __init__(self, tag, parent):
def __get_value(self):
def __set_value(self, v):
def __init__(self, tag, parent):
def __get_value(self):
def __set_value(self, v):
def __init__(self, children_names, tag, value=0):
def _reset(self):
def next_child_pos(self):
def get_tag(self):
def __init__(self, children_names, value=0, secondary=False):
def __init__(self, children_names, value=0, secondary=False):
def __init__(self,
def get_tag(self):
def is_input_field(self):
def __init__(self,
def __init__(self, value = 0):
def __init__(self,
def __init__(self,
def __init__(self,
def __init__(self, handler, code="", swidth="", hlp=None):
def helper_cb(self, button_code, p_fa):
def is_input_field(self):
def __init__(self, handler):
def helper_cb(self, fid, p_fa):
def get_tag(self):
def free(self):
def __init__(self,
def __get_selection__(self):
def free(self):
def __init__(self, items=[], readonly=True, selval=0, width=50, swidth=50, hlp = None):
def __set_selval(self, val):
def __get_selval(self):
def free(self):
def set_items(self, items):
def __init__(self, text="", flags=0, tabsize=0, width=50, swidth=50, hlp = None):
def free(self):
def __init__(self, form, controls):
def Free(self):
def _reset(self):
def __getitem__(self, name):
def Add(self, name, ctrl, mkattr = True):
def FindControlById(self, id):
def _ParseFormTitle(form):
def _AddGroup(self, Group, mkattr=True):
def AddControls(self, controls, mkattr=True):
def CompileEx(self, form):
def next_control(form, p, first_pass):
def Compile(self):
def Compiled(self):
def _ChkCompiled(self):
def Execute(self):
def Open(self):
def EnableField(self, ctrl, enable):
def ShowField(self, ctrl, show):
def MoveField(self, ctrl, x, y, w, h):
def GetFocusedField(self):
def SetFocusedField(self, ctrl):
def RefreshField(self, ctrl):
def Close(self, close_normally):
def GetControlValue(self, ctrl):
def SetControlValue(self, ctrl, value):
def ControlToFieldTypeIdAndSize(ctrl):
def __ask_form_callable(*args):
def __open_form_callable(*args):
def __call_form_callable(call, *args):
def ask_form(*args):
def open_form(*args):
def install_command_interpreter(*args) -> "int":
def remove_command_interpreter(*args) -> "void":
def __init__(self):
def __del__(self):
def register(self, flags = 0, sname = None, lname = None, hint = None):
def unregister(self):
def OnExecuteLine(self, line):
def OnKeydown(self, line, x, sellen, vkey, shift):
def OnCompleteLine(self, prefix, n, line, prefix_start):
def __init__(self, *args):
def hook(self, *args) -> "bool":
def unhook(self, *args) -> "bool":
def view_activated(self, *args) -> "void":
def view_deactivated(self, *args) -> "void":
def view_keydown(self, *args) -> "void":
def view_click(self, *args) -> "void":
def view_dblclick(self, *args) -> "void":
def view_curpos(self, *args) -> "void":
def view_created(self, *args) -> "void":
def view_close(self, *args) -> "void":
def view_switched(self, *args) -> "void":
def view_mouse_over(self, *args) -> "void":
def view_loc_changed(self, *args) -> "void":
def view_mouse_moved(self, *args) -> "void":
def __disown__(self):
def __init__(self):
def _graph_item_tuple(self, ve):
def _dummy_cb(*args):
def _get_cb(self, view, cb_name):
def _get_cb_arity(self, cb):
def view_activated(self, view):
def view_deactivated(self, view):
def view_keydown(self, view, key, state):
def view_click(self, view, ve):
def view_dblclick(self, view, ve):
def view_curpos(self, view, *args):
def view_close(self, view, *args):
def view_switched(self, view, rt):
def view_mouse_over(self, view, ve):
def view_loc_changed(self, view, now, was):
def view_mouse_moved(self, view, ve):
def Refresh(self):
def GetCurrentRendererType(self):
def SetCurrentRendererType(self, rtype):
def SetNodeInfo(self, node_index, node_info, flags):
def SetNodesInfos(self, values):
def GetNodeInfo(self, *args):
def DelNodesInfos(self, *nodes):
def CreateGroups(self, groups_infos):
def DeleteGroups(self, groups, new_current = -1):
def SetGroupsVisibility(self, groups, expand, new_current = -1):
def GetWidget(self):
def GetWidgetAsGraphViewer(self):
def pyidag_bind(*args) -> "bool":
def pyidag_unbind(*args) -> "bool":
def __init__(self, title):
def Bind(self):
def Unbind(self):
def pyscv_init(*args) -> "PyObject *":
def pyscv_refresh(*args) -> "bool":
def pyscv_get_current_line(*args) -> "PyObject *":
def pyscv_is_focused(*args) -> "bool":
def pyscv_count(*args) -> "size_t":
def pyscv_show(*args) -> "bool":
def pyscv_close(*args) -> "void":
def pyscv_jumpto(*args) -> "bool":
def pyscv_get_line(*args) -> "PyObject *":
def pyscv_get_pos(*args) -> "PyObject *":
def pyscv_clear_lines(*args) -> "PyObject *":
def pyscv_add_line(*args) -> "bool":
def pyscv_insert_line(*args) -> "bool":
def pyscv_patch_line(*args) -> "bool":
def pyscv_del_line(*args) -> "bool":
def pyscv_get_selection(*args) -> "PyObject *":
def pyscv_get_current_word(*args) -> "PyObject *":
def pyscv_edit_line(*args) -> "bool":
def pyscv_get_widget(*args) -> "TWidget *":
def __init__(self, v):
def populating_widget_popup(self, form, popup_handle):
def __init__(self):
def __make_sl_arg(line, fgcolor=None, bgcolor=None):
def OnPopup(self, form, popup_handle):
def Create(self, title):
def Close(self):
def Show(self):
def Refresh(self):
def RefreshCurrent(self):
def Count(self):
def GetSelection(self):
def ClearLines(self):
def AddLine(self, line, fgcolor=None, bgcolor=None):
def InsertLine(self, lineno, line, fgcolor=None, bgcolor=None):
def EditLine(self, lineno, line, fgcolor=None, bgcolor=None):
def PatchLine(self, lineno, offs, value):
def DelLine(self, lineno):
def GetLine(self, lineno):
def GetCurrentWord(self, mouse = 0):
def GetCurrentLine(self, mouse = 0, notags = 0):
def GetPos(self, mouse = 0):
def GetLineNo(self, mouse = 0):
def Jump(self, lineno, x=0, y=0):
def IsFocused(self):
def GetWidget(self):
#def OnClick(self, shift):
#def OnDblClick(self, shift):
#def OnCursorPosChanged(self):
#def OnClose(self):
#def OnKeydown(self, vkey, shift):
#def OnHint(self, lineno):
#def OnPopupMenu(self, menu_id):
def plgform_new(*args) -> "PyObject *":
def plgform_show(*args) -> "bool":
def plgform_close(*args) -> "void":
def plgform_get_widget(*args) -> "TWidget *":
def __init__(self):
def Show(self, caption, options=0):
def _ensure_widget_deps(ctx):
def TWidgetToPyQtWidget(tw, ctx = sys.modules['__main__']):
def QtWidgetToTWidget(w, ctx = sys.modules['__main__']):
def TWidgetToPySideWidget(tw, ctx = sys.modules['__main__']):
def OnCreate(self, form):
def OnClose(self, form):
def Close(self, options):
def GetWidget(self):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def tag_strlen(*args) -> "ssize_t":
def calc_prefix_color(*args) -> "color_t":
def calc_bg_color(*args) -> "bgcolor_t":
def add_sourcefile(*args) -> "bool":
def get_sourcefile(*args) -> "char const *":
def del_sourcefile(*args) -> "bool":
def install_user_defined_prefix(*args) -> "bool":
def __init__(self, *args):
def get_user_defined_prefix(self, *args) -> "void":
def __disown__(self):
def add_extra_line(*args) -> "bool":
def add_extra_cmt(*args) -> "bool":
def add_pgm_cmt(*args) -> "bool":
def generate_disasm_line(*args) -> "qstring *":
def get_first_free_extra_cmtidx(*args) -> "int":
def update_extra_cmt(*args) -> "void":
def del_extra_cmt(*args) -> "void":
def get_extra_cmt(*args) -> "int":
def delete_extra_cmts(*args) -> "void":
def create_encoding_helper(*args) -> "encoder_t *":
def tag_remove(*args) -> "PyObject *":
def set_user_defined_prefix(*args) -> "PyObject *":
def tag_addr(*args) -> "PyObject *":
def tag_skipcode(*args) -> "int":
def tag_skipcodes(*args) -> "int":
def tag_advance(*args) -> "int":
def generate_disassembly(*args) -> "PyObject *":
def requires_color_esc(c):
def COLSTR(str, tag):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "snapshot_t *&":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "snapshot_t *const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "snapshot_t **":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< snapshot_t * >::const_iterator":
def end(self, *args) -> "qvector< snapshot_t * >::const_iterator":
def insert(self, *args) -> "qvector< snapshot_t * >::iterator":
def erase(self, *args) -> "qvector< snapshot_t * >::iterator":
def find(self, *args) -> "qvector< snapshot_t * >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "snapshot_t *const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def load_binary_file(*args) -> "bool":
def process_archive(*args) -> "qstring *":
def gen_file(*args) -> "int":
def file2base(*args) -> "int":
def base2file(*args) -> "int":
def get_basic_file_type(*args) -> "filetype_t":
def get_file_type_name(*args) -> "size_t":
def set_import_ordinal(*args) -> "void":
def set_import_name(*args) -> "void":
def load_ids_module(*args) -> "int":
def get_plugin_options(*args) -> "char const *":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def find_plugin(*args) -> "plugin_t *":
def get_fileregion_offset(*args) -> "qoff64_t":
def get_fileregion_ea(*args) -> "ea_t":
def gen_exe_file(*args) -> "int":
def reload_file(*args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def clear(self, *args) -> "void":
def __init__(self, *args):
def build_snapshot_tree(*args) -> "bool":
def flush_buffers(*args) -> "int":
def is_trusted_idb(*args) -> "bool":
def save_database(*args) -> "bool":
def is_database_flag(*args) -> "bool":
def set_database_flag(*args) -> "void":
def clr_database_flag(*args) -> "void":
def get_path(*args) -> "char const *":
def set_path(*args) -> "void":
def get_elf_debug_file_directory(*args) -> "char const *":
def mem2base(*args) -> "int":
def load_plugin(*args) -> "PyObject *":
def run_plugin(*args) -> "bool":
def load_and_run_plugin(*args) -> "bool":
def extract_module_from_archive(*args) -> "PyObject *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "segm_move_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "segm_move_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "segm_move_info_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< segm_move_info_t >::const_iterator":
def end(self, *args) -> "qvector< segm_move_info_t >::const_iterator":
def insert(self, *args) -> "qvector< segm_move_info_t >::iterator":
def erase(self, *args) -> "qvector< segm_move_info_t >::iterator":
def find(self, *args) -> "qvector< segm_move_info_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "segm_move_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def find(self, *args) -> "segm_move_info_t const *":
def __init__(self, *args):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
def renderer_info(self, *args) -> "renderer_info_t &":
def place(self, *args) -> "place_t *":
def set_place(self, *args) -> "void":
def is_valid(self, *args) -> "bool":
def acquire_place(self, *args) -> "void":
def __init__(self, *args):
def is_history_enabled(self, *args) -> "bool":
def get_place_id(self, *args) -> "int":
def init(self, *args) -> "bool":
def netcode(self, *args) -> "nodeidx_t":
def jump(self, *args) -> "void":
def current_index(self, *args) -> "uint32":
def seek(self, *args) -> "bool":
def fwd(self, *args) -> "bool":
def back(self, *args) -> "bool":
def save(self, *args) -> "void":
def clear(self, *args) -> "void":
def get_current(self, *args) -> "lochist_entry_t const &":
def set_current(self, *args) -> "void":
def set(self, *args) -> "void":
def get(self, *args) -> "bool":
def size(self, *args) -> "uint32":
def get_template_place(self, *args) -> "place_t const *":
def __init__(self, *args, **kwargs):
def mark(*args) -> "uint32":
def get(*args) -> "bool":
def get_desc(*args) -> "qstring *":
def find_index(*args) -> "uint32":
def size(*args) -> "uint32":
def erase(*args) -> "bool":
def get_dirtree_id(*args) -> "dirtree_id_t":
def bookmarks_t_mark(*args) -> "uint32":
def bookmarks_t_get(*args) -> "bool":
def bookmarks_t_get_desc(*args) -> "qstring *":
def bookmarks_t_find_index(*args) -> "uint32":
def bookmarks_t_size(*args) -> "uint32":
def bookmarks_t_erase(*args) -> "bool":
def bookmarks_t_get_dirtree_id(*args) -> "dirtree_id_t":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "short const &":
def __setitem__(self, *args) -> "void":
def _get_bytes(self, *args) -> "bytevec_t":
def _set_bytes(self, *args) -> "void":
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "unsigned long long const &":
def __setitem__(self, *args) -> "void":
def _get_bytes(self, *args) -> "bytevec_t":
def _set_bytes(self, *args) -> "void":
def ea2node(*args) -> "nodeidx_t":
def node2ea(*args) -> "ea_t":
def getnode(*args) -> "netnode":
def get_strid(*args) -> "tid_t":
def set_aflags(*args) -> "void":
def upd_abits(*args) -> "void":
def set_abits(*args) -> "void":
def clr_abits(*args) -> "void":
def get_aflags(*args) -> "aflags_t":
def del_aflags(*args) -> "void":
def has_aflag_linnum(*args) -> "bool":
def is_aflag_usersp(*args) -> "bool":
def is_aflag_public_name(*args) -> "bool":
def is_aflag_weak_name(*args) -> "bool":
def is_aflag_hidden_item(*args) -> "bool":
def is_aflag_manual_insn(*args) -> "bool":
def is_aflag_hidden_border(*args) -> "bool":
def is_aflag_zstroff(*args) -> "bool":
def is_aflag__bnot0(*args) -> "bool":
def is_aflag__bnot1(*args) -> "bool":
def is_aflag_libitem(*args) -> "bool":
def has_aflag_ti(*args) -> "bool":
def has_aflag_ti0(*args) -> "bool":
def has_aflag_ti1(*args) -> "bool":
def has_aflag_lname(*args) -> "bool":
def is_aflag_tilcmt(*args) -> "bool":
def is_aflag_lzero0(*args) -> "bool":
def is_aflag_lzero1(*args) -> "bool":
def is_aflag_colored_item(*args) -> "bool":
def is_aflag_terse_struc(*args) -> "bool":
def is_aflag__invsign0(*args) -> "bool":
def is_aflag__invsign1(*args) -> "bool":
def is_aflag_noret(*args) -> "bool":
def is_aflag_fixed_spd(*args) -> "bool":
def is_aflag_align_flow(*args) -> "bool":
def is_aflag_userti(*args) -> "bool":
def is_aflag_retfp(*args) -> "bool":
def uses_aflag_modsp(*args) -> "bool":
def is_aflag_notcode(*args) -> "bool":
def is_aflag_notproc(*args) -> "bool":
def is_aflag_type_guessed_by_ida(*args) -> "bool":
def is_aflag_func_guessed_by_hexrays(*args) -> "bool":
def is_aflag_data_guessed_by_hexrays(*args) -> "bool":
def is_aflag_type_determined_by_hexrays(*args) -> "bool":
def is_aflag_type_guessed_by_hexrays(*args) -> "bool":
def is_hidden_item(*args) -> "bool":
def hide_item(*args) -> "void":
def unhide_item(*args) -> "void":
def is_hidden_border(*args) -> "bool":
def hide_border(*args) -> "void":
def unhide_border(*args) -> "void":
def uses_modsp(*args) -> "bool":
def set_usemodsp(*args) -> "void":
def clr_usemodsp(*args) -> "void":
def is_zstroff(*args) -> "bool":
def set_zstroff(*args) -> "void":
def clr_zstroff(*args) -> "void":
def is__bnot0(*args) -> "bool":
def set__bnot0(*args) -> "void":
def clr__bnot0(*args) -> "void":
def is__bnot1(*args) -> "bool":
def set__bnot1(*args) -> "void":
def clr__bnot1(*args) -> "void":
def is_libitem(*args) -> "bool":
def set_libitem(*args) -> "void":
def clr_libitem(*args) -> "void":
def has_ti(*args) -> "bool":
def set_has_ti(*args) -> "void":
def clr_has_ti(*args) -> "void":
def has_ti0(*args) -> "bool":
def set_has_ti0(*args) -> "void":
def clr_has_ti0(*args) -> "void":
def has_ti1(*args) -> "bool":
def set_has_ti1(*args) -> "void":
def clr_has_ti1(*args) -> "void":
def has_lname(*args) -> "bool":
def set_has_lname(*args) -> "void":
def clr_has_lname(*args) -> "void":
def is_tilcmt(*args) -> "bool":
def set_tilcmt(*args) -> "void":
def clr_tilcmt(*args) -> "void":
def is_usersp(*args) -> "bool":
def set_usersp(*args) -> "void":
def clr_usersp(*args) -> "void":
def is_lzero0(*args) -> "bool":
def set_lzero0(*args) -> "void":
def clr_lzero0(*args) -> "void":
def is_lzero1(*args) -> "bool":
def set_lzero1(*args) -> "void":
def clr_lzero1(*args) -> "void":
def is_colored_item(*args) -> "bool":
def set_colored_item(*args) -> "void":
def clr_colored_item(*args) -> "void":
def is_terse_struc(*args) -> "bool":
def set_terse_struc(*args) -> "void":
def clr_terse_struc(*args) -> "void":
def is__invsign0(*args) -> "bool":
def set__invsign0(*args) -> "void":
def clr__invsign0(*args) -> "void":
def is__invsign1(*args) -> "bool":
def set__invsign1(*args) -> "void":
def clr__invsign1(*args) -> "void":
def is_noret(*args) -> "bool":
def set_noret(*args) -> "void":
def clr_noret(*args) -> "void":
def is_fixed_spd(*args) -> "bool":
def set_fixed_spd(*args) -> "void":
def clr_fixed_spd(*args) -> "void":
def is_align_flow(*args) -> "bool":
def set_align_flow(*args) -> "void":
def clr_align_flow(*args) -> "void":
def is_userti(*args) -> "bool":
def set_userti(*args) -> "void":
def clr_userti(*args) -> "void":
def is_retfp(*args) -> "bool":
def set_retfp(*args) -> "void":
def clr_retfp(*args) -> "void":
def is_notproc(*args) -> "bool":
def set_notproc(*args) -> "void":
def clr_notproc(*args) -> "void":
def is_type_guessed_by_ida(*args) -> "bool":
def is_func_guessed_by_hexrays(*args) -> "bool":
def is_data_guessed_by_hexrays(*args) -> "bool":
def is_type_determined_by_hexrays(*args) -> "bool":
def is_type_guessed_by_hexrays(*args) -> "bool":
def set_type_guessed_by_ida(*args) -> "void":
def set_func_guessed_by_hexrays(*args) -> "void":
def set_data_guessed_by_hexrays(*args) -> "void":
def set_type_determined_by_hexrays(*args) -> "void":
def set_notcode(*args) -> "void":
def clr_notcode(*args) -> "void":
def is_notcode(*args) -> "bool":
def set_visible_item(*args) -> "void":
def is_visible_item(*args) -> "bool":
def is_finally_visible_item(*args) -> "bool":
def set_source_linnum(*args) -> "void":
def get_source_linnum(*args) -> "uval_t":
def del_source_linnum(*args) -> "void":
def get_absbase(*args) -> "ea_t":
def set_absbase(*args) -> "void":
def del_absbase(*args) -> "void":
def get_ind_purged(*args) -> "ea_t":
def del_ind_purged(*args) -> "void":
def get_str_type(*args) -> "uint32":
def set_str_type(*args) -> "void":
def del_str_type(*args) -> "void":
def get_str_type_code(*args) -> "uchar":
def get_str_term1(*args) -> "char":
def get_str_term2(*args) -> "char":
def get_str_encoding_idx(*args) -> "uchar":
def set_str_encoding_idx(*args) -> "int32":
def make_str_type(*args) -> "int32":
def is_pascal(*args) -> "bool":
def get_str_type_prefix_length(*args) -> "size_t":
def get_alignment(*args) -> "uint32":
def set_alignment(*args) -> "void":
def del_alignment(*args) -> "void":
def set_item_color(*args) -> "void":
def get_item_color(*args) -> "bgcolor_t":
def del_item_color(*args) -> "bool":
def __init__(self, *args):
def get_array_parameters(*args) -> "ssize_t":
def set_array_parameters(*args) -> "void":
def del_array_parameters(*args) -> "void":
def get_shift(self, *args) -> "int":
def set_shift(self, *args) -> "void":
def get_jtable_element_size(self, *args) -> "int":
def set_jtable_element_size(self, *args) -> "void":
def get_vtable_element_size(self, *args) -> "int":
def set_vtable_element_size(self, *args) -> "void":
def has_default(self, *args) -> "bool":
def has_elbase(self, *args) -> "bool":
def is_sparse(self, *args) -> "bool":
def is_custom(self, *args) -> "bool":
def is_indirect(self, *args) -> "bool":
def is_subtract(self, *args) -> "bool":
def is_nolowcase(self, *args) -> "bool":
def use_std_table(self, *args) -> "bool":
def is_user_defined(self, *args) -> "bool":
def get_lowcase(self, *args) -> "sval_t":
def get_jtable_size(self, *args) -> "int":
def set_jtable_size(self, *args) -> "void":
def set_elbase(self, *args) -> "void":
def set_expr(self, *args) -> "void":
def get_jrange_vrange(self, *args) -> "bool":
def get_version(self, *args) -> "int":
def __init__(self, *args):
def clear(self, *args) -> "void":
def assign(self, *args) -> "void":
def _get_values_lowcase(self, *args) -> "ea_t":
def _set_values_lowcase(self, *args) -> "void":
def get_switch_info(*args) -> "ssize_t":
def set_switch_info(*args) -> "void":
def del_switch_info(*args) -> "void":
def get_switch_parent(*args) -> "ea_t":
def set_switch_parent(*args) -> "void":
def del_switch_parent(*args) -> "void":
def set(self, *args) -> "void":
def get_dtid(self, *args) -> "tid_t":
def __getFids(self, *args) -> "wrapped_array_t< int16,8 >":
def __init__(self, *args):
def get_custom_data_type_ids(*args) -> "int":
def set_custom_data_type_ids(*args) -> "void":
def del_custom_data_type_ids(*args) -> "void":
def is_reftype_target_optional(*args) -> "bool":
def get_reftype_by_size(*args) -> "reftype_t":
def type(self, *args) -> "reftype_t":
def is_target_optional(self, *args) -> "bool":
def no_base_xref(self, *args) -> "bool":
def is_pastend(self, *args) -> "bool":
def is_rvaoff(self, *args) -> "bool":
def is_custom(self, *args) -> "bool":
def is_subtract(self, *args) -> "bool":
def is_signed(self, *args) -> "bool":
def is_no_zeros(self, *args) -> "bool":
def is_no_ones(self, *args) -> "bool":
def set_type(self, *args) -> "void":
def init(self, *args) -> "void":
def __init__(self, *args):
def find_custom_refinfo(*args) -> "int":
def get_custom_refinfo(*args) -> "custom_refinfo_handler_t const *":
def __getIds(self, *args) -> "wrapped_array_t< tid_t,32 >":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def is_ti_initialized(self, *args) -> "bool":
def set_ti_initialized(self, *args) -> "void":
def is_aflags_initialized(self, *args) -> "bool":
def set_aflags_initialized(self, *args) -> "void":
def get_ti(self, *args) -> "opinfo_t const *":
def set_refinfo_ex(*args) -> "bool":
def set_refinfo(*args) -> "bool":
def get_refinfo(*args) -> "bool":
def del_refinfo(*args) -> "bool":
def get_tinfo(*args) -> "bool":
def set_tinfo(*args) -> "bool":
def del_tinfo(*args) -> "void":
def get_op_tinfo(*args) -> "bool":
def set_op_tinfo(*args) -> "bool":
def del_op_tinfo(*args) -> "void":
def get_root_filename(*args) -> "size_t":
def dbg_get_input_path(*args) -> "size_t":
def get_input_file_path(*args) -> "size_t":
def set_root_filename(*args) -> "void":
def retrieve_input_file_size(*args) -> "size_t":
def retrieve_input_file_crc32(*args) -> "uint32":
def retrieve_input_file_md5(*args) -> "uchar [ANY]":
def retrieve_input_file_sha256(*args) -> "uchar [ANY]":
def get_asm_inc_file(*args) -> "qstring *":
def set_asm_inc_file(*args) -> "bool":
def get_imagebase(*args) -> "ea_t":
def set_imagebase(*args) -> "void":
def get_ids_modnode(*args) -> "netnode":
def set_ids_modnode(*args) -> "void":
def get_archive_path(*args) -> "qstring *":
def set_archive_path(*args) -> "bool":
def get_loader_format_name(*args) -> "qstring *":
def set_loader_format_name(*args) -> "void":
def get_initial_ida_version(*args) -> "qstring *":
def get_ida_notepad_text(*args) -> "qstring *":
def set_ida_notepad_text(*args) -> "void":
def get_srcdbg_paths(*args) -> "qstring *":
def set_srcdbg_paths(*args) -> "void":
def get_srcdbg_undesired_paths(*args) -> "qstring *":
def set_srcdbg_undesired_paths(*args) -> "void":
def get_initial_idb_version(*args) -> "ushort":
def get_idb_ctime(*args) -> "time_t":
def get_elapsed_secs(*args) -> "size_t":
def get_idb_nopens(*args) -> "size_t":
def get_encoding_qty(*args) -> "int":
def get_encoding_name(*args) -> "char const *":
def add_encoding(*args) -> "int":
def del_encoding(*args) -> "bool":
def rename_encoding(*args) -> "bool":
def get_encoding_bpu(*args) -> "int":
def get_encoding_bpu_by_name(*args) -> "int":
def get_strtype_bpu(*args) -> "int":
def get_default_encoding_idx(*args) -> "int":
def set_default_encoding_idx(*args) -> "bool":
def encoding_from_strtype(*args) -> "char const *":
def get_outfile_encoding_idx(*args) -> "int":
def set_outfile_encoding_idx(*args) -> "bool":
def get_import_module_qty(*args) -> "uint":
def delete_imports(*args) -> "void":
def validate_idb_names(*args) -> "int":
def set_gotea(*args) -> "void":
def get_gotea(*args) -> "ea_t":
def get_import_module_name(*args) -> "PyObject *":
def enum_import_names(*args) -> "int":
def switch_info_t__from_ptrval__(*args) -> "switch_info_t *":
def get_switch_info(*args):
def get_abi_name():
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "ea_name_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "ea_name_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "ea_name_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< ea_name_t >::const_iterator":
def end(self, *args) -> "qvector< ea_name_t >::const_iterator":
def insert(self, *args) -> "qvector< ea_name_t >::iterator":
def erase(self, *args) -> "qvector< ea_name_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "ea_name_t const &":
def __setitem__(self, *args) -> "void":
def get_name(*args) -> "qstring":
def get_colored_name(*args) -> "qstring":
def set_name(*args) -> "bool":
def force_name(*args) -> "bool":
def del_global_name(*args) -> "bool":
def del_local_name(*args) -> "bool":
def set_dummy_name(*args) -> "bool":
def make_name_auto(*args) -> "bool":
def make_name_user(*args) -> "bool":
def is_valid_cp(*args) -> "bool":
def set_cp_validity(*args) -> "void":
def get_cp_validity(*args) -> "bool":
def is_ident_cp(*args) -> "bool":
def is_strlit_cp(*args) -> "bool":
def is_visible_cp(*args) -> "bool":
def is_ident(*args) -> "bool":
def is_uname(*args) -> "bool":
def is_valid_typename(*args) -> "bool":
def extract_name(*args) -> "qstring *":
def hide_name(*args) -> "void":
def show_name(*args) -> "void":
def get_name_ea(*args) -> "ea_t":
def get_name_base_ea(*args) -> "ea_t":
def get_name_value(*args) -> "uval_t *":
def get_visible_name(*args) -> "qstring":
def get_short_name(*args) -> "qstring":
def get_long_name(*args) -> "qstring":
def get_colored_short_name(*args) -> "qstring":
def get_colored_long_name(*args) -> "qstring":
def get_demangled_name(*args) -> "qstring":
def get_colored_demangled_name(*args) -> "qstring":
def get_name_color(*args) -> "color_t":
def get_name_expr(*args) -> "qstring *":
def get_nice_colored_name(*args) -> "qstring *":
def append_struct_fields(*args) -> "qstring *, adiff_t *":
def is_public_name(*args) -> "bool":
def make_name_public(*args) -> "void":
def make_name_non_public(*args) -> "void":
def is_weak_name(*args) -> "bool":
def make_name_weak(*args) -> "void":
def make_name_non_weak(*args) -> "void":
def get_nlist_size(*args) -> "size_t":
def get_nlist_idx(*args) -> "size_t":
def is_in_nlist(*args) -> "bool":
def get_nlist_ea(*args) -> "ea_t":
def get_nlist_name(*args) -> "char const *":
def rebuild_nlist(*args) -> "void":
def reorder_dummy_names(*args) -> "void":
def __init__(self, *args):
def set_debug_name(*args) -> "bool":
def get_debug_name(*args) -> "qstring *":
def del_debug_names(*args) -> "void":
def get_debug_name_ea(*args) -> "ea_t":
def demangle_name(*args) -> "qstring *":
def is_name_defined_locally(*args) -> "bool":
def cleanup_name(*args) -> "qstring *":
def get_mangled_name_type(*args) -> "mangled_name_type_t":
def get_debug_names(*args) -> "PyObject *":
def get_ea_name(*args) -> "qstring":
def validate_name(*args) -> "PyObject *":
def __init__(self, ea_names):
def update(self, ea_names):
def find(self, ea):
def _get_item(self, index):
def __iter__(self):
def __getitem__(self, index):
def calc_gtn_flags(fromaddr, ea):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def exist(*args) -> "bool":
def create(self, *args) -> "bool":
def kill(self, *args) -> "void":
def get_name(self, *args) -> "ssize_t":
def rename(self, *args) -> "bool":
def valobj(self, *args) -> "ssize_t":
def valstr(self, *args) -> "ssize_t":
def set(self, *args) -> "bool":
def delvalue(self, *args) -> "bool":
def set_long(self, *args) -> "bool":
def value_exists(self, *args) -> "bool":
def long_value(self, *args) -> "nodeidx_t":
def altval(self, *args) -> "nodeidx_t":
def altval_ea(self, *args) -> "nodeidx_t":
def altset(self, *args) -> "bool":
def altset_ea(self, *args) -> "bool":
def altdel_ea(self, *args) -> "bool":
def easet(self, *args) -> "bool":
def eaget(self, *args) -> "ea_t":
def eadel(self, *args) -> "bool":
def easet_idx(self, *args) -> "bool":
def eaget_idx(self, *args) -> "ea_t":
def easet_idx8(self, *args) -> "bool":
def eaget_idx8(self, *args) -> "ea_t":
def eadel_idx8(self, *args) -> "bool":
def altfirst(self, *args) -> "nodeidx_t":
def altnext(self, *args) -> "nodeidx_t":
def altlast(self, *args) -> "nodeidx_t":
def altprev(self, *args) -> "nodeidx_t":
def altshift(self, *args) -> "size_t":
def charval(self, *args) -> "uchar":
def charset(self, *args) -> "bool":
def chardel(self, *args) -> "bool":
def charval_ea(self, *args) -> "uchar":
def charset_ea(self, *args) -> "bool":
def chardel_ea(self, *args) -> "bool":
def charfirst(self, *args) -> "nodeidx_t":
def charnext(self, *args) -> "nodeidx_t":
def charlast(self, *args) -> "nodeidx_t":
def charprev(self, *args) -> "nodeidx_t":
def charshift(self, *args) -> "size_t":
def altval_idx8(self, *args) -> "nodeidx_t":
def altset_idx8(self, *args) -> "bool":
def altdel_idx8(self, *args) -> "bool":
def altfirst_idx8(self, *args) -> "nodeidx_t":
def altnext_idx8(self, *args) -> "nodeidx_t":
def altlast_idx8(self, *args) -> "nodeidx_t":
def altprev_idx8(self, *args) -> "nodeidx_t":
def charval_idx8(self, *args) -> "uchar":
def charset_idx8(self, *args) -> "bool":
def chardel_idx8(self, *args) -> "bool":
def charfirst_idx8(self, *args) -> "nodeidx_t":
def charnext_idx8(self, *args) -> "nodeidx_t":
def charlast_idx8(self, *args) -> "nodeidx_t":
def charprev_idx8(self, *args) -> "nodeidx_t":
def altdel(self, *args) -> "bool":
def altdel_all(self, *args) -> "bool":
def supval(self, *args) -> "ssize_t":
def supval_ea(self, *args) -> "ssize_t":
def supstr(self, *args) -> "ssize_t":
def supstr_ea(self, *args) -> "ssize_t":
def supdel_ea(self, *args) -> "bool":
def lower_bound(self, *args) -> "nodeidx_t":
def lower_bound_ea(self, *args) -> "nodeidx_t":
def supfirst(self, *args) -> "nodeidx_t":
def supnext(self, *args) -> "nodeidx_t":
def suplast(self, *args) -> "nodeidx_t":
def supprev(self, *args) -> "nodeidx_t":
def supshift(self, *args) -> "size_t":
def supval_idx8(self, *args) -> "ssize_t":
def supstr_idx8(self, *args) -> "ssize_t":
def supset_idx8(self, *args) -> "bool":
def supdel_idx8(self, *args) -> "bool":
def lower_bound_idx8(self, *args) -> "nodeidx_t":
def supfirst_idx8(self, *args) -> "nodeidx_t":
def supnext_idx8(self, *args) -> "nodeidx_t":
def suplast_idx8(self, *args) -> "nodeidx_t":
def supprev_idx8(self, *args) -> "nodeidx_t":
def supdel(self, *args) -> "bool":
def supdel_all(self, *args) -> "bool":
def supdel_range(self, *args) -> "int":
def supdel_range_idx8(self, *args) -> "int":
def hashval(self, *args) -> "ssize_t":
def hashstr(self, *args) -> "ssize_t":
def hashval_long(self, *args) -> "nodeidx_t":
def hashset(self, *args) -> "bool":
def hashset_idx(self, *args) -> "bool":
def hashdel(self, *args) -> "bool":
def hashfirst(self, *args) -> "ssize_t":
def hashnext(self, *args) -> "ssize_t":
def hashlast(self, *args) -> "ssize_t":
def hashprev(self, *args) -> "ssize_t":
def hashdel_all(self, *args) -> "bool":
def blobsize(self, *args) -> "size_t":
def blobsize_ea(self, *args) -> "size_t":
def setblob(self, *args) -> "bool":
def setblob_ea(self, *args) -> "bool":
def delblob(self, *args) -> "int":
def delblob_ea(self, *args) -> "int":
def start(self, *args) -> "bool":
def end(self, *args) -> "bool":
def next(self, *args) -> "bool":
def prev(self, *args) -> "bool":
def copyto(self, *args) -> "size_t":
def moveto(self, *args) -> "size_t":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def index(self, *args) -> "nodeidx_t":
def getblob(self, *args) -> "PyObject *":
def getclob(self, *args) -> "PyObject *":
def getblob_ea(self, *args) -> "PyObject *":
def hashstr_buf(self, *args) -> "PyObject *":
def hashset_buf(self, *args) -> "bool":
def supset(self, *args) -> "bool":
def supset_ea(self, *args) -> "bool":
def exist(*args) -> "bool":
def netnode_exist(*args) -> "bool":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def get_default_reftype(*args) -> "reftype_t":
def op_offset_ex(*args) -> "bool":
def op_offset(*args) -> "bool":
def op_plain_offset(*args) -> "bool":
def get_offbase(*args) -> "ea_t":
def get_offset_expression(*args) -> "qstring *":
def get_offset_expr(*args) -> "qstring *":
def can_be_off32(*args) -> "ea_t":
def calc_offset_base(*args) -> "ea_t":
def calc_probable_base_by_value(*args) -> "ea_t":
def calc_reference_data(*args) -> "bool":
def add_refinfo_dref(*args) -> "ea_t":
def calc_target(*args) -> "ea_t":
def calc_basevalue(*args) -> "ea_t":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def qatoll(*args) -> "int64":
def qexit(*args) -> "void":
def set_bits(*args) -> "void":
def clear_bits(*args) -> "void":
def log2ceil(*args) -> "int":
def log2floor(*args) -> "int":
def extend_sign(*args) -> "uint64":
def readbytes(*args) -> "int":
def writebytes(*args) -> "int":
def reloc_value(*args) -> "void":
def qvector_reserve(*args) -> "void *":
def __init__(self, *args, **kwargs):
def release(self, *args) -> "void":
def relocate_relobj(*args) -> "bool":
def is_input(self, *args) -> "bool":
def is_output(self, *args) -> "bool":
def is_append(self, *args) -> "bool":
def is_quoted(self, *args) -> "bool":
def __init__(self, *args):
def quote_cmdline_arg(*args) -> "bool":
def __init__(self, *args):
def parse_dbgopts(*args) -> "bool":
def check_process_exit(*args) -> "int":
def is_control_tty(*args) -> "enum tty_control_t":
def qdetach_tty(*args) -> "void":
def qcontrol_tty(*args) -> "void":
def __init__(self, *args):
def qthread_equal(*args) -> "bool":
def is_main_thread(*args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def __init__(self, *args):
def push_back(self, *args) -> "int &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "int const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "int *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< int >::const_iterator":
def end(self, *args) -> "qvector< int >::const_iterator":
def insert(self, *args) -> "qvector< int >::iterator":
def erase(self, *args) -> "qvector< int >::iterator":
def find(self, *args) -> "qvector< int >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "int const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "unsigned int &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "unsigned int const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "unsigned int *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< unsigned int >::const_iterator":
def end(self, *args) -> "qvector< unsigned int >::const_iterator":
def insert(self, *args) -> "qvector< unsigned int >::iterator":
def erase(self, *args) -> "qvector< unsigned int >::iterator":
def find(self, *args) -> "qvector< unsigned int >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "unsigned int const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "long long &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "long long const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "long long *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< long long >::const_iterator":
def end(self, *args) -> "qvector< long long >::const_iterator":
def insert(self, *args) -> "qvector< long long >::iterator":
def erase(self, *args) -> "qvector< long long >::iterator":
def find(self, *args) -> "qvector< long long >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "long long const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "unsigned long long &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "unsigned long long const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "unsigned long long *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< unsigned long long >::const_iterator":
def end(self, *args) -> "qvector< unsigned long long >::const_iterator":
def insert(self, *args) -> "qvector< unsigned long long >::iterator":
def erase(self, *args) -> "qvector< unsigned long long >::iterator":
def find(self, *args) -> "qvector< unsigned long long >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "unsigned long long const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "bool &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "bool const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "bool *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< bool >::const_iterator":
def end(self, *args) -> "qvector< bool >::const_iterator":
def insert(self, *args) -> "qvector< bool >::iterator":
def erase(self, *args) -> "qvector< bool >::iterator":
def find(self, *args) -> "qvector< bool >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "bool const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "simpleline_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "simpleline_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "simpleline_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< simpleline_t >::const_iterator":
def end(self, *args) -> "qvector< simpleline_t >::const_iterator":
def insert(self, *args) -> "qvector< simpleline_t >::iterator":
def erase(self, *args) -> "qvector< simpleline_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "simpleline_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "size_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "size_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "size_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< size_t >::const_iterator":
def end(self, *args) -> "qvector< size_t >::const_iterator":
def insert(self, *args) -> "qvector< size_t >::iterator":
def erase(self, *args) -> "qvector< size_t >::iterator":
def find(self, *args) -> "qvector< size_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "size_t const &":
def __setitem__(self, *args) -> "void":
def qstrvec_t_create(*args) -> "PyObject *":
def qstrvec_t_destroy(*args) -> "bool":
def qstrvec_t_get_clink(*args) -> "qstrvec_t *":
def qstrvec_t_get_clink_ptr(*args) -> "PyObject *":
def qstrvec_t_assign(*args) -> "bool":
def qstrvec_t_addressof(*args) -> "PyObject *":
def qstrvec_t_set(*args) -> "bool":
def qstrvec_t_from_list(*args) -> "bool":
def qstrvec_t_size(*args) -> "size_t":
def qstrvec_t_get(*args) -> "PyObject *":
def qstrvec_t_add(*args) -> "bool":
def qstrvec_t_clear(*args) -> "bool":
def qstrvec_t_insert(*args) -> "bool":
def qstrvec_t_remove(*args) -> "bool":
def str2user(*args) -> "PyObject *":
def __init__(self, *args):
def __getitem__(self, *args) -> "uchar":
def __setitem__(self, *args) -> "void":
def cast(self, *args) -> "uchar *":
def frompointer(*args) -> "uchar_array *":
def uchar_array_frompointer(*args) -> "uchar_array *":
def __init__(self, *args):
def __getitem__(self, *args) -> "tid_t":
def __setitem__(self, *args) -> "void":
def cast(self, *args) -> "tid_t *":
def frompointer(*args) -> "tid_array *":
def tid_array_frompointer(*args) -> "tid_array *":
def __init__(self, *args):
def __getitem__(self, *args) -> "ea_t":
def __setitem__(self, *args) -> "void":
def cast(self, *args) -> "ea_t *":
def frompointer(*args) -> "ea_array *":
def ea_array_frompointer(*args) -> "ea_array *":
def __init__(self, *args):
def __getitem__(self, *args) -> "sel_t":
def __setitem__(self, *args) -> "void":
def cast(self, *args) -> "sel_t *":
def frompointer(*args) -> "sel_array *":
def sel_array_frompointer(*args) -> "sel_array *":
def __init__(self, *args):
def __getitem__(self, *args) -> "uval_t":
def __setitem__(self, *args) -> "void":
def cast(self, *args) -> "uval_t *":
def frompointer(*args) -> "uval_array *":
def uval_array_frompointer(*args) -> "uval_array *":
def __init__(self, *args):
def assign(self, *args) -> "void":
def value(self, *args) -> "int":
def cast(self, *args) -> "int *":
def frompointer(*args) -> "int_pointer *":
def int_pointer_frompointer(*args) -> "int_pointer *":
def __init__(self, *args):
def assign(self, *args) -> "void":
def value(self, *args) -> "ea_t":
def cast(self, *args) -> "ea_t *":
def frompointer(*args) -> "ea_pointer *":
def ea_pointer_frompointer(*args) -> "ea_pointer *":
def __init__(self, *args):
def assign(self, *args) -> "void":
def value(self, *args) -> "sval_t":
def cast(self, *args) -> "sval_t *":
def frompointer(*args) -> "sval_pointer *":
def sval_pointer_frompointer(*args) -> "sval_pointer *":
def __init__(self, *args):
def assign(self, *args) -> "void":
def value(self, *args) -> "sel_t":
def cast(self, *args) -> "sel_t *":
def frompointer(*args) -> "sel_pointer *":
def sel_pointer_frompointer(*args) -> "sel_pointer *":
def __init__(self, items=None):
def _create_clink(self):
def _del_clink(self, lnk):
def _get_clink_ptr(self):
def assign(self, other):
def __setitem__(self, idx, s):
def __getitem__(self, idx):
def __get_size(self):
def addressof(self, idx):
def add(self, s):
def from_list(self, lst):
def clear(self, qclear=False):
def insert(self, idx, s):
def remove(self, idx):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def get_problem_desc(*args) -> "qstring *":
def remember_problem(*args) -> "void":
def get_problem(*args) -> "ea_t":
def forget_problem(*args) -> "bool":
def get_problem_name(*args) -> "char const *":
def is_problem_present(*args) -> "bool":
def was_ida_decision(*args) -> "bool":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "range_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "range_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "range_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< range_t >::const_iterator":
def end(self, *args) -> "qvector< range_t >::const_iterator":
def insert(self, *args) -> "qvector< range_t >::iterator":
def erase(self, *args) -> "qvector< range_t >::iterator":
def find(self, *args) -> "qvector< range_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "range_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "rangeset_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "rangeset_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "rangeset_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< rangeset_t >::const_iterator":
def end(self, *args) -> "qvector< rangeset_t >::const_iterator":
def insert(self, *args) -> "qvector< rangeset_t >::iterator":
def erase(self, *args) -> "qvector< rangeset_t >::iterator":
def find(self, *args) -> "qvector< rangeset_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "rangeset_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def compare(self, *args) -> "int":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def contains(self, *args) -> "bool":
def overlaps(self, *args) -> "bool":
def clear(self, *args) -> "void":
def empty(self, *args) -> "bool":
def size(self, *args) -> "asize_t":
def intersect(self, *args) -> "void":
def extend(self, *args) -> "void":
def _print(self, *args) -> "size_t":
def range_t_print(*args) -> "size_t":
def __init__(self, *args):
def __init__(self, *args):
def swap(self, *args) -> "void":
def add(self, *args) -> "bool":
def sub(self, *args) -> "bool":
def includes(self, *args) -> "bool":
def _print(self, *args) -> "size_t":
def getrange(self, *args) -> "range_t const &":
def lastrange(self, *args) -> "range_t const &":
def nranges(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def clear(self, *args) -> "void":
def has_common(self, *args) -> "bool":
def contains(self, *args) -> "bool":
def intersect(self, *args) -> "bool":
def is_subset_of(self, *args) -> "bool":
def is_equal(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "rangeset_t::iterator":
def end(self, *args) -> "rangeset_t::iterator":
def find_range(self, *args) -> "range_t const *":
def cached_range(self, *args) -> "range_t const *":
def next_addr(self, *args) -> "ea_t":
def prev_addr(self, *args) -> "ea_t":
def next_range(self, *args) -> "ea_t":
def prev_range(self, *args) -> "ea_t":
def __getitem__(self, idx):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def reg_read_string(*args) -> "PyObject *":
def reg_data_type(*args) -> "regval_type_t":
def reg_read_binary(*args) -> "PyObject *":
def reg_write_binary(*args) -> "PyObject *":
def reg_subkey_subkeys(*args) -> "PyObject *":
def reg_subkey_values(*args) -> "PyObject *":
def reg_delete_subkey(*args) -> "bool":
def reg_delete_tree(*args) -> "bool":
def reg_delete(*args) -> "bool":
def reg_subkey_exists(*args) -> "bool":
def reg_exists(*args) -> "bool":
def reg_read_strlist(*args) -> "qstrvec_t *":
def reg_update_strlist(*args) -> "void":
def reg_write_string(*args) -> "void":
def reg_read_int(*args) -> "int":
def reg_write_int(*args) -> "void":
def reg_read_bool(*args) -> "bool":
def reg_write_bool(*args) -> "void":
def reg_update_filestrlist(*args) -> "void":
def reg_load(*args) -> "void":
def reg_flush(*args) -> "void":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def search_down(*args) -> "bool":
def find_error(*args) -> "int *":
def find_notype(*args) -> "int *":
def find_unknown(*args) -> "ea_t":
def find_defined(*args) -> "ea_t":
def find_suspop(*args) -> "int *":
def find_data(*args) -> "ea_t":
def find_code(*args) -> "ea_t":
def find_not_func(*args) -> "ea_t":
def find_imm(*args) -> "int *":
def find_text(*args) -> "ea_t":
def find_reg_access(*args) -> "ea_t":
def find_binary(*args) -> "ea_t":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def is_16bit(self, *args) -> "bool":
def is_32bit(self, *args) -> "bool":
def is_64bit(self, *args) -> "bool":
def abits(self, *args) -> "int":
def abytes(self, *args) -> "int":
def comorg(self, *args) -> "bool":
def set_comorg(self, *args) -> "void":
def clr_comorg(self, *args) -> "void":
def ob_ok(self, *args) -> "bool":
def set_ob_ok(self, *args) -> "void":
def clr_ob_ok(self, *args) -> "void":
def is_visible_segm(self, *args) -> "bool":
def set_visible_segm(self, *args) -> "void":
def set_debugger_segm(self, *args) -> "void":
def is_loader_segm(self, *args) -> "bool":
def set_loader_segm(self, *args) -> "void":
def is_hidden_segtype(self, *args) -> "bool":
def set_hidden_segtype(self, *args) -> "void":
def is_header_segm(self, *args) -> "bool":
def set_header_segm(self, *args) -> "void":
def update(self, *args) -> "bool":
def __init__(self, *args):
def is_visible_segm(*args) -> "bool":
def is_finally_visible_segm(*args) -> "bool":
def set_visible_segm(*args) -> "void":
def is_spec_segm(*args) -> "bool":
def is_spec_ea(*args) -> "bool":
def lock_segm(*args) -> "void":
def __init__(self, *args):
def is_segm_locked(*args) -> "bool":
def getn_selector(*args) -> "sel_t *, ea_t *":
def get_selector_qty(*args) -> "size_t":
def setup_selector(*args) -> "sel_t":
def allocate_selector(*args) -> "sel_t":
def find_free_selector(*args) -> "sel_t":
def set_selector(*args) -> "int":
def del_selector(*args) -> "void":
def sel2para(*args) -> "ea_t":
def sel2ea(*args) -> "ea_t":
def find_selector(*args) -> "sel_t":
def get_segm_by_sel(*args) -> "segment_t *":
def add_segm_ex(*args) -> "bool":
def add_segm(*args) -> "bool":
def del_segm(*args) -> "bool":
def get_segm_qty(*args) -> "int":
def getseg(*args) -> "segment_t *":
def getnseg(*args) -> "segment_t *":
def get_segm_num(*args) -> "int":
def get_next_seg(*args) -> "segment_t *":
def get_prev_seg(*args) -> "segment_t *":
def get_first_seg(*args) -> "segment_t *":
def get_last_seg(*args) -> "segment_t *":
def get_segm_by_name(*args) -> "segment_t *":
def set_segm_end(*args) -> "bool":
def set_segm_start(*args) -> "bool":
def move_segm_start(*args) -> "bool":
def move_segm(*args) -> "int":
def change_segment_status(*args) -> "int":
def take_memory_snapshot(*args) -> "bool":
def is_miniidb(*args) -> "bool":
def set_segm_base(*args) -> "bool":
def set_group_selector(*args) -> "int":
def get_group_selector(*args) -> "sel_t":
def add_segment_translation(*args) -> "bool":
def set_segment_translations(*args) -> "bool":
def del_segment_translations(*args) -> "void":
def get_segment_translations(*args) -> "ssize_t":
def get_segment_cmt(*args) -> "qstring *":
def set_segment_cmt(*args) -> "void":
def std_out_segm_footer(*args) -> "void":
def set_segm_name(*args) -> "int":
def get_segm_name(*args) -> "qstring *":
def get_visible_segm_name(*args) -> "qstring *":
def get_segm_class(*args) -> "qstring *":
def set_segm_class(*args) -> "int":
def segtype(*args) -> "uchar":
def get_segment_alignment(*args) -> "char const *":
def get_segment_combination(*args) -> "char const *":
def get_segm_para(*args) -> "ea_t":
def get_segm_base(*args) -> "ea_t":
def set_segm_addressing(*args) -> "bool":
def update_segm(*args) -> "bool":
def segm_adjust_diff(*args) -> "adiff_t":
def segm_adjust_ea(*args) -> "ea_t":
def get_defsr(*args) -> "sel_t":
def set_defsr(*args) -> "void":
def rebase_program(*args) -> "int":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def get_sreg(*args) -> "sel_t":
def split_sreg_range(*args) -> "bool":
def set_default_sreg_value(*args) -> "bool":
def set_sreg_at_next_code(*args) -> "void":
def get_sreg_range(*args) -> "bool":
def get_prev_sreg_range(*args) -> "bool":
def set_default_dataseg(*args) -> "void":
def get_sreg_ranges_qty(*args) -> "size_t":
def getn_sreg_range(*args) -> "bool":
def get_sreg_range_num(*args) -> "int":
def del_sreg_range(*args) -> "bool":
def copy_sreg_ranges(*args) -> "void":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def select_parser_by_name(*args) -> "bool":
def select_parser_by_srclang(*args) -> "bool":
def set_parser_argv(*args) -> "int":
def parse_decls_for_srclang(*args) -> "int":
def parse_decls_with_parser(*args) -> "int":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def _get_strtypes(self, *args) -> "PyObject *":
def _set_strtypes(self, *args) -> "PyObject *":
def __init__(self, *args):
def __init__(self, *args):
def __lt__(self, *args) -> "bool":
def get_strlist_options(*args) -> "strwinsetup_t const *":
def build_strlist(*args) -> "void":
def clear_strlist(*args) -> "void":
def get_strlist_qty(*args) -> "size_t":
def get_strlist_item(*args) -> "bool":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "member_t const &":
def __setitem__(self, *args) -> "void":
def unimem(self, *args) -> "bool":
def has_union(self, *args) -> "bool":
def by_til(self, *args) -> "bool":
def has_ti(self, *args) -> "bool":
def is_baseclass(self, *args) -> "bool":
def is_dupname(self, *args) -> "bool":
def is_destructor(self, *args) -> "bool":
def get_soff(self, *args) -> "ea_t":
def get_size(self, *args) -> "asize_t":
def __init__(self, *args):
def __init__(self, *args, **kwargs):
def is_varstr(self, *args) -> "bool":
def is_union(self, *args) -> "bool":
def has_union(self, *args) -> "bool":
def like_union(self, *args) -> "bool":
def is_choosable(self, *args) -> "bool":
def from_til(self, *args) -> "bool":
def is_hidden(self, *args) -> "bool":
def is_frame(self, *args) -> "bool":
def get_alignment(self, *args) -> "int":
def is_ghost(self, *args) -> "bool":
def is_synced(self, *args) -> "bool":
def is_mappedto(self, *args) -> "bool":
def is_copyof(self, *args) -> "bool":
def set_alignment(self, *args) -> "void":
def get_last_member(self, *args) -> "member_t const *":
def set_ghost(self, *args) -> "void":
def unsync(self, *args) -> "void":
def __get_members__(self, *args) -> "dynamic_wrapped_array_t< member_t >":
def get_member(self, index):
def get_struc_qty(*args) -> "size_t":
def get_first_struc_idx(*args) -> "uval_t":
def get_last_struc_idx(*args) -> "uval_t":
def get_prev_struc_idx(*args) -> "uval_t":
def get_next_struc_idx(*args) -> "uval_t":
def get_struc_idx(*args) -> "uval_t":
def get_struc_by_idx(*args) -> "tid_t":
def get_struc(*args) -> "struc_t *":
def get_struc_id(*args) -> "tid_t":
def get_struc_name(*args) -> "qstring *":
def get_struc_cmt(*args) -> "qstring *":
def get_struc_size(*args) -> "asize_t":
def get_struc_prev_offset(*args) -> "ea_t":
def get_struc_next_offset(*args) -> "ea_t":
def get_struc_last_offset(*args) -> "ea_t":
def get_struc_first_offset(*args) -> "ea_t":
def get_max_offset(*args) -> "ea_t":
def is_varstr(*args) -> "bool":
def is_union(*args) -> "bool":
def get_member_struc(*args) -> "struc_t *":
def get_sptr(*args) -> "struc_t *":
def get_member(*args) -> "member_t *":
def get_member_id(*args) -> "tid_t":
def get_member_by_name(*args) -> "member_t *":
def get_member_by_fullname(*args) -> "struc_t **":
def get_member_fullname(*args) -> "qstring *":
def get_member_name(*args) -> "qstring *":
def get_member_cmt(*args) -> "qstring *":
def get_member_size(*args) -> "asize_t":
def is_varmember(*args) -> "bool":
def get_best_fit_member(*args) -> "member_t *":
def get_next_member_idx(*args) -> "ssize_t":
def get_prev_member_idx(*args) -> "ssize_t":
def add_struc(*args) -> "tid_t":
def del_struc(*args) -> "bool":
def set_struc_idx(*args) -> "bool":
def set_struc_align(*args) -> "bool":
def set_struc_name(*args) -> "bool":
def set_struc_cmt(*args) -> "bool":
def add_struc_member(*args) -> "struc_error_t":
def del_struc_member(*args) -> "bool":
def del_struc_members(*args) -> "int":
def set_member_name(*args) -> "bool":
def set_member_type(*args) -> "bool":
def set_member_cmt(*args) -> "bool":
def expand_struc(*args) -> "bool":
def save_struc(*args) -> "void":
def set_struc_hidden(*args) -> "void":
def set_struc_listed(*args) -> "void":
def get_member_tinfo(*args) -> "bool":
def del_member_tinfo(*args) -> "bool":
def set_member_tinfo(*args) -> "smt_code_t":
def get_or_guess_member_tinfo(*args) -> "bool":
def retrieve_member_info(*args) -> "opinfo_t *":
def is_anonymous_member_name(*args) -> "bool":
def is_dummy_member_name(*args) -> "bool":
def get_member_by_id(*args) -> "qstring *, struc_t **":
def is_member_id(*args) -> "bool":
def is_special_member(*args) -> "bool":
def visit_field(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def visit_stroff_fields(*args) -> "adiff_t *":
def stroff_as_size(*args) -> "bool":
def get_innermost_member(*args) -> "PyObject *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "tryblk_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "tryblk_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "tryblk_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< tryblk_t >::const_iterator":
def end(self, *args) -> "qvector< tryblk_t >::const_iterator":
def insert(self, *args) -> "qvector< tryblk_t >::iterator":
def erase(self, *args) -> "qvector< tryblk_t >::iterator":
def find(self, *args) -> "qvector< tryblk_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "tryblk_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "catch_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "catch_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "catch_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< catch_t >::const_iterator":
def end(self, *args) -> "qvector< catch_t >::const_iterator":
def insert(self, *args) -> "qvector< catch_t >::iterator":
def erase(self, *args) -> "qvector< catch_t >::iterator":
def find(self, *args) -> "qvector< catch_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "catch_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def clear(self, *args) -> "void":
def clear(self, *args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def cpp(self, *args) -> "catchvec_t &":
def seh(self, *args) -> "seh_t &":
def __init__(self, *args):
def get_kind(self, *args) -> "uchar":
def empty(self, *args) -> "bool":
def is_seh(self, *args) -> "bool":
def is_cpp(self, *args) -> "bool":
def clear(self, *args) -> "void":
def set_seh(self, *args) -> "seh_t &":
def set_cpp(self, *args) -> "catchvec_t &":
def get_tryblks(*args) -> "size_t":
def del_tryblks(*args) -> "void":
def add_tryblk(*args) -> "int":
def find_syseh(*args) -> "ea_t":
def is_ea_tryblks(*args) -> "bool":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def push_back(self, *args) -> "funcarg_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "funcarg_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "funcarg_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< funcarg_t >::const_iterator":
def end(self, *args) -> "qvector< funcarg_t >::const_iterator":
def insert(self, *args) -> "qvector< funcarg_t >::iterator":
def erase(self, *args) -> "qvector< funcarg_t >::iterator":
def find(self, *args) -> "qvector< funcarg_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "funcarg_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "reg_info_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "reg_info_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "reg_info_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< reg_info_t >::const_iterator":
def end(self, *args) -> "qvector< reg_info_t >::const_iterator":
def insert(self, *args) -> "qvector< reg_info_t >::iterator":
def erase(self, *args) -> "qvector< reg_info_t >::iterator":
def find(self, *args) -> "qvector< reg_info_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "reg_info_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "enum_member_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "enum_member_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "enum_member_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< enum_member_t >::const_iterator":
def end(self, *args) -> "qvector< enum_member_t >::const_iterator":
def insert(self, *args) -> "qvector< enum_member_t >::iterator":
def erase(self, *args) -> "qvector< enum_member_t >::iterator":
def find(self, *args) -> "qvector< enum_member_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "enum_member_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "argpart_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "argpart_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "argpart_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< argpart_t >::const_iterator":
def end(self, *args) -> "qvector< argpart_t >::const_iterator":
def insert(self, *args) -> "qvector< argpart_t >::iterator":
def erase(self, *args) -> "qvector< argpart_t >::iterator":
def find(self, *args) -> "qvector< argpart_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "argpart_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "valstr_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "valstr_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "valstr_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< valstr_t >::const_iterator":
def end(self, *args) -> "qvector< valstr_t >::const_iterator":
def insert(self, *args) -> "qvector< valstr_t >::iterator":
def erase(self, *args) -> "qvector< valstr_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "valstr_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "regobj_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "regobj_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "regobj_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< regobj_t >::const_iterator":
def end(self, *args) -> "qvector< regobj_t >::const_iterator":
def insert(self, *args) -> "qvector< regobj_t >::iterator":
def erase(self, *args) -> "qvector< regobj_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "regobj_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "type_attr_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "type_attr_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "type_attr_t *":
def inject(self, *args) -> "void":
def begin(self, *args) -> "qvector< type_attr_t >::const_iterator":
def end(self, *args) -> "qvector< type_attr_t >::const_iterator":
def insert(self, *args) -> "qvector< type_attr_t >::iterator":
def erase(self, *args) -> "qvector< type_attr_t >::iterator":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "type_attr_t const &":
def __setitem__(self, *args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "udt_member_t &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "udt_member_t const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "udt_member_t *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< udt_member_t >::const_iterator":
def end(self, *args) -> "qvector< udt_member_t >::const_iterator":
def insert(self, *args) -> "qvector< udt_member_t >::iterator":
def erase(self, *args) -> "qvector< udt_member_t >::iterator":
def find(self, *args) -> "qvector< udt_member_t >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "udt_member_t const &":
def __setitem__(self, *args) -> "void":
def is_type_const(*args) -> "bool":
def is_type_volatile(*args) -> "bool":
def get_base_type(*args) -> "type_t":
def get_type_flags(*args) -> "type_t":
def get_full_type(*args) -> "type_t":
def is_typeid_last(*args) -> "bool":
def is_type_partial(*args) -> "bool":
def is_type_void(*args) -> "bool":
def is_type_unknown(*args) -> "bool":
def is_type_ptr(*args) -> "bool":
def is_type_complex(*args) -> "bool":
def is_type_func(*args) -> "bool":
def is_type_array(*args) -> "bool":
def is_type_typedef(*args) -> "bool":
def is_type_sue(*args) -> "bool":
def is_type_struct(*args) -> "bool":
def is_type_union(*args) -> "bool":
def is_type_struni(*args) -> "bool":
def is_type_enum(*args) -> "bool":
def is_type_bitfld(*args) -> "bool":
def is_type_int(*args) -> "bool":
def is_type_int128(*args) -> "bool":
def is_type_int64(*args) -> "bool":
def is_type_int32(*args) -> "bool":
def is_type_int16(*args) -> "bool":
def is_type_char(*args) -> "bool":
def is_type_paf(*args) -> "bool":
def is_type_ptr_or_array(*args) -> "bool":
def is_type_floating(*args) -> "bool":
def is_type_integral(*args) -> "bool":
def is_type_ext_integral(*args) -> "bool":
def is_type_arithmetic(*args) -> "bool":
def is_type_ext_arithmetic(*args) -> "bool":
def is_type_uint(*args) -> "bool":
def is_type_uchar(*args) -> "bool":
def is_type_uint16(*args) -> "bool":
def is_type_uint32(*args) -> "bool":
def is_type_uint64(*args) -> "bool":
def is_type_uint128(*args) -> "bool":
def is_type_ldouble(*args) -> "bool":
def is_type_double(*args) -> "bool":
def is_type_float(*args) -> "bool":
def is_type_tbyte(*args) -> "bool":
def is_type_bool(*args) -> "bool":
def is_tah_byte(*args) -> "bool":
def is_sdacl_byte(*args) -> "bool":
def __lt__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def __init__(self, *args):
def append_argloc(*args) -> "bool":
def extract_argloc(*args) -> "bool":
def resolve_typedef(*args) -> "type_t const *":
def is_restype_void(*args) -> "bool":
def is_restype_enum(*args) -> "bool":
def is_restype_struni(*args) -> "bool":
def is_restype_struct(*args) -> "bool":
def get_scalar_bt(*args) -> "type_t":
def is_dirty(self, *args) -> "bool":
def set_dirty(self, *args) -> "void":
def base(self, *args) -> "til_t *":
def __init__(self, *args):
def new_til(*args) -> "til_t *":
def load_til(*args) -> "qstring *":
def compact_til(*args) -> "bool":
def store_til(*args) -> "bool":
def free_til(*args) -> "void":
def load_til_header(*args) -> "qstring *":
def is_code_far(*args) -> "bool":
def is_data_far(*args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def swap(self, *args) -> "void":
def atype(self, *args) -> "argloc_type_t":
def is_reg1(self, *args) -> "bool":
def is_reg2(self, *args) -> "bool":
def is_reg(self, *args) -> "bool":
def is_rrel(self, *args) -> "bool":
def is_ea(self, *args) -> "bool":
def is_stkoff(self, *args) -> "bool":
def is_scattered(self, *args) -> "bool":
def has_reg(self, *args) -> "bool":
def has_stkoff(self, *args) -> "bool":
def is_mixed_scattered(self, *args) -> "bool":
def in_stack(self, *args) -> "bool":
def is_fragmented(self, *args) -> "bool":
def is_custom(self, *args) -> "bool":
def is_badloc(self, *args) -> "bool":
def reg1(self, *args) -> "int":
def regoff(self, *args) -> "int":
def reg2(self, *args) -> "int":
def get_reginfo(self, *args) -> "uint32":
def stkoff(self, *args) -> "sval_t":
def get_ea(self, *args) -> "ea_t":
def scattered(self, *args) -> "scattered_aloc_t const &":
def get_rrel(self, *args) -> "rrel_t const &":
def get_custom(self, *args) -> "void *":
def get_biggest(self, *args) -> "argloc_t::biggest_t":
def _set_badloc(self, *args) -> "void":
def _set_reg1(self, *args) -> "void":
def _set_reg2(self, *args) -> "void":
def _set_stkoff(self, *args) -> "void":
def _set_ea(self, *args) -> "void":
def _consume_rrel(self, *args) -> "bool":
def _consume_scattered(self, *args) -> "bool":
def _set_custom(self, *args) -> "void":
def _set_biggest(self, *args) -> "void":
def set_reg1(self, *args) -> "void":
def set_reg2(self, *args) -> "void":
def set_stkoff(self, *args) -> "void":
def set_ea(self, *args) -> "void":
def consume_rrel(self, *args) -> "void":
def set_badloc(self, *args) -> "void":
def calc_offset(self, *args) -> "sval_t":
def advance(self, *args) -> "bool":
def align_reg_high(self, *args) -> "void":
def align_stkoff_high(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def consume_scattered(self, *args) -> "void":
def __init__(self, *args):
def bad_offset(self, *args) -> "bool":
def bad_size(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def swap(self, *args) -> "void":
def __init__(self, *args):
def verify_argloc(*args) -> "int":
def optimize_argloc(*args) -> "bool":
def print_argloc(*args) -> "size_t":
def visit_location(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def for_all_arglocs(*args) -> "int":
def visit_location(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def for_all_const_arglocs(*args) -> "int":
def is_user_cc(*args) -> "bool":
def is_vararg_cc(*args) -> "bool":
def is_purging_cc(*args) -> "bool":
def is_golang_cc(*args) -> "bool":
def __init__(self, *args):
def init_regs(self, *args) -> "void":
def by_slots(self, *args) -> "bool":
def set(self, *args) -> "void":
def reset(self, *args) -> "void":
def regcount(*args) -> "int":
def reginds(self, *args) -> "bool":
def callregs_t_regcount(*args) -> "int":
def get_comp(*args) -> "comp_t":
def get_compiler_name(*args) -> "char const *":
def get_compiler_abbr(*args) -> "char const *":
def get_compilers(*args) -> "void":
def is_comp_unsure(*args) -> "comp_t":
def default_compiler(*args) -> "comp_t":
def is_gcc(*args) -> "bool":
def is_gcc32(*args) -> "bool":
def is_gcc64(*args) -> "bool":
def gcc_layout(*args) -> "bool":
def set_compiler(*args) -> "bool":
def set_compiler_id(*args) -> "bool":
def set_abi_name(*args) -> "bool":
def get_abi_name(*args) -> "qstring *":
def append_abi_opts(*args) -> "bool":
def remove_abi_opts(*args) -> "bool":
def set_compiler_string(*args) -> "bool":
def use_golang_cc(*args) -> "bool":
def switch_to_golang(*args) -> "void":
def parse_decl(*args) -> "qstring *":
def convert_pt_flags_to_hti(*args) -> "int":
def parse_decls(*args) -> "int":
def print_type(*args) -> "qstring *":
def del_named_type(*args) -> "bool":
def first_named_type(*args) -> "char const *":
def next_named_type(*args) -> "char const *":
def copy_named_type(*args) -> "uint32":
def gen_decorate_name(*args) -> "qstring *":
def calc_c_cpp_name(*args) -> "qstring *":
def alloc_type_ordinals(*args) -> "uint32":
def alloc_type_ordinal(*args) -> "uint32":
def get_ordinal_qty(*args) -> "uint32":
def set_numbered_type(*args) -> "tinfo_code_t":
def del_numbered_type(*args) -> "bool":
def set_type_alias(*args) -> "bool":
def get_alias_target(*args) -> "uint32":
def get_type_ordinal(*args) -> "int32":
def get_numbered_type_name(*args) -> "char const *":
def create_numbered_type_name(*args) -> "qstring *":
def is_ordinal_name(*args) -> "bool":
def get_ordinal_from_idb_type(*args) -> "int":
def is_autosync(*args) -> "bool":
def get_vftable_ea(*args) -> "ea_t":
def get_vftable_ordinal(*args) -> "uint32":
def set_vftable_ea(*args) -> "bool":
def del_vftable_ea(*args) -> "bool":
def deref_ptr(*args) -> "bool":
def import_type(*args) -> "tid_t":
def add_til(*args) -> "int":
def del_til(*args) -> "bool":
def apply_named_type(*args) -> "bool":
def apply_tinfo(*args) -> "bool":
def apply_cdecl(*args) -> "bool":
def apply_callee_tinfo(*args) -> "bool":
def apply_once_tinfo_and_name(*args) -> "bool":
def guess_tinfo(*args) -> "int":
def set_c_header_path(*args) -> "void":
def get_c_header_path(*args) -> "qstring *":
def set_c_macros(*args) -> "void":
def get_c_macros(*args) -> "qstring *":
def get_idati(*args) -> "til_t const *":
def get_idainfo_by_type(*args) -> "size_t *, flags_t *, opinfo_t *, size_t *":
def copy_tinfo_t(*args) -> "void":
def clear_tinfo_t(*args) -> "void":
def create_tinfo(*args) -> "bool":
def verify_tinfo(*args) -> "int":
def get_tinfo_details(*args) -> "bool":
def get_tinfo_size(*args) -> "size_t":
def get_tinfo_pdata(*args) -> "size_t":
def get_tinfo_property(*args) -> "size_t":
def set_tinfo_property(*args) -> "size_t":
def serialize_tinfo(*args) -> "bool":
def deserialize_tinfo(*args) -> "bool":
def find_tinfo_udt_member(*args) -> "int":
def print_tinfo(*args) -> "qstring *":
def dstr_tinfo(*args) -> "char const *":
def visit_subtypes(*args) -> "int":
def compare_tinfo(*args) -> "bool":
def lexcompare_tinfo(*args) -> "int":
def get_stock_tinfo(*args) -> "bool":
def read_tinfo_bitfield_value(*args) -> "uint64":
def write_tinfo_bitfield_value(*args) -> "uint64":
def get_tinfo_attr(*args) -> "bool":
def set_tinfo_attr(*args) -> "bool":
def del_tinfo_attr(*args) -> "bool":
def get_tinfo_attrs(*args) -> "bool":
def set_tinfo_attrs(*args) -> "bool":
def score_tinfo(*args) -> "uint32":
def save_tinfo(*args) -> "tinfo_code_t":
def append_tinfo_covered(*args) -> "bool":
def calc_tinfo_gaps(*args) -> "bool":
def __init__(self, *args):
def clear(self, *args) -> "void":
def swap(self, *args) -> "void":
def get_named_type(self, *args) -> "bool":
def get_numbered_type(self, *args) -> "bool":
def is_correct(self, *args) -> "bool":
def get_realtype(self, *args) -> "type_t":
def get_decltype(self, *args) -> "type_t":
def empty(self, *args) -> "bool":
def present(self, *args) -> "bool":
def get_size(self, *args) -> "size_t":
def get_unpadded_size(self, *args) -> "size_t":
def get_sign(self, *args) -> "type_sign_t":
def is_signed(self, *args) -> "bool":
def is_unsigned(self, *args) -> "bool":
def get_declalign(self, *args) -> "uchar":
def set_declalign(self, *args) -> "bool":
def is_typeref(self, *args) -> "bool":
def has_details(self, *args) -> "bool":
def get_type_name(self, *args) -> "bool":
def get_final_type_name(self, *args) -> "bool":
Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
def get_next_type_name(self, *args) -> "bool":
Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
def get_ordinal(self, *args) -> "uint32":
def get_final_ordinal(self, *args) -> "uint32":
def get_til(self, *args) -> "til_t const *":
def is_from_subtil(self, *args) -> "bool":
def is_forward_decl(self, *args) -> "bool":
def is_decl_const(self, *args) -> "bool":
def is_decl_volatile(self, *args) -> "bool":
def is_decl_void(self, *args) -> "bool":
def is_decl_partial(self, *args) -> "bool":
def is_decl_unknown(self, *args) -> "bool":
def is_decl_last(self, *args) -> "bool":
def is_decl_ptr(self, *args) -> "bool":
def is_decl_array(self, *args) -> "bool":
def is_decl_func(self, *args) -> "bool":
def is_decl_complex(self, *args) -> "bool":
def is_decl_typedef(self, *args) -> "bool":
def is_decl_sue(self, *args) -> "bool":
def is_decl_struct(self, *args) -> "bool":
def is_decl_union(self, *args) -> "bool":
def is_decl_udt(self, *args) -> "bool":
def is_decl_enum(self, *args) -> "bool":
def is_decl_bitfield(self, *args) -> "bool":
def is_decl_int128(self, *args) -> "bool":
def is_decl_int64(self, *args) -> "bool":
def is_decl_int32(self, *args) -> "bool":
def is_decl_int16(self, *args) -> "bool":
def is_decl_int(self, *args) -> "bool":
def is_decl_char(self, *args) -> "bool":
def is_decl_uint(self, *args) -> "bool":
def is_decl_uchar(self, *args) -> "bool":
def is_decl_uint16(self, *args) -> "bool":
def is_decl_uint32(self, *args) -> "bool":
def is_decl_uint64(self, *args) -> "bool":
def is_decl_uint128(self, *args) -> "bool":
def is_decl_ldouble(self, *args) -> "bool":
def is_decl_double(self, *args) -> "bool":
def is_decl_float(self, *args) -> "bool":
def is_decl_tbyte(self, *args) -> "bool":
def is_decl_floating(self, *args) -> "bool":
def is_decl_bool(self, *args) -> "bool":
def is_decl_paf(self, *args) -> "bool":
def is_well_defined(self, *args) -> "bool":
def is_const(self, *args) -> "bool":
def is_volatile(self, *args) -> "bool":
def is_void(self, *args) -> "bool":
def is_partial(self, *args) -> "bool":
def is_unknown(self, *args) -> "bool":
def is_ptr(self, *args) -> "bool":
def is_array(self, *args) -> "bool":
def is_func(self, *args) -> "bool":
def is_complex(self, *args) -> "bool":
def is_struct(self, *args) -> "bool":
def is_union(self, *args) -> "bool":
def is_udt(self, *args) -> "bool":
def is_enum(self, *args) -> "bool":
def is_sue(self, *args) -> "bool":
def is_bitfield(self, *args) -> "bool":
def is_int128(self, *args) -> "bool":
def is_int64(self, *args) -> "bool":
def is_int32(self, *args) -> "bool":
def is_int16(self, *args) -> "bool":
def is_int(self, *args) -> "bool":
def is_char(self, *args) -> "bool":
def is_uint(self, *args) -> "bool":
def is_uchar(self, *args) -> "bool":
def is_uint16(self, *args) -> "bool":
def is_uint32(self, *args) -> "bool":
def is_uint64(self, *args) -> "bool":
def is_uint128(self, *args) -> "bool":
def is_ldouble(self, *args) -> "bool":
def is_double(self, *args) -> "bool":
def is_float(self, *args) -> "bool":
def is_tbyte(self, *args) -> "bool":
def is_bool(self, *args) -> "bool":
def is_paf(self, *args) -> "bool":
def is_ptr_or_array(self, *args) -> "bool":
def is_integral(self, *args) -> "bool":
def is_ext_integral(self, *args) -> "bool":
def is_floating(self, *args) -> "bool":
def is_arithmetic(self, *args) -> "bool":
def is_ext_arithmetic(self, *args) -> "bool":
def is_scalar(self, *args) -> "bool":
def get_ptr_details(self, *args) -> "bool":
def get_array_details(self, *args) -> "bool":
def get_enum_details(self, *args) -> "bool":
def get_bitfield_details(self, *args) -> "bool":
def get_udt_details(self, *args) -> "bool":
def get_func_details(self, *args) -> "bool":
def is_funcptr(self, *args) -> "bool":
def is_shifted_ptr(self, *args) -> "bool":
def is_varstruct(self, *args) -> "bool":
def get_ptrarr_objsize(self, *args) -> "int":
def get_ptrarr_object(self, *args) -> "tinfo_t":
def get_pointed_object(self, *args) -> "tinfo_t":
def is_pvoid(self, *args) -> "bool":
def get_array_element(self, *args) -> "tinfo_t":
def get_array_nelems(self, *args) -> "int":
def get_nth_arg(self, *args) -> "tinfo_t":
def get_rettype(self, *args) -> "tinfo_t":
def get_nargs(self, *args) -> "int":
def is_user_cc(self, *args) -> "bool":
def is_vararg_cc(self, *args) -> "bool":
def is_purging_cc(self, *args) -> "bool":
def calc_purged_bytes(self, *args) -> "int":
def is_high_func(self, *args) -> "bool":
def get_methods(self, *args) -> "bool":
def set_methods(self, *args) -> "bool":
def find_udt_member(self, *args) -> "int":
def get_udt_nmembers(self, *args) -> "int":
def is_empty_udt(self, *args) -> "bool":
def is_small_udt(self, *args) -> "bool":
def requires_qualifier(self, *args) -> "bool":
def append_covered(self, *args) -> "bool":
def calc_gaps(self, *args) -> "bool":
def is_one_fpval(self, *args) -> "bool":
def is_sse_type(self, *args) -> "bool":
def is_anonymous_udt(self, *args) -> "bool":
def is_vftable(self, *args) -> "bool":
def has_vftable(self, *args) -> "bool":
def get_enum_base_type(self, *args) -> "type_t":
def get_onemember_type(self, *args) -> "tinfo_t":
def calc_score(self, *args) -> "uint32":
def _print(self, *args) -> "bool":
def dstr(self, *args) -> "char const *":
def get_attrs(self, *args) -> "bool":
def set_attrs(self, *args) -> "bool":
def set_attr(self, *args) -> "bool":
def del_attrs(self, *args) -> "void":
def del_attr(self, *args) -> "bool":
def create_simple_type(self, *args) -> "bool":
def create_ptr(self, *args) -> "bool":
def create_array(self, *args) -> "bool":
def create_typedef(self, *args) -> "void":
def create_bitfield(self, *args) -> "bool":
def create_udt(self, *args) -> "bool":
def create_enum(self, *args) -> "bool":
def create_func(self, *args) -> "bool":
def set_named_type(self, *args) -> "tinfo_code_t":
def set_symbol_type(self, *args) -> "tinfo_code_t":
def set_numbered_type(self, *args) -> "tinfo_code_t":
def create_forward_decl(self, *args) -> "tinfo_code_t":
def get_stock(*args) -> "tinfo_t":
def convert_array_to_ptr(self, *args) -> "bool":
def remove_ptr_or_array(self, *args) -> "bool":
def change_sign(self, *args) -> "bool":
def calc_udt_aligns(self, *args) -> "bool":
def read_bitfield_value(self, *args) -> "uint64":
def write_bitfield_value(self, *args) -> "uint64":
def get_modifiers(self, *args) -> "type_t":
def set_modifiers(self, *args) -> "void":
def set_const(self, *args) -> "void":
def set_volatile(self, *args) -> "void":
def clr_const(self, *args) -> "void":
def clr_volatile(self, *args) -> "void":
def clr_const_volatile(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def compare_with(self, *args) -> "bool":
def equals_to(self, *args) -> "bool":
def is_castable_to(self, *args) -> "bool":
def is_manually_castable_to(self, *args) -> "bool":
def serialize(self, *args) -> "PyObject *":
def deserialize(self, *args) -> "bool":
def copy(self, *args) -> "tinfo_t":
def __str__(self, *args) -> "qstring":
def get_attr(self, *args) -> "PyObject *":
def remove_pointer(*args) -> "tinfo_t":
def tinfo_t_get_stock(*args) -> "tinfo_t":
def __init__(self, *args):
def match_pattern(self, *args) -> "bool":
def guess_func_cc(*args) -> "cm_t":
def dump_func_type_data(*args) -> "qstring *":
def __init__(self, *args):
def swap(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def is_code_ptr(self, *args) -> "bool":
def is_shifted(self, *args) -> "bool":
def __init__(self, *args):
def swap(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __init__(self, *args):
the original typedef name (simple string)
def swap(self, *args) -> "void":
def is_high(self, *args) -> "bool":
def is_noret(self, *args) -> "bool":
def is_pure(self, *args) -> "bool":
def is_static(self, *args) -> "bool":
def is_virtual(self, *args) -> "bool":
def is_const(self, *args) -> "bool":
def is_ctor(self, *args) -> "bool":
def is_dtor(self, *args) -> "bool":
def get_call_method(self, *args) -> "int":
def is_vararg_cc(self, *args) -> "bool":
def is_golang_cc(self, *args) -> "bool":
def guess_cc(self, *args) -> "cm_t":
def dump(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def swap(self, *args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def is_64bit(self, *args) -> "bool":
def is_hex(self, *args) -> "bool":
def is_char(self, *args) -> "bool":
def is_sdec(self, *args) -> "bool":
def is_udec(self, *args) -> "bool":
def calc_nbytes(self, *args) -> "int":
def calc_mask(self, *args) -> "uint64":
def swap(self, *args) -> "void":
def __init__(self, *args):
def swap(self, *args) -> "void":
def __init__(self, *args):
def is_bitfield(self, *args) -> "bool":
def is_zero_bitfield(self, *args) -> "bool":
def is_unaligned(self, *args) -> "bool":
def is_baseclass(self, *args) -> "bool":
def is_virtbase(self, *args) -> "bool":
def is_vftable(self, *args) -> "bool":
def is_method(self, *args) -> "bool":
def set_unaligned(self, *args) -> "void":
def set_baseclass(self, *args) -> "void":
def set_virtbase(self, *args) -> "void":
def set_vftable(self, *args) -> "void":
def set_method(self, *args) -> "void":
def clr_unaligned(self, *args) -> "void":
def clr_baseclass(self, *args) -> "void":
def clr_virtbase(self, *args) -> "void":
def clr_vftable(self, *args) -> "void":
def clr_method(self, *args) -> "void":
def begin(self, *args) -> "uint64":
def end(self, *args) -> "uint64":
def __lt__(self, *args) -> "bool":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def swap(self, *args) -> "void":
def is_anonymous_udm(self, *args) -> "bool":
def __init__(self, *args):
def __init__(self, *args):
def swap(self, *args) -> "void":
def is_unaligned(self, *args) -> "bool":
def is_msstruct(self, *args) -> "bool":
def is_cppobj(self, *args) -> "bool":
def is_vftable(self, *args) -> "bool":
def set_vftable(self, *args) -> "void":
def is_last_baseclass(self, *args) -> "bool":
def __init__(self, *args):
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def __lt__(self, *args) -> "bool":
def __gt__(self, *args) -> "bool":
def __le__(self, *args) -> "bool":
def __ge__(self, *args) -> "bool":
def compare(self, *args) -> "int":
def swap(self, *args) -> "void":
def inf_pack_stkargs(*args) -> "bool":
def inf_big_arg_align(*args) -> "bool":
def __init__(self, *args):
def clear(self, *args) -> "void":
def set_new_type(self, *args) -> "void":
def set_new_name(self, *args) -> "void":
def set_new_cmt(self, *args) -> "void":
def has_type(self, *args) -> "bool":
def has_name(self, *args) -> "bool":
def has_cmt(self, *args) -> "bool":
def has_info(self, *args) -> "bool":
def __init__(self, *args):
def visit_type(self, *args) -> "int":
def prune_now(self, *args) -> "void":
def apply_to(self, *args) -> "int":
def __disown__(self):
def size(self, *args) -> "size_t":
def __init__(self, *args):
def __init__(self, *args):
def unpack_idcobj_from_idb(*args) -> "error_t":
def unpack_idcobj_from_bv(*args) -> "error_t":
def pack_idcobj_to_idb(*args) -> "error_t":
def pack_idcobj_to_bv(*args) -> "error_t":
def apply_tinfo_to_stkarg(*args) -> "bool":
def set_op_tinfo(self, *args) -> "bool":
def is_stkarg_load(self, *args) -> "bool":
def has_delay_slot(self, *args) -> "bool":
def use_arg_tinfos(self, *args) -> "void":
def __init__(self, *args):
def __disown__(self):
def gen_use_arg_tinfos2(*args) -> "void":
def func_has_stkframe_hole(*args) -> "bool":
def __init__(self, *args, **kwargs):
def func_has_stkframe_hole(self, *args) -> "bool":
def get_func_purged_bytes(self, *args) -> "int":
def __init__(self, *args):
def func_has_stkframe_hole(self, *args) -> "bool":
def get_func_purged_bytes(self, *args) -> "int":
def lower_type(*args) -> "int":
def replace_ordinal_typerefs(*args) -> "int":
def begin_type_updating(*args) -> "void":
def end_type_updating(*args) -> "void":
def __init__(self, *args):
def __init__(self, *args):
def _print(self, *args) -> "int":
def __init__(self, *args):
def __disown__(self):
def calc_number_of_children(*args) -> "int":
def get_enum_member_expr(*args) -> "qstring *":
def __init__(self, *args):
def should_display(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def choose_named_type(*args) -> "bool":
def choose_local_tinfo(*args) -> "uint32":
def choose_local_tinfo_and_delta(*args) -> "uint32":
def gen_use_arg_tinfos(*args) -> "void":
def idc_parse_decl(*args) -> "PyObject *":
def calc_type_size(*args) -> "PyObject *":
def apply_type(*args) -> "bool":
def get_arg_addrs(*args) -> "PyObject *":
def unpack_object_from_idb(*args) -> "PyObject *":
def unpack_object_from_bv(*args) -> "PyObject *":
def pack_object_to_idb(*args) -> "PyObject *":
def pack_object_to_bv(*args) -> "PyObject *":
def idc_parse_types(*args) -> "int":
def idc_get_type_raw(*args) -> "PyObject *":
def idc_get_local_type_raw(*args) -> "PyObject *":
def idc_guess_type(*args) -> "size_t":
def idc_get_type(*args) -> "size_t":
def idc_set_local_type(*args) -> "int":
def idc_get_local_type(*args) -> "int":
def idc_print_type(*args) -> "PyObject *":
def idc_get_local_type_name(*args) -> "size_t":
def get_named_type(*args) -> "PyObject *":
def get_named_type64(*args) -> "PyObject *":
def print_decls(*args) -> "PyObject *":
def remove_tinfo_pointer(*args) -> "PyObject *":
def get_numbered_type(*args) -> "PyObject *":
def __getattr__(self, attr):
def __setattr__(self, attr, value):
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def __init__(self, *args):
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "op_t const &":
def __setitem__(self, *args) -> "void":
def _get_bytes(self, *args) -> "bytevec_t":
def _set_bytes(self, *args) -> "void":
def set_shown(self, *args) -> "void":
def clr_shown(self, *args) -> "void":
def shown(self, *args) -> "bool":
def is_reg(self, *args) -> "bool":
def is_imm(self, *args) -> "bool":
def __get_reg_phrase__(self, *args) -> "uint16":
def __set_reg_phrase__(self, *args) -> "void":
def __get_value__(self, *args) -> "ea_t":
def __set_value__(self, *args) -> "void":
def __get_addr__(self, *args) -> "ea_t":
def __set_addr__(self, *args) -> "void":
def __get_specval__(self, *args) -> "ea_t":
def __set_specval__(self, *args) -> "void":
def assign(self, *args) -> "void":
def has_reg(self, r):
def __init__(self, *args):
def insn_add_cref(*args) -> "void":
def insn_add_dref(*args) -> "void":
def insn_add_off_drefs(*args) -> "ea_t":
def insn_create_stkvar(*args) -> "bool":
def __init__(self, *args):
def is_macro(self, *args) -> "bool":
def is_64bit(self, *args) -> "bool":
def get_next_byte(self, *args) -> "uint8":
def get_next_word(self, *args) -> "uint16":
def get_next_dword(self, *args) -> "uint32":
def get_next_qword(self, *args) -> "uint64":
def create_op_data(self, *args) -> "bool":
def create_stkvar(self, *args) -> "bool":
def add_cref(self, *args) -> "void":
def add_dref(self, *args) -> "void":
def add_off_drefs(self, *args) -> "ea_t":
def __get_ops__(self, *args) -> "wrapped_array_t< op_t,8 >":
def __get_operand__(self, *args) -> "op_t *":
def __get_auxpref__(self, *args) -> "uint32":
def __set_auxpref__(self, *args) -> "void":
def assign(self, *args) -> "void":
def is_canon_insn(self, *args) -> "bool":
def get_canon_feature(self, *args) -> "uint32":
def get_canon_mnem(self, *args) -> "char const *":
def __iter__(self):
def __getitem__(self, idx):
def get_lookback(*args) -> "int":
def calc_dataseg(*args) -> "ea_t":
def map_data_ea(*args) -> "ea_t":
def map_code_ea(*args) -> "ea_t":
def map_ea(*args) -> "ea_t":
def __init__(self, *args, **kwargs):
def only_main_line(self, *args) -> "bool":
def multiline(self, *args) -> "bool":
def force_code(self, *args) -> "bool":
def stack_view(self, *args) -> "bool":
def display_voids(self, *args) -> "bool":
def set_gen_xrefs(self, *args) -> "void":
def set_gen_cmt(self, *args) -> "void":
def clr_gen_label(self, *args) -> "void":
def set_gen_label(self, *args) -> "void":
def set_gen_demangled_label(self, *args) -> "void":
def set_comment_addr(self, *args) -> "void":
def set_dlbind_opnd(self, *args) -> "void":
def print_label_now(self, *args) -> "bool":
def forbid_annotations(self, *args) -> "int":
def restore_ctxflags(self, *args) -> "void":
def out_printf(self, *args) -> "void":
def out_value(self, *args) -> "flags_t":
def out_symbol(self, *args) -> "void":
def out_chars(self, *args) -> "void":
def out_spaces(self, *args) -> "void":
def out_line(self, *args) -> "void":
def out_keyword(self, *args) -> "void":
def out_register(self, *args) -> "void":
def out_tagon(self, *args) -> "void":
def out_tagoff(self, *args) -> "void":
def out_addr_tag(self, *args) -> "void":
def out_colored_register_line(self, *args) -> "void":
def out_char(self, *args) -> "void":
def out_btoa(self, *args) -> "void":
def out_long(self, *args) -> "void":
def out_name_expr(self, *args) -> "bool":
def close_comment(self, *args) -> "void":
def flush_outbuf(self, *args) -> "bool":
def flush_buf(self, *args) -> "bool":
def term_outctx(self, *args) -> "int":
def gen_printf(self, *args) -> "bool":
def gen_empty_line(self, *args) -> "bool":
def gen_border_line(self, *args) -> "bool":
def gen_cmt_line(self, *args) -> "bool":
def gen_collapsed_line(self, *args) -> "bool":
def gen_block_cmt(self, *args) -> "bool":
def setup_outctx(self, *args) -> "void":
def retrieve_cmt(self, *args) -> "ssize_t":
def retrieve_name(self, *args) -> "ssize_t":
def gen_xref_lines(self, *args) -> "bool":
def init_lines_array(self, *args) -> "void":
def get_stkvar(self, *args) -> "member_t *":
def gen_empty_line_without_annotations(self, *args) -> "void":
def __init__(self, *args, **kwargs):
def setup_outctx(self, *args) -> "void":
def retrieve_cmt(self, *args) -> "ssize_t":
def retrieve_name(self, *args) -> "ssize_t":
def gen_xref_lines(self, *args) -> "bool":
def set_bin_state(self, *args) -> "void":
def out_mnem(self, *args) -> "void":
def out_custom_mnem(self, *args) -> "void":
def out_mnemonic(self, *args) -> "void":
def out_one_operand(self, *args) -> "bool":
def out_immchar_cmts(self, *args) -> "void":
def gen_func_header(self, *args) -> "void":
def gen_func_footer(self, *args) -> "void":
def out_data(self, *args) -> "void":
def out_specea(self, *args) -> "bool":
def gen_header_extra(self, *args) -> "void":
def gen_header(self, *args) -> "void":
def create_outctx(*args) -> "outctx_base_t *":
def print_insn_mnem(*args) -> "qstring *":
def get_dtype_flag(*args) -> "flags_t":
def get_dtype_size(*args) -> "size_t":
def is_floating_dtype(*args) -> "bool":
def create_insn(*args) -> "int":
def decode_insn(*args) -> "int":
def can_decode(*args) -> "bool":
def print_operand(*args) -> "qstring *":
def decode_prev_insn(*args) -> "ea_t":
def build_macro(self, *args) -> "bool":
def __init__(self, *args):
def __disown__(self):
def construct_macro2(*args) -> "bool":
def decode_preceding_insn(*args) -> "PyObject *":
def construct_macro(*args) -> "bool":
def get_dtype_by_size(*args) -> "int":
def get_immvals(*args) -> "PyObject *":
def get_printable_immvals(*args) -> "PyObject *":
def insn_t__from_ptrval__(*args) -> "insn_t *":
def op_t__from_ptrval__(*args) -> "op_t *":
def outctx_base_t__from_ptrval__(*args) -> "outctx_base_t *":
def outctx_t__from_ptrval__(*args) -> "outctx_t *":
def _swig_repr(self):
def _swig_setattr_nondynamic_instance_variable(set):
def set_instance_attr(self, name, value):
def _swig_setattr_nondynamic_class_variable(set):
def set_class_attr(cls, name, value):
def _swig_add_metaclass(metaclass):
def wrapper(cls):
def create_switch_xrefs(*args) -> "bool":
def __init__(self, *args):
def calc_switch_cases(*args) -> "cases_and_targets_t *":
def create_switch_table(*args) -> "bool":
def xrefchar(*args) -> "char":
def add_cref(*args) -> "bool":
def del_cref(*args) -> "bool":
def add_dref(*args) -> "bool":
def del_dref(*args) -> "void":
def first_from(self, *args) -> "bool":
def first_to(self, *args) -> "bool":
def next_from(self, *args) -> "bool":
def next_to(self, *args) -> "bool":
def crefs_to(self, ea):
def fcrefs_to(self, ea):
def crefs_from(self, ea):
def fcrefs_from(self, ea):
def drefs_to(self, ea):
def drefs_from(self, ea):
def refs_from(self, ea, flag):
def _copy_xref():
def refs_to(self, ea, flag):
def _copy_xref():
def __init__(self, *args):
def get_first_dref_from(*args) -> "ea_t":
def get_next_dref_from(*args) -> "ea_t":
def get_first_dref_to(*args) -> "ea_t":
def get_next_dref_to(*args) -> "ea_t":
def get_first_cref_from(*args) -> "ea_t":
def get_next_cref_from(*args) -> "ea_t":
def get_first_cref_to(*args) -> "ea_t":
def get_next_cref_to(*args) -> "ea_t":
def get_first_fcref_from(*args) -> "ea_t":
def get_next_fcref_from(*args) -> "ea_t":
def get_first_fcref_to(*args) -> "ea_t":
def get_next_fcref_to(*args) -> "ea_t":
def has_external_refs(*args) -> "bool":
def delete_switch_table(*args) -> "void":
def __init__(self, *args):
def push_back(self, *args) -> "qvector< long long > &":
def pop_back(self, *args) -> "void":
def size(self, *args) -> "size_t":
def empty(self, *args) -> "bool":
def at(self, *args) -> "qvector< long long > const &":
def qclear(self, *args) -> "void":
def clear(self, *args) -> "void":
def resize(self, *args) -> "void":
def grow(self, *args) -> "void":
def capacity(self, *args) -> "size_t":
def reserve(self, *args) -> "void":
def truncate(self, *args) -> "void":
def swap(self, *args) -> "void":
def extract(self, *args) -> "qvector< long long > *":
def inject(self, *args) -> "void":
def __eq__(self, *args) -> "bool":
def __ne__(self, *args) -> "bool":
def begin(self, *args) -> "qvector< qvector< long long > >::const_iterator":
def end(self, *args) -> "qvector< qvector< long long > >::const_iterator":
def insert(self, *args) -> "qvector< qvector< long long > >::iterator":
def erase(self, *args) -> "qvector< qvector< long long > >::iterator":
def find(self, *args) -> "qvector< qvector< long long > >::const_iterator":
def has(self, *args) -> "bool":
def add_unique(self, *args) -> "bool":
def _del(self, *args) -> "bool":
def __len__(self, *args) -> "size_t":
def __getitem__(self, *args) -> "qvector< long long > const &":
def __setitem__(self, *args) -> "void":
def __warn_once_deprecated_proto_confusion(what, alternative):
def _IDC_GetAttr(obj, attrmap, attroffs):
def _IDC_SetAttr(obj, attrmap, attroffs, value):
def has_value(F): return ((F & FF_IVL) != 0) # any defined value?
def byte_value(F):
def is_loaded(ea):
def is_code(F):   return ((F & MS_CLS) == FF_CODE) # is code byte?
def is_data(F):   return ((F & MS_CLS) == FF_DATA) # is data byte?
def is_tail(F):   return ((F & MS_CLS) == FF_TAIL) # is tail byte?
def is_unknown(F):return ((F & MS_CLS) == FF_UNK)  # is unexplored byte?
def is_head(F):   return ((F & FF_DATA) != 0)  # is start of code/data?
def is_flow(F):   return ((F & FF_FLOW) != 0)
def isExtra(F):  return ((F & FF_LINE) != 0)
def isRef(F):return ((F & FF_REF)  != 0)
def hasName(F):  return ((F & FF_NAME) != 0)
def hasUserName(F):  return ((F & FF_ANYNAME) == FF_NAME)
def is_defarg0(F):return ((F & MS_0TYPE) != FF_0VOID)
def is_defarg1(F):return ((F & MS_1TYPE) != FF_1VOID)
def isDec0(F):   return ((F & MS_0TYPE) == FF_0NUMD)
def isDec1(F):   return ((F & MS_1TYPE) == FF_1NUMD)
def isHex0(F):   return ((F & MS_0TYPE) == FF_0NUMH)
def isHex1(F):   return ((F & MS_1TYPE) == FF_1NUMH)
def isOct0(F):   return ((F & MS_0TYPE) == FF_0NUMO)
def isOct1(F):   return ((F & MS_1TYPE) == FF_1NUMO)
def isBin0(F):   return ((F & MS_0TYPE) == FF_0NUMB)
def isBin1(F):   return ((F & MS_1TYPE) == FF_1NUMB)
def is_off0(F):   return ((F & MS_0TYPE) == FF_0OFF)
def is_off1(F):   return ((F & MS_1TYPE) == FF_1OFF)
def is_char0(F):  return ((F & MS_0TYPE) == FF_0CHAR)
def is_char1(F):  return ((F & MS_1TYPE) == FF_1CHAR)
def is_seg0(F):   return ((F & MS_0TYPE) == FF_0SEG)
def is_seg1(F):   return ((F & MS_1TYPE) == FF_1SEG)
def is_enum0(F):  return ((F & MS_0TYPE) == FF_0ENUM)
def is_enum1(F):  return ((F & MS_1TYPE) == FF_1ENUM)
def is_manual0(F):   return ((F & MS_0TYPE) == FF_0FOP)
def is_manual1(F):   return ((F & MS_1TYPE) == FF_1FOP)
def is_stroff0(F):return ((F & MS_0TYPE) == FF_0STRO)
def is_stroff1(F):return ((F & MS_1TYPE) == FF_1STRO)
def is_stkvar0(F):return ((F & MS_0TYPE) == FF_0STK)
def is_stkvar1(F):return ((F & MS_1TYPE) == FF_1STK)
def is_byte(F): return (is_data(F) and (F & DT_TYPE) == FF_BYTE)
def is_word(F): return (is_data(F) and (F & DT_TYPE) == FF_WORD)
def is_dword(F): return (is_data(F) and (F & DT_TYPE) == FF_DWORD)
def is_qword(F): return (is_data(F) and (F & DT_TYPE) == FF_QWORD)
def is_oword(F): return (is_data(F) and (F & DT_TYPE) == FF_OWORD)
def is_tbyte(F): return (is_data(F) and (F & DT_TYPE) == FF_TBYTE)
def is_float(F):return (is_data(F) and (F & DT_TYPE) == FF_FLOAT)
def is_double(F):   return (is_data(F) and (F & DT_TYPE) == FF_DOUBLE)
def is_pack_real(F): return (is_data(F) and (F & DT_TYPE) == FF_PACKREAL)
def is_strlit(F):return (is_data(F) and (F & DT_TYPE) == FF_STRLIT)
def is_struct(F):   return (is_data(F) and (F & DT_TYPE) == FF_STRUCT)
def is_align(F):return (is_data(F) and (F & DT_TYPE) == FF_ALIGN)
def value_is_string(var): raise NotImplementedError("this function is not needed in Python")
def value_is_long(var):   raise NotImplementedError("this function is not needed in Python")
def value_is_float(var):  raise NotImplementedError("this function is not needed in Python")
def value_is_func(var):   raise NotImplementedError("this function is not needed in Python")
def value_is_pvoid(var):  raise NotImplementedError("this function is not needed in Python")
def value_is_int64(var):  raise NotImplementedError("this function is not needed in Python")
def to_ea(seg, off):
def form(format, *args):
def substr(s, x1, x2):
def strstr(s1, s2):
def strlen(s):
def xtol(s):
def atoa(ea):
def ltoa(n, radix):
def atol(s):
def rotate_left(value, count, nbits, offset):
def rotate_dword(x, count): return rotate_left(x, count, 32, 0)
def rotate_word(x, count):  return rotate_left(x, count, 16, 0)
def rotate_byte(x, count):  return rotate_left(x, count, 8, 0)
def eval_idc(expr):
def EVAL_FAILURE(code):
def save_database(idbname, flags=0):
def validate_idb_names(do_repair = 0):
def call_system(command):
def qsleep(milliseconds):
def delete_all_segments():
def plan_and_wait(sEA, eEA, final_pass=True):
def set_name(ea, name, flags=ida_name.SN_CHECK):
def make_array(ea, nitems):
def create_strlit(ea, endea):
def create_byte(ea):
def create_word(ea):
def create_dword(ea):
def create_qword(ea):
def create_oword(ea):
def create_yword(ea):
def create_float(ea):
def create_double(ea):
def create_pack_real(ea):
def create_tbyte(ea):
def create_struct(ea, size, strname):
def define_local_var(start, end, location, name):
def set_array_params(ea, flags, litems, align):
def op_plain_offset(ea, n, base):
def toggle_bnot(ea, n):
def op_stroff(ea, n, strid, delta):
def op_offset_high16(ea, n, target):
def MakeVar(ea):
def split_sreg_range(ea, reg, value, tag=SR_user):
def AutoMark(ea,qtype):
def gen_file(filetype, path, ea1, ea2, flags):
def gen_flow_graph(outfile, title, ea1, ea2, flags):
def gen_simple_call_chart(outfile, title, flags):
def idadir():
def get_idb_path():
def get_bytes(ea, size, use_dbg = False):
def __DbgValue(ea, len):
def read_dbg_byte(ea):
def read_dbg_word(ea):
def read_dbg_dword(ea):
def read_dbg_qword(ea):
def write_dbg_memory(ea, data):
def GetFloat(ea):
def GetDouble(ea):
def get_name_ea_simple(name):
def get_segm_by_sel(base):
def get_curline():
def read_selection_start():
def read_selection_end():
def get_sreg(ea, reg):
def next_head(ea, maxea=BADADDR):
def prev_head(ea, minea=0):
def get_item_size(ea):
def func_contains(func_ea, ea):
def get_name(ea, gtn_flags=0):
def demangle_name(name, disable_mask):
def generate_disasm_line(ea, flags):
def GetDisasm(ea):
def print_insn_mnem(ea):
def print_operand(ea, n):
def get_operand_type(ea, n):
def get_operand_value(ea, n):
def get_strlit_contents(ea, length = -1, strtype = STRTYPE_C):
def get_str_type(ea):
def find_text(ea, flag, y, x, searchstr):
def find_binary(ea, flag, searchstr, radix=16):
def process_config_line(directive):
def _import_module_flag_sets(module, prefixes):
def get_inf_attr(attr):
def set_inf_attr(attr, value):
def SetPrcsr(processor): return set_processor_type(processor, SETPROC_USER)
def batch(batch):
def process_ui_action(name, flags=0):
def sel2para(sel):
def find_selector(val):
def get_first_seg():
def get_next_seg(ea):
def get_segm_start(ea):
def get_segm_end(ea):
def get_segm_name(ea):
def add_segm_ex(startea, endea, base, use32, align, comb, flags):
def AddSeg(startea, endea, base, use32, align, comb):
def set_segment_bounds(ea, startea, endea, flags):
def set_segm_name(ea, name):
def set_segm_class(ea, segclass):
def set_segm_alignment(ea, alignment):
def set_segm_combination(segea, comb):
def set_segm_addressing(ea, bitness):
def selector_by_name(segname):
def set_default_sreg_value(ea, reg, value):
def set_segm_type(segea, segtype):
def get_segm_attr(segea, attr):
def set_segm_attr(segea, attr, value):
def move_segm(ea, to, flags):
def get_xref_type():
def fopen(f, mode):
def fclose(handle):
def filelength(handle):
def fseek(handle, offset, origin):
def ftell(handle):
def LoadFile(filepath, pos, ea, size):
def loadfile(filepath, pos, ea, size): return LoadFile(filepath, pos, ea, size)
def SaveFile(filepath, pos, ea, size):
def savefile(filepath, pos, ea, size): return SaveFile(filepath, pos, ea, size)
def fgetc(handle):
def fputc(byte, handle):
def fprintf(handle, format, *args):
def readshort(handle, mostfirst):
def readlong(handle, mostfirst):
def writeshort(handle, word, mostfirst):
def writelong(handle, dword, mostfirst):
def readstr(handle):
def writestr(handle, s):
def get_next_func(ea):
def get_prev_func(ea):
def get_func_attr(ea, attr):
def set_func_attr(ea, attr, value):
def get_func_flags(ea):
def set_func_flags(ea, flags):
def get_func_name(ea):
def get_func_cmt(ea, repeatable):
def set_func_cmt(ea, cmt, repeatable):
def choose_func(title):
def get_func_off_str(ea):
def find_func_end(ea):
def get_frame_id(ea):
def get_frame_lvar_size(ea):
def get_frame_regs_size(ea):
def get_frame_args_size(ea):
def get_frame_size(ea):
def set_frame_size(ea, lvsize, frregs, argsize):
def get_spd(ea):
def get_sp_delta(ea):
def add_auto_stkpnt(func_ea, ea, delta):
def del_stkpnt(func_ea, ea):
def get_min_spd_ea(func_ea):
def get_fixup_target_type(ea):
def get_fixup_target_flags(ea):
def get_fixup_target_sel(ea):
def get_fixup_target_off(ea):
def get_fixup_target_dis(ea):
def set_fixup(ea, fixuptype, fixupflags, targetsel, targetoff, displ):
def get_member_qty(sid):
def get_member_id(sid, member_offset):
def get_prev_offset(sid, offset):
def get_next_offset(sid, offset):
def get_first_member(sid):
def get_last_member(sid):
def get_member_offset(sid, member_name):
def get_member_name(sid, member_offset):
def get_member_cmt(sid, member_offset, repeatable):
def get_member_size(sid, member_offset):
def get_member_flag(sid, member_offset):
def get_member_strid(sid, member_offset):
def is_union(sid):
def add_struc(index, name, is_union):
def del_struc(sid):
def set_struc_idx(sid, index):
def add_struc_member(sid, name, offset, flag, typeid, nbytes, target=-1, tdelta=0, reftype=REF_OFF32):
def del_struc_member(sid, member_offset):
def set_member_name(sid, member_offset, name):
def set_member_type(sid, member_offset, flag, typeid, nitems, target=-1, tdelta=0, reftype=REF_OFF32):
def set_member_cmt(sid, member_offset, comment, repeatable):
def expand_struc(sid, offset, delta, recalc):
def get_fchunk_attr(ea, attr):
def set_fchunk_attr(ea, attr, value):
def get_next_fchunk(ea):
def get_prev_fchunk(ea):
def append_func_tail(funcea, ea1, ea2):
def remove_fchunk(funcea, tailea):
def set_tail_owner(tailea, funcea):
def first_func_chunk(funcea):
def next_func_chunk(funcea, tailea):
def get_enum_member(enum_id, value, serial, bmask):
def get_bmask_name(enum_id, bmask):
def get_bmask_cmt(enum_id, bmask, repeatable):
def set_bmask_name(enum_id, bmask, name):
def set_bmask_cmt(enum_id, bmask, cmt, repeatable):
def get_first_enum_member(enum_id, bmask):
def get_last_enum_member(enum_id, bmask):
def get_next_enum_member(enum_id, value, bmask):
def get_prev_enum_member(enum_id, value, bmask):
def get_enum_member_name(const_id):
def get_enum_member_cmt(const_id, repeatable):
def add_enum(idx, name, flag):
def add_enum_member(enum_id, name, value, bmask):
def del_enum_member(enum_id, value, serial, bmask):
def __l2m1(v):
def rename(self, *args): return 0
def kill(self, *args): pass
def index(self, *args): return -1
def altset(self, *args): return 0
def supset(self, *args): return 0
def altval(self, *args): return 0
def supval(self, *args): return 0
def altdel(self, *args): return 0
def supdel(self, *args): return 0
def altfirst(self, *args): return -1
def supfirst(self, *args): return -1
def altlast(self, *args): return -1
def suplast(self, *args): return -1
def altnext(self, *args): return -1
def supnext(self, *args): return -1
def altprev(self, *args): return -1
def supprev(self, *args): return -1
def hashset(self, *args): return 0
def hashval(self, *args): return 0
def hashstr(self, *args): return 0
def hashstr_buf(self, *args): return 0
def hashset_idx(self, *args): return 0
def hashset_buf(self, *args): return 0
def hashval_long(self, *args): return 0
def hashdel(self, *args): return 0
def hashfirst(self, *args): return 0
def hashnext(self, *args): return 0
def hashprev(self, *args): return 0
def hashlast(self, *args): return 0
def __GetArrayById(array_id):
def create_array(name):
def get_array_id(name):
def rename_array(array_id, newname):
def delete_array(array_id):
def set_array_long(array_id, idx, value):
def set_array_string(array_id, idx, value):
def get_array_element(tag, array_id, idx):
def del_array_element(tag, array_id, idx):
def get_first_index(tag, array_id):
def get_last_index(tag, array_id):
def get_next_index(tag, array_id, idx):
def get_prev_index(tag, array_id, idx):
def set_hash_long(hash_id, key, value):
def get_hash_long(hash_id, key):
def set_hash_string(hash_id, key, value):
def get_hash_string(hash_id, key):
def del_hash_string(hash_id, key):
def get_first_hash_key(hash_id):
def get_last_hash_key(hash_id):
def get_next_hash_key(hash_id, key):
def get_prev_hash_key(hash_id, key):
def add_default_til(name):
def import_type(idx, type_name):
def get_type(ea):
def SizeOf(typestr):
def get_tinfo(ea):
def get_local_tinfo(ordinal):
def guess_type(ea):
def apply_type(ea, py_type, flags = TINFO_DEFINITE):
def SetType(ea, newtype):
def parse_decl(inputtype, flags):
def parse_decls(inputtype, flags = 0):
def print_decls(ordinals, flags):
def __init__(self):
def _print(self, defstr):
def get_ordinal_qty():
def set_local_type(ordinal, input, flags):
def GetLocalType(ordinal, flags):
def get_numbered_type_name(ordinal):
def update_hidden_range(ea, visible):
def _get_modules():
def get_first_module():
def get_next_module(base):
def get_module_name(base):
def get_module_size(base):
def resume_process():
def send_dbg_command(cmd):
def get_event_id():
def get_event_pid():
def get_event_tid():
def get_event_ea():
def is_event_handled():
def get_event_module_name():
def get_event_module_base():
def get_event_module_size():
def get_event_exit_code():
def get_event_info():
def get_event_bpt_hea():
def get_event_exc_code():
def get_event_exc_ea():
def can_exc_continue():
def get_event_exc_info():
def set_reg_value(value, name):
def get_bpt_ea(n):
def get_bpt_attr(ea, bptattr):
def set_bpt_attr(address, bptattr, value):
def set_bpt_cond(ea, cnd, is_lowcnd=0):
def enable_tracing(trace_level, enable):
def clear_trace(filename):
def get_color(ea, what):
def set_color(ea, what, color):
def force_bl_jump(ea):
def force_bl_call(ea):
def set_flag(off, bit, value):
def here(): return get_screen_ea()
def is_mapped(ea): return (prev_addr(ea+1)==ea)
def write(self, text):
def flush(self):
def isatty(self):
def runscript(script):
def print_banner():
def readline(self):
